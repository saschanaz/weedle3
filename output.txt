#![feature(prelude_import)]
//! Weedle - A WebIDL Parser
//!
//! Parses valid WebIDL definitions & produces a data structure starting from
//! [`Definitions`](struct.Definitions.html).
//!
//! ### Example
//!
//! ```
//! extern crate weedle;
//!
//! let parsed = weedle::parse("
//!     interface Window {
//!         readonly attribute Storage sessionStorage;
//!     };
//! ").unwrap();
//! println!("{:?}", parsed);
//! ```
//!
//! Note:
//! This parser follows the grammar given at [WebIDL](https://heycam.github.io/webidl).
//!
//! If any flaws found when parsing string with a valid grammar, create an issue.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use crate::tokens::contextful_cut;
use self::argument::ArgumentList;
use self::attribute::ExtendedAttributeList;
use self::common::{Braced, Identifier, Parenthesized, PunctuatedNonEmpty};
use self::dictionary::DictionaryMembers;
use self::interface::{CallbackInterfaceMembers, Inheritance, InterfaceMembers};
use self::literal::StringLit;
use self::mixin::MixinMembers;
use self::namespace::NamespaceMembers;
use self::types::{AttributedType, Type};
use weedle_derive::Weedle;
#[macro_use]
mod macros {
    pub fn annotate<'slice, 'token, F, R>(f: F) -> F
    where
        F: Fn(
            crate::tokens::Tokens<'slice, 'token>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'token>, R>,
        'token: 'slice,
    {
        f
    }
}
mod whitespace {
    pub(crate) fn sp(input: &str) -> crate::VerboseResult<&str, &str> {
        nom::combinator::recognize(
            nom::multi::many0(
                nom::branch::alt((
                    nom::combinator::value(
                        (),
                        nom::sequence::tuple((
                            nom::bytes::complete::tag("//"),
                            nom::bytes::complete::take_until("\n"),
                            nom::bytes::complete::tag("\n"),
                        )),
                    ),
                    nom::combinator::value((), nom::character::complete::multispace1),
                    nom::combinator::value(
                        (),
                        nom::sequence::tuple((
                            nom::bytes::complete::tag("/*"),
                            nom::bytes::complete::take_until("*/"),
                            nom::bytes::complete::tag("*/"),
                        )),
                    ),
                )),
            ),
        )(input)
    }
}
#[macro_use]
pub mod term {
    /// Represents the terminal symbol `(`
    pub struct OpenParen;
    #[automatically_derived]
    impl ::core::marker::Copy for OpenParen {}
    #[automatically_derived]
    impl ::core::default::Default for OpenParen {
        #[inline]
        fn default() -> OpenParen {
            OpenParen {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OpenParen {
        #[inline]
        fn clone(&self) -> OpenParen {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OpenParen {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "OpenParen")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OpenParen {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OpenParen {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OpenParen {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OpenParen {
        #[inline]
        fn eq(&self, other: &OpenParen) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for OpenParen {
        #[inline]
        fn cmp(&self, other: &OpenParen) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for OpenParen {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OpenParen,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OpenParen {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl OpenParen {
        pub fn value(&self) -> &'static str {
            return "(";
        }
    }
    impl<'a> crate::Parse<'a> for OpenParen {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::OpenParen(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for OpenParen {}
    /// Represents the terminal symbol `)`
    pub struct CloseParen;
    #[automatically_derived]
    impl ::core::marker::Copy for CloseParen {}
    #[automatically_derived]
    impl ::core::default::Default for CloseParen {
        #[inline]
        fn default() -> CloseParen {
            CloseParen {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CloseParen {
        #[inline]
        fn clone(&self) -> CloseParen {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CloseParen {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "CloseParen")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for CloseParen {}
    #[automatically_derived]
    impl ::core::cmp::Eq for CloseParen {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CloseParen {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CloseParen {
        #[inline]
        fn eq(&self, other: &CloseParen) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for CloseParen {
        #[inline]
        fn cmp(&self, other: &CloseParen) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for CloseParen {
        #[inline]
        fn partial_cmp(
            &self,
            other: &CloseParen,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for CloseParen {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl CloseParen {
        pub fn value(&self) -> &'static str {
            return ")";
        }
    }
    impl<'a> crate::Parse<'a> for CloseParen {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::CloseParen(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for CloseParen {}
    /// Represents the terminal symbol `[`
    pub struct OpenBracket;
    #[automatically_derived]
    impl ::core::marker::Copy for OpenBracket {}
    #[automatically_derived]
    impl ::core::default::Default for OpenBracket {
        #[inline]
        fn default() -> OpenBracket {
            OpenBracket {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OpenBracket {
        #[inline]
        fn clone(&self) -> OpenBracket {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OpenBracket {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "OpenBracket")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OpenBracket {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OpenBracket {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OpenBracket {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OpenBracket {
        #[inline]
        fn eq(&self, other: &OpenBracket) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for OpenBracket {
        #[inline]
        fn cmp(&self, other: &OpenBracket) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for OpenBracket {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OpenBracket,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OpenBracket {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl OpenBracket {
        pub fn value(&self) -> &'static str {
            return "[";
        }
    }
    impl<'a> crate::Parse<'a> for OpenBracket {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::OpenBracket(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for OpenBracket {}
    /// Represents the terminal symbol `]`
    pub struct CloseBracket;
    #[automatically_derived]
    impl ::core::marker::Copy for CloseBracket {}
    #[automatically_derived]
    impl ::core::default::Default for CloseBracket {
        #[inline]
        fn default() -> CloseBracket {
            CloseBracket {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CloseBracket {
        #[inline]
        fn clone(&self) -> CloseBracket {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CloseBracket {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "CloseBracket")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for CloseBracket {}
    #[automatically_derived]
    impl ::core::cmp::Eq for CloseBracket {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CloseBracket {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CloseBracket {
        #[inline]
        fn eq(&self, other: &CloseBracket) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for CloseBracket {
        #[inline]
        fn cmp(&self, other: &CloseBracket) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for CloseBracket {
        #[inline]
        fn partial_cmp(
            &self,
            other: &CloseBracket,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for CloseBracket {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl CloseBracket {
        pub fn value(&self) -> &'static str {
            return "]";
        }
    }
    impl<'a> crate::Parse<'a> for CloseBracket {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::CloseBracket(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for CloseBracket {}
    /// Represents the terminal symbol `{`
    pub struct OpenBrace;
    #[automatically_derived]
    impl ::core::marker::Copy for OpenBrace {}
    #[automatically_derived]
    impl ::core::default::Default for OpenBrace {
        #[inline]
        fn default() -> OpenBrace {
            OpenBrace {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OpenBrace {
        #[inline]
        fn clone(&self) -> OpenBrace {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OpenBrace {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "OpenBrace")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OpenBrace {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OpenBrace {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OpenBrace {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OpenBrace {
        #[inline]
        fn eq(&self, other: &OpenBrace) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for OpenBrace {
        #[inline]
        fn cmp(&self, other: &OpenBrace) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for OpenBrace {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OpenBrace,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OpenBrace {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl OpenBrace {
        pub fn value(&self) -> &'static str {
            return "{";
        }
    }
    impl<'a> crate::Parse<'a> for OpenBrace {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::OpenBrace(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for OpenBrace {}
    /// Represents the terminal symbol `}`
    pub struct CloseBrace;
    #[automatically_derived]
    impl ::core::marker::Copy for CloseBrace {}
    #[automatically_derived]
    impl ::core::default::Default for CloseBrace {
        #[inline]
        fn default() -> CloseBrace {
            CloseBrace {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CloseBrace {
        #[inline]
        fn clone(&self) -> CloseBrace {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CloseBrace {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "CloseBrace")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for CloseBrace {}
    #[automatically_derived]
    impl ::core::cmp::Eq for CloseBrace {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CloseBrace {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CloseBrace {
        #[inline]
        fn eq(&self, other: &CloseBrace) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for CloseBrace {
        #[inline]
        fn cmp(&self, other: &CloseBrace) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for CloseBrace {
        #[inline]
        fn partial_cmp(
            &self,
            other: &CloseBrace,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for CloseBrace {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl CloseBrace {
        pub fn value(&self) -> &'static str {
            return "}";
        }
    }
    impl<'a> crate::Parse<'a> for CloseBrace {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::CloseBrace(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for CloseBrace {}
    /// Represents the terminal symbol `,`
    pub struct Comma;
    #[automatically_derived]
    impl ::core::marker::Copy for Comma {}
    #[automatically_derived]
    impl ::core::default::Default for Comma {
        #[inline]
        fn default() -> Comma {
            Comma {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Comma {
        #[inline]
        fn clone(&self) -> Comma {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Comma {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Comma")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Comma {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Comma {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Comma {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Comma {
        #[inline]
        fn eq(&self, other: &Comma) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Comma {
        #[inline]
        fn cmp(&self, other: &Comma) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Comma {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Comma,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Comma {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Comma {
        pub fn value(&self) -> &'static str {
            return ",";
        }
    }
    impl<'a> crate::Parse<'a> for Comma {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Comma(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Comma {}
    /// Represents the terminal symbol `-`
    pub struct Minus;
    #[automatically_derived]
    impl ::core::marker::Copy for Minus {}
    #[automatically_derived]
    impl ::core::default::Default for Minus {
        #[inline]
        fn default() -> Minus {
            Minus {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Minus {
        #[inline]
        fn clone(&self) -> Minus {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Minus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Minus")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Minus {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Minus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Minus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Minus {
        #[inline]
        fn eq(&self, other: &Minus) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Minus {
        #[inline]
        fn cmp(&self, other: &Minus) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Minus {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Minus,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Minus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Minus {
        pub fn value(&self) -> &'static str {
            return "-";
        }
    }
    impl<'a> crate::Parse<'a> for Minus {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Minus(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Minus {}
    /// Represents the terminal symbol `...`
    pub struct Ellipsis;
    #[automatically_derived]
    impl ::core::marker::Copy for Ellipsis {}
    #[automatically_derived]
    impl ::core::default::Default for Ellipsis {
        #[inline]
        fn default() -> Ellipsis {
            Ellipsis {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Ellipsis {
        #[inline]
        fn clone(&self) -> Ellipsis {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Ellipsis {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Ellipsis")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Ellipsis {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Ellipsis {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ellipsis {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ellipsis {
        #[inline]
        fn eq(&self, other: &Ellipsis) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Ellipsis {
        #[inline]
        fn cmp(&self, other: &Ellipsis) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Ellipsis {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Ellipsis,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Ellipsis {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Ellipsis {
        pub fn value(&self) -> &'static str {
            return "...";
        }
    }
    impl<'a> crate::Parse<'a> for Ellipsis {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Ellipsis(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Ellipsis {}
    /// Represents the terminal symbol `.`
    pub struct Dot;
    #[automatically_derived]
    impl ::core::marker::Copy for Dot {}
    #[automatically_derived]
    impl ::core::default::Default for Dot {
        #[inline]
        fn default() -> Dot {
            Dot {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Dot {
        #[inline]
        fn clone(&self) -> Dot {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Dot {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Dot")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Dot {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Dot {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Dot {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Dot {
        #[inline]
        fn eq(&self, other: &Dot) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Dot {
        #[inline]
        fn cmp(&self, other: &Dot) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Dot {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Dot,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Dot {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Dot {
        pub fn value(&self) -> &'static str {
            return ".";
        }
    }
    impl<'a> crate::Parse<'a> for Dot {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Dot(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Dot {}
    /// Represents the terminal symbol `:`
    pub struct Colon;
    #[automatically_derived]
    impl ::core::marker::Copy for Colon {}
    #[automatically_derived]
    impl ::core::default::Default for Colon {
        #[inline]
        fn default() -> Colon {
            Colon {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Colon {
        #[inline]
        fn clone(&self) -> Colon {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Colon {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Colon")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Colon {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Colon {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Colon {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Colon {
        #[inline]
        fn eq(&self, other: &Colon) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Colon {
        #[inline]
        fn cmp(&self, other: &Colon) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Colon {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Colon,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Colon {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Colon {
        pub fn value(&self) -> &'static str {
            return ":";
        }
    }
    impl<'a> crate::Parse<'a> for Colon {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Colon(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Colon {}
    /// Represents the terminal symbol `;`
    pub struct SemiColon;
    #[automatically_derived]
    impl ::core::marker::Copy for SemiColon {}
    #[automatically_derived]
    impl ::core::default::Default for SemiColon {
        #[inline]
        fn default() -> SemiColon {
            SemiColon {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SemiColon {
        #[inline]
        fn clone(&self) -> SemiColon {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SemiColon {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "SemiColon")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for SemiColon {}
    #[automatically_derived]
    impl ::core::cmp::Eq for SemiColon {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SemiColon {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SemiColon {
        #[inline]
        fn eq(&self, other: &SemiColon) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for SemiColon {
        #[inline]
        fn cmp(&self, other: &SemiColon) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for SemiColon {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SemiColon,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for SemiColon {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl SemiColon {
        pub fn value(&self) -> &'static str {
            return ";";
        }
    }
    impl<'a> crate::Parse<'a> for SemiColon {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::SemiColon(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for SemiColon {}
    /// Represents the terminal symbol `<`
    pub struct LessThan;
    #[automatically_derived]
    impl ::core::marker::Copy for LessThan {}
    #[automatically_derived]
    impl ::core::default::Default for LessThan {
        #[inline]
        fn default() -> LessThan {
            LessThan {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LessThan {
        #[inline]
        fn clone(&self) -> LessThan {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LessThan {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "LessThan")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for LessThan {}
    #[automatically_derived]
    impl ::core::cmp::Eq for LessThan {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LessThan {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LessThan {
        #[inline]
        fn eq(&self, other: &LessThan) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for LessThan {
        #[inline]
        fn cmp(&self, other: &LessThan) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for LessThan {
        #[inline]
        fn partial_cmp(
            &self,
            other: &LessThan,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for LessThan {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl LessThan {
        pub fn value(&self) -> &'static str {
            return "<";
        }
    }
    impl<'a> crate::Parse<'a> for LessThan {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::LessThan(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for LessThan {}
    /// Represents the terminal symbol `=`
    pub struct Assign;
    #[automatically_derived]
    impl ::core::marker::Copy for Assign {}
    #[automatically_derived]
    impl ::core::default::Default for Assign {
        #[inline]
        fn default() -> Assign {
            Assign {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Assign {
        #[inline]
        fn clone(&self) -> Assign {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Assign {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Assign")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Assign {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Assign {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Assign {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Assign {
        #[inline]
        fn eq(&self, other: &Assign) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Assign {
        #[inline]
        fn cmp(&self, other: &Assign) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Assign {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Assign,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Assign {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Assign {
        pub fn value(&self) -> &'static str {
            return "=";
        }
    }
    impl<'a> crate::Parse<'a> for Assign {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Assign(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Assign {}
    /// Represents the terminal symbol `>`
    pub struct GreaterThan;
    #[automatically_derived]
    impl ::core::marker::Copy for GreaterThan {}
    #[automatically_derived]
    impl ::core::default::Default for GreaterThan {
        #[inline]
        fn default() -> GreaterThan {
            GreaterThan {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GreaterThan {
        #[inline]
        fn clone(&self) -> GreaterThan {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for GreaterThan {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "GreaterThan")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for GreaterThan {}
    #[automatically_derived]
    impl ::core::cmp::Eq for GreaterThan {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for GreaterThan {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for GreaterThan {
        #[inline]
        fn eq(&self, other: &GreaterThan) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for GreaterThan {
        #[inline]
        fn cmp(&self, other: &GreaterThan) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for GreaterThan {
        #[inline]
        fn partial_cmp(
            &self,
            other: &GreaterThan,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for GreaterThan {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl GreaterThan {
        pub fn value(&self) -> &'static str {
            return ">";
        }
    }
    impl<'a> crate::Parse<'a> for GreaterThan {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::GreaterThan(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for GreaterThan {}
    /// Represents the terminal symbol `?`
    pub struct QMark;
    #[automatically_derived]
    impl ::core::marker::Copy for QMark {}
    #[automatically_derived]
    impl ::core::default::Default for QMark {
        #[inline]
        fn default() -> QMark {
            QMark {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for QMark {
        #[inline]
        fn clone(&self) -> QMark {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for QMark {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "QMark")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for QMark {}
    #[automatically_derived]
    impl ::core::cmp::Eq for QMark {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for QMark {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for QMark {
        #[inline]
        fn eq(&self, other: &QMark) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for QMark {
        #[inline]
        fn cmp(&self, other: &QMark) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for QMark {
        #[inline]
        fn partial_cmp(
            &self,
            other: &QMark,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for QMark {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl QMark {
        pub fn value(&self) -> &'static str {
            return "?";
        }
    }
    impl<'a> crate::Parse<'a> for QMark {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::QMark(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for QMark {}
    /// Represents the terminal symbol `*`
    pub struct Wildcard;
    #[automatically_derived]
    impl ::core::marker::Copy for Wildcard {}
    #[automatically_derived]
    impl ::core::default::Default for Wildcard {
        #[inline]
        fn default() -> Wildcard {
            Wildcard {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Wildcard {
        #[inline]
        fn clone(&self) -> Wildcard {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Wildcard {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Wildcard")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Wildcard {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Wildcard {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Wildcard {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Wildcard {
        #[inline]
        fn eq(&self, other: &Wildcard) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Wildcard {
        #[inline]
        fn cmp(&self, other: &Wildcard) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Wildcard {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Wildcard,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Wildcard {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Wildcard {
        pub fn value(&self) -> &'static str {
            return "*";
        }
    }
    impl<'a> crate::Parse<'a> for Wildcard {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Wildcard(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Wildcard {}
    ///Represents the terminal symbol `
    ///or
    ///`
    pub struct Or;
    #[automatically_derived]
    impl ::core::marker::Copy for Or {}
    #[automatically_derived]
    impl ::core::default::Default for Or {
        #[inline]
        fn default() -> Or {
            Or {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Or {
        #[inline]
        fn clone(&self) -> Or {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Or {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Or")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Or {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Or {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Or {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Or {
        #[inline]
        fn eq(&self, other: &Or) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Or {
        #[inline]
        fn cmp(&self, other: &Or) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Or {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Or,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Or {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Or {
        pub fn value(&self) -> &'static str {
            return "or";
        }
    }
    impl<'a> crate::Parse<'a> for Or {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Or(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Or {}
    ///Represents the terminal symbol `
    ///optional
    ///`
    pub struct Optional;
    #[automatically_derived]
    impl ::core::marker::Copy for Optional {}
    #[automatically_derived]
    impl ::core::default::Default for Optional {
        #[inline]
        fn default() -> Optional {
            Optional {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Optional {
        #[inline]
        fn clone(&self) -> Optional {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Optional {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Optional")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Optional {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Optional {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Optional {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Optional {
        #[inline]
        fn eq(&self, other: &Optional) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Optional {
        #[inline]
        fn cmp(&self, other: &Optional) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Optional {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Optional,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Optional {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Optional {
        pub fn value(&self) -> &'static str {
            return "optional";
        }
    }
    impl<'a> crate::Parse<'a> for Optional {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Optional(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Optional {}
    ///Represents the terminal symbol `
    ///async
    ///`
    pub struct Async;
    #[automatically_derived]
    impl ::core::marker::Copy for Async {}
    #[automatically_derived]
    impl ::core::default::Default for Async {
        #[inline]
        fn default() -> Async {
            Async {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Async {
        #[inline]
        fn clone(&self) -> Async {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Async {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Async")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Async {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Async {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Async {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Async {
        #[inline]
        fn eq(&self, other: &Async) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Async {
        #[inline]
        fn cmp(&self, other: &Async) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Async {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Async,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Async {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Async {
        pub fn value(&self) -> &'static str {
            return "async";
        }
    }
    impl<'a> crate::Parse<'a> for Async {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Async(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Async {}
    ///Represents the terminal symbol `
    ///attribute
    ///`
    pub struct Attribute;
    #[automatically_derived]
    impl ::core::marker::Copy for Attribute {}
    #[automatically_derived]
    impl ::core::default::Default for Attribute {
        #[inline]
        fn default() -> Attribute {
            Attribute {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Attribute {
        #[inline]
        fn clone(&self) -> Attribute {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Attribute {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Attribute")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Attribute {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Attribute {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Attribute {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Attribute {
        #[inline]
        fn eq(&self, other: &Attribute) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Attribute {
        #[inline]
        fn cmp(&self, other: &Attribute) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Attribute {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Attribute,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Attribute {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Attribute {
        pub fn value(&self) -> &'static str {
            return "attribute";
        }
    }
    impl<'a> crate::Parse<'a> for Attribute {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Attribute(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Attribute {}
    ///Represents the terminal symbol `
    ///callback
    ///`
    pub struct Callback;
    #[automatically_derived]
    impl ::core::marker::Copy for Callback {}
    #[automatically_derived]
    impl ::core::default::Default for Callback {
        #[inline]
        fn default() -> Callback {
            Callback {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Callback {
        #[inline]
        fn clone(&self) -> Callback {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Callback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Callback")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Callback {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Callback {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Callback {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Callback {
        #[inline]
        fn eq(&self, other: &Callback) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Callback {
        #[inline]
        fn cmp(&self, other: &Callback) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Callback {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Callback,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Callback {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Callback {
        pub fn value(&self) -> &'static str {
            return "callback";
        }
    }
    impl<'a> crate::Parse<'a> for Callback {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Callback(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Callback {}
    ///Represents the terminal symbol `
    ///const
    ///`
    pub struct Const;
    #[automatically_derived]
    impl ::core::marker::Copy for Const {}
    #[automatically_derived]
    impl ::core::default::Default for Const {
        #[inline]
        fn default() -> Const {
            Const {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Const {
        #[inline]
        fn clone(&self) -> Const {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Const {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Const")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Const {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Const {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Const {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Const {
        #[inline]
        fn eq(&self, other: &Const) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Const {
        #[inline]
        fn cmp(&self, other: &Const) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Const {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Const,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Const {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Const {
        pub fn value(&self) -> &'static str {
            return "const";
        }
    }
    impl<'a> crate::Parse<'a> for Const {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Const(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Const {}
    ///Represents the terminal symbol `
    ///deleter
    ///`
    pub struct Deleter;
    #[automatically_derived]
    impl ::core::marker::Copy for Deleter {}
    #[automatically_derived]
    impl ::core::default::Default for Deleter {
        #[inline]
        fn default() -> Deleter {
            Deleter {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Deleter {
        #[inline]
        fn clone(&self) -> Deleter {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Deleter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Deleter")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Deleter {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Deleter {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Deleter {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Deleter {
        #[inline]
        fn eq(&self, other: &Deleter) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Deleter {
        #[inline]
        fn cmp(&self, other: &Deleter) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Deleter {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Deleter,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Deleter {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Deleter {
        pub fn value(&self) -> &'static str {
            return "deleter";
        }
    }
    impl<'a> crate::Parse<'a> for Deleter {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Deleter(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Deleter {}
    ///Represents the terminal symbol `
    ///dictionary
    ///`
    pub struct Dictionary;
    #[automatically_derived]
    impl ::core::marker::Copy for Dictionary {}
    #[automatically_derived]
    impl ::core::default::Default for Dictionary {
        #[inline]
        fn default() -> Dictionary {
            Dictionary {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Dictionary {
        #[inline]
        fn clone(&self) -> Dictionary {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Dictionary {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Dictionary")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Dictionary {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Dictionary {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Dictionary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Dictionary {
        #[inline]
        fn eq(&self, other: &Dictionary) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Dictionary {
        #[inline]
        fn cmp(&self, other: &Dictionary) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Dictionary {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Dictionary,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Dictionary {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Dictionary {
        pub fn value(&self) -> &'static str {
            return "dictionary";
        }
    }
    impl<'a> crate::Parse<'a> for Dictionary {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Dictionary(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Dictionary {}
    ///Represents the terminal symbol `
    ///enum
    ///`
    pub struct Enum;
    #[automatically_derived]
    impl ::core::marker::Copy for Enum {}
    #[automatically_derived]
    impl ::core::default::Default for Enum {
        #[inline]
        fn default() -> Enum {
            Enum {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Enum {
        #[inline]
        fn clone(&self) -> Enum {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Enum {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Enum")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Enum {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Enum {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Enum {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Enum {
        #[inline]
        fn eq(&self, other: &Enum) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Enum {
        #[inline]
        fn cmp(&self, other: &Enum) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Enum {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Enum,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Enum {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Enum {
        pub fn value(&self) -> &'static str {
            return "enum";
        }
    }
    impl<'a> crate::Parse<'a> for Enum {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Enum(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Enum {}
    ///Represents the terminal symbol `
    ///getter
    ///`
    pub struct Getter;
    #[automatically_derived]
    impl ::core::marker::Copy for Getter {}
    #[automatically_derived]
    impl ::core::default::Default for Getter {
        #[inline]
        fn default() -> Getter {
            Getter {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Getter {
        #[inline]
        fn clone(&self) -> Getter {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Getter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Getter")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Getter {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Getter {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Getter {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Getter {
        #[inline]
        fn eq(&self, other: &Getter) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Getter {
        #[inline]
        fn cmp(&self, other: &Getter) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Getter {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Getter,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Getter {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Getter {
        pub fn value(&self) -> &'static str {
            return "getter";
        }
    }
    impl<'a> crate::Parse<'a> for Getter {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Getter(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Getter {}
    ///Represents the terminal symbol `
    ///includes
    ///`
    pub struct Includes;
    #[automatically_derived]
    impl ::core::marker::Copy for Includes {}
    #[automatically_derived]
    impl ::core::default::Default for Includes {
        #[inline]
        fn default() -> Includes {
            Includes {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Includes {
        #[inline]
        fn clone(&self) -> Includes {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Includes {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Includes")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Includes {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Includes {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Includes {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Includes {
        #[inline]
        fn eq(&self, other: &Includes) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Includes {
        #[inline]
        fn cmp(&self, other: &Includes) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Includes {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Includes,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Includes {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Includes {
        pub fn value(&self) -> &'static str {
            return "includes";
        }
    }
    impl<'a> crate::Parse<'a> for Includes {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Includes(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Includes {}
    ///Represents the terminal symbol `
    ///inherit
    ///`
    pub struct Inherit;
    #[automatically_derived]
    impl ::core::marker::Copy for Inherit {}
    #[automatically_derived]
    impl ::core::default::Default for Inherit {
        #[inline]
        fn default() -> Inherit {
            Inherit {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Inherit {
        #[inline]
        fn clone(&self) -> Inherit {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Inherit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Inherit")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Inherit {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Inherit {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Inherit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Inherit {
        #[inline]
        fn eq(&self, other: &Inherit) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Inherit {
        #[inline]
        fn cmp(&self, other: &Inherit) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Inherit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Inherit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Inherit {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Inherit {
        pub fn value(&self) -> &'static str {
            return "inherit";
        }
    }
    impl<'a> crate::Parse<'a> for Inherit {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Inherit(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Inherit {}
    ///Represents the terminal symbol `
    ///interface
    ///`
    pub struct Interface;
    #[automatically_derived]
    impl ::core::marker::Copy for Interface {}
    #[automatically_derived]
    impl ::core::default::Default for Interface {
        #[inline]
        fn default() -> Interface {
            Interface {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Interface {
        #[inline]
        fn clone(&self) -> Interface {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Interface {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Interface")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Interface {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Interface {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Interface {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Interface {
        #[inline]
        fn eq(&self, other: &Interface) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Interface {
        #[inline]
        fn cmp(&self, other: &Interface) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Interface {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Interface,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Interface {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Interface {
        pub fn value(&self) -> &'static str {
            return "interface";
        }
    }
    impl<'a> crate::Parse<'a> for Interface {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Interface(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Interface {}
    ///Represents the terminal symbol `
    ///iterable
    ///`
    pub struct Iterable;
    #[automatically_derived]
    impl ::core::marker::Copy for Iterable {}
    #[automatically_derived]
    impl ::core::default::Default for Iterable {
        #[inline]
        fn default() -> Iterable {
            Iterable {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Iterable {
        #[inline]
        fn clone(&self) -> Iterable {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Iterable {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Iterable")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Iterable {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Iterable {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Iterable {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Iterable {
        #[inline]
        fn eq(&self, other: &Iterable) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Iterable {
        #[inline]
        fn cmp(&self, other: &Iterable) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Iterable {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Iterable,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Iterable {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Iterable {
        pub fn value(&self) -> &'static str {
            return "iterable";
        }
    }
    impl<'a> crate::Parse<'a> for Iterable {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Iterable(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Iterable {}
    ///Represents the terminal symbol `
    ///maplike
    ///`
    pub struct Maplike;
    #[automatically_derived]
    impl ::core::marker::Copy for Maplike {}
    #[automatically_derived]
    impl ::core::default::Default for Maplike {
        #[inline]
        fn default() -> Maplike {
            Maplike {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Maplike {
        #[inline]
        fn clone(&self) -> Maplike {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Maplike {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Maplike")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Maplike {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Maplike {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Maplike {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Maplike {
        #[inline]
        fn eq(&self, other: &Maplike) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Maplike {
        #[inline]
        fn cmp(&self, other: &Maplike) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Maplike {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Maplike,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Maplike {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Maplike {
        pub fn value(&self) -> &'static str {
            return "maplike";
        }
    }
    impl<'a> crate::Parse<'a> for Maplike {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Maplike(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Maplike {}
    ///Represents the terminal symbol `
    ///namespace
    ///`
    pub struct Namespace;
    #[automatically_derived]
    impl ::core::marker::Copy for Namespace {}
    #[automatically_derived]
    impl ::core::default::Default for Namespace {
        #[inline]
        fn default() -> Namespace {
            Namespace {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Namespace {
        #[inline]
        fn clone(&self) -> Namespace {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Namespace {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Namespace")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Namespace {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Namespace {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Namespace {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Namespace {
        #[inline]
        fn eq(&self, other: &Namespace) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Namespace {
        #[inline]
        fn cmp(&self, other: &Namespace) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Namespace {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Namespace,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Namespace {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Namespace {
        pub fn value(&self) -> &'static str {
            return "namespace";
        }
    }
    impl<'a> crate::Parse<'a> for Namespace {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Namespace(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Namespace {}
    ///Represents the terminal symbol `
    ///partial
    ///`
    pub struct Partial;
    #[automatically_derived]
    impl ::core::marker::Copy for Partial {}
    #[automatically_derived]
    impl ::core::default::Default for Partial {
        #[inline]
        fn default() -> Partial {
            Partial {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Partial {
        #[inline]
        fn clone(&self) -> Partial {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Partial {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Partial")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Partial {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Partial {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Partial {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Partial {
        #[inline]
        fn eq(&self, other: &Partial) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Partial {
        #[inline]
        fn cmp(&self, other: &Partial) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Partial {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Partial,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Partial {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Partial {
        pub fn value(&self) -> &'static str {
            return "partial";
        }
    }
    impl<'a> crate::Parse<'a> for Partial {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Partial(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Partial {}
    ///Represents the terminal symbol `
    ///required
    ///`
    pub struct Required;
    #[automatically_derived]
    impl ::core::marker::Copy for Required {}
    #[automatically_derived]
    impl ::core::default::Default for Required {
        #[inline]
        fn default() -> Required {
            Required {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Required {
        #[inline]
        fn clone(&self) -> Required {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Required {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Required")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Required {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Required {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Required {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Required {
        #[inline]
        fn eq(&self, other: &Required) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Required {
        #[inline]
        fn cmp(&self, other: &Required) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Required {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Required,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Required {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Required {
        pub fn value(&self) -> &'static str {
            return "required";
        }
    }
    impl<'a> crate::Parse<'a> for Required {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Required(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Required {}
    ///Represents the terminal symbol `
    ///setlike
    ///`
    pub struct Setlike;
    #[automatically_derived]
    impl ::core::marker::Copy for Setlike {}
    #[automatically_derived]
    impl ::core::default::Default for Setlike {
        #[inline]
        fn default() -> Setlike {
            Setlike {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Setlike {
        #[inline]
        fn clone(&self) -> Setlike {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Setlike {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Setlike")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Setlike {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Setlike {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Setlike {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Setlike {
        #[inline]
        fn eq(&self, other: &Setlike) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Setlike {
        #[inline]
        fn cmp(&self, other: &Setlike) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Setlike {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Setlike,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Setlike {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Setlike {
        pub fn value(&self) -> &'static str {
            return "setlike";
        }
    }
    impl<'a> crate::Parse<'a> for Setlike {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Setlike(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Setlike {}
    ///Represents the terminal symbol `
    ///setter
    ///`
    pub struct Setter;
    #[automatically_derived]
    impl ::core::marker::Copy for Setter {}
    #[automatically_derived]
    impl ::core::default::Default for Setter {
        #[inline]
        fn default() -> Setter {
            Setter {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Setter {
        #[inline]
        fn clone(&self) -> Setter {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Setter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Setter")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Setter {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Setter {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Setter {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Setter {
        #[inline]
        fn eq(&self, other: &Setter) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Setter {
        #[inline]
        fn cmp(&self, other: &Setter) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Setter {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Setter,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Setter {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Setter {
        pub fn value(&self) -> &'static str {
            return "setter";
        }
    }
    impl<'a> crate::Parse<'a> for Setter {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Setter(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Setter {}
    ///Represents the terminal symbol `
    ///static
    ///`
    pub struct Static;
    #[automatically_derived]
    impl ::core::marker::Copy for Static {}
    #[automatically_derived]
    impl ::core::default::Default for Static {
        #[inline]
        fn default() -> Static {
            Static {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Static {
        #[inline]
        fn clone(&self) -> Static {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Static {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Static")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Static {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Static {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Static {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Static {
        #[inline]
        fn eq(&self, other: &Static) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Static {
        #[inline]
        fn cmp(&self, other: &Static) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Static {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Static,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Static {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Static {
        pub fn value(&self) -> &'static str {
            return "static";
        }
    }
    impl<'a> crate::Parse<'a> for Static {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Static(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Static {}
    ///Represents the terminal symbol `
    ///stringifier
    ///`
    pub struct Stringifier;
    #[automatically_derived]
    impl ::core::marker::Copy for Stringifier {}
    #[automatically_derived]
    impl ::core::default::Default for Stringifier {
        #[inline]
        fn default() -> Stringifier {
            Stringifier {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Stringifier {
        #[inline]
        fn clone(&self) -> Stringifier {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Stringifier {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Stringifier")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Stringifier {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Stringifier {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Stringifier {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Stringifier {
        #[inline]
        fn eq(&self, other: &Stringifier) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Stringifier {
        #[inline]
        fn cmp(&self, other: &Stringifier) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Stringifier {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Stringifier,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Stringifier {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Stringifier {
        pub fn value(&self) -> &'static str {
            return "stringifier";
        }
    }
    impl<'a> crate::Parse<'a> for Stringifier {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Stringifier(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Stringifier {}
    ///Represents the terminal symbol `
    ///typedef
    ///`
    pub struct Typedef;
    #[automatically_derived]
    impl ::core::marker::Copy for Typedef {}
    #[automatically_derived]
    impl ::core::default::Default for Typedef {
        #[inline]
        fn default() -> Typedef {
            Typedef {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Typedef {
        #[inline]
        fn clone(&self) -> Typedef {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Typedef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Typedef")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Typedef {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Typedef {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Typedef {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Typedef {
        #[inline]
        fn eq(&self, other: &Typedef) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Typedef {
        #[inline]
        fn cmp(&self, other: &Typedef) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Typedef {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Typedef,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Typedef {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Typedef {
        pub fn value(&self) -> &'static str {
            return "typedef";
        }
    }
    impl<'a> crate::Parse<'a> for Typedef {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Typedef(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Typedef {}
    ///Represents the terminal symbol `
    ///unrestricted
    ///`
    pub struct Unrestricted;
    #[automatically_derived]
    impl ::core::marker::Copy for Unrestricted {}
    #[automatically_derived]
    impl ::core::default::Default for Unrestricted {
        #[inline]
        fn default() -> Unrestricted {
            Unrestricted {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Unrestricted {
        #[inline]
        fn clone(&self) -> Unrestricted {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Unrestricted {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Unrestricted")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Unrestricted {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Unrestricted {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Unrestricted {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Unrestricted {
        #[inline]
        fn eq(&self, other: &Unrestricted) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Unrestricted {
        #[inline]
        fn cmp(&self, other: &Unrestricted) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Unrestricted {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Unrestricted,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Unrestricted {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Unrestricted {
        pub fn value(&self) -> &'static str {
            return "unrestricted";
        }
    }
    impl<'a> crate::Parse<'a> for Unrestricted {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Unrestricted(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Unrestricted {}
    ///Represents the terminal symbol `
    ///symbol
    ///`
    pub struct Symbol;
    #[automatically_derived]
    impl ::core::marker::Copy for Symbol {}
    #[automatically_derived]
    impl ::core::default::Default for Symbol {
        #[inline]
        fn default() -> Symbol {
            Symbol {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Symbol {
        #[inline]
        fn clone(&self) -> Symbol {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Symbol {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Symbol")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Symbol {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Symbol {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Symbol {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Symbol {
        #[inline]
        fn eq(&self, other: &Symbol) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Symbol {
        #[inline]
        fn cmp(&self, other: &Symbol) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Symbol {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Symbol,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Symbol {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Symbol {
        pub fn value(&self) -> &'static str {
            return "symbol";
        }
    }
    impl<'a> crate::Parse<'a> for Symbol {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Symbol(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Symbol {}
    ///Represents the terminal symbol `
    ///-Infinity
    ///`
    pub struct NegInfinity;
    #[automatically_derived]
    impl ::core::marker::Copy for NegInfinity {}
    #[automatically_derived]
    impl ::core::default::Default for NegInfinity {
        #[inline]
        fn default() -> NegInfinity {
            NegInfinity {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NegInfinity {
        #[inline]
        fn clone(&self) -> NegInfinity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NegInfinity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "NegInfinity")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for NegInfinity {}
    #[automatically_derived]
    impl ::core::cmp::Eq for NegInfinity {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NegInfinity {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NegInfinity {
        #[inline]
        fn eq(&self, other: &NegInfinity) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for NegInfinity {
        #[inline]
        fn cmp(&self, other: &NegInfinity) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for NegInfinity {
        #[inline]
        fn partial_cmp(
            &self,
            other: &NegInfinity,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for NegInfinity {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl NegInfinity {
        pub fn value(&self) -> &'static str {
            return "-Infinity";
        }
    }
    impl<'a> crate::Parse<'a> for NegInfinity {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::NegInfinity(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for NegInfinity {}
    ///Represents the terminal symbol `
    ///ByteString
    ///`
    pub struct ByteString;
    #[automatically_derived]
    impl ::core::marker::Copy for ByteString {}
    #[automatically_derived]
    impl ::core::default::Default for ByteString {
        #[inline]
        fn default() -> ByteString {
            ByteString {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ByteString {
        #[inline]
        fn clone(&self) -> ByteString {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ByteString {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ByteString")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ByteString {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ByteString {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ByteString {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ByteString {
        #[inline]
        fn eq(&self, other: &ByteString) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ByteString {
        #[inline]
        fn cmp(&self, other: &ByteString) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ByteString {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ByteString,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ByteString {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl ByteString {
        pub fn value(&self) -> &'static str {
            return "ByteString";
        }
    }
    impl<'a> crate::Parse<'a> for ByteString {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::ByteString(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for ByteString {}
    ///Represents the terminal symbol `
    ///DOMString
    ///`
    pub struct DOMString;
    #[automatically_derived]
    impl ::core::marker::Copy for DOMString {}
    #[automatically_derived]
    impl ::core::default::Default for DOMString {
        #[inline]
        fn default() -> DOMString {
            DOMString {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DOMString {
        #[inline]
        fn clone(&self) -> DOMString {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DOMString {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "DOMString")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DOMString {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DOMString {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DOMString {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DOMString {
        #[inline]
        fn eq(&self, other: &DOMString) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DOMString {
        #[inline]
        fn cmp(&self, other: &DOMString) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DOMString {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DOMString,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DOMString {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl DOMString {
        pub fn value(&self) -> &'static str {
            return "DOMString";
        }
    }
    impl<'a> crate::Parse<'a> for DOMString {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::DOMString(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for DOMString {}
    ///Represents the terminal symbol `
    ///FrozenArray
    ///`
    pub struct FrozenArray;
    #[automatically_derived]
    impl ::core::marker::Copy for FrozenArray {}
    #[automatically_derived]
    impl ::core::default::Default for FrozenArray {
        #[inline]
        fn default() -> FrozenArray {
            FrozenArray {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FrozenArray {
        #[inline]
        fn clone(&self) -> FrozenArray {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FrozenArray {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "FrozenArray")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FrozenArray {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FrozenArray {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FrozenArray {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FrozenArray {
        #[inline]
        fn eq(&self, other: &FrozenArray) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FrozenArray {
        #[inline]
        fn cmp(&self, other: &FrozenArray) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FrozenArray {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FrozenArray,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FrozenArray {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl FrozenArray {
        pub fn value(&self) -> &'static str {
            return "FrozenArray";
        }
    }
    impl<'a> crate::Parse<'a> for FrozenArray {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::FrozenArray(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for FrozenArray {}
    ///Represents the terminal symbol `
    ///Infinity
    ///`
    pub struct Infinity;
    #[automatically_derived]
    impl ::core::marker::Copy for Infinity {}
    #[automatically_derived]
    impl ::core::default::Default for Infinity {
        #[inline]
        fn default() -> Infinity {
            Infinity {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Infinity {
        #[inline]
        fn clone(&self) -> Infinity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Infinity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Infinity")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Infinity {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Infinity {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Infinity {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Infinity {
        #[inline]
        fn eq(&self, other: &Infinity) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Infinity {
        #[inline]
        fn cmp(&self, other: &Infinity) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Infinity {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Infinity,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Infinity {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Infinity {
        pub fn value(&self) -> &'static str {
            return "Infinity";
        }
    }
    impl<'a> crate::Parse<'a> for Infinity {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Infinity(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Infinity {}
    ///Represents the terminal symbol `
    ///NaN
    ///`
    pub struct NaN;
    #[automatically_derived]
    impl ::core::marker::Copy for NaN {}
    #[automatically_derived]
    impl ::core::default::Default for NaN {
        #[inline]
        fn default() -> NaN {
            NaN {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NaN {
        #[inline]
        fn clone(&self) -> NaN {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NaN {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "NaN")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for NaN {}
    #[automatically_derived]
    impl ::core::cmp::Eq for NaN {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NaN {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NaN {
        #[inline]
        fn eq(&self, other: &NaN) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for NaN {
        #[inline]
        fn cmp(&self, other: &NaN) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for NaN {
        #[inline]
        fn partial_cmp(
            &self,
            other: &NaN,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for NaN {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl NaN {
        pub fn value(&self) -> &'static str {
            return "NaN";
        }
    }
    impl<'a> crate::Parse<'a> for NaN {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::NaN(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for NaN {}
    ///Represents the terminal symbol `
    ///ObservableArray
    ///`
    pub struct ObservableArray;
    #[automatically_derived]
    impl ::core::marker::Copy for ObservableArray {}
    #[automatically_derived]
    impl ::core::default::Default for ObservableArray {
        #[inline]
        fn default() -> ObservableArray {
            ObservableArray {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ObservableArray {
        #[inline]
        fn clone(&self) -> ObservableArray {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ObservableArray {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ObservableArray")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ObservableArray {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ObservableArray {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ObservableArray {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ObservableArray {
        #[inline]
        fn eq(&self, other: &ObservableArray) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ObservableArray {
        #[inline]
        fn cmp(&self, other: &ObservableArray) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ObservableArray {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ObservableArray,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ObservableArray {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl ObservableArray {
        pub fn value(&self) -> &'static str {
            return "ObservableArray";
        }
    }
    impl<'a> crate::Parse<'a> for ObservableArray {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::ObservableArray(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for ObservableArray {}
    ///Represents the terminal symbol `
    ///USVString
    ///`
    pub struct USVString;
    #[automatically_derived]
    impl ::core::marker::Copy for USVString {}
    #[automatically_derived]
    impl ::core::default::Default for USVString {
        #[inline]
        fn default() -> USVString {
            USVString {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for USVString {
        #[inline]
        fn clone(&self) -> USVString {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for USVString {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "USVString")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for USVString {}
    #[automatically_derived]
    impl ::core::cmp::Eq for USVString {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for USVString {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for USVString {
        #[inline]
        fn eq(&self, other: &USVString) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for USVString {
        #[inline]
        fn cmp(&self, other: &USVString) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for USVString {
        #[inline]
        fn partial_cmp(
            &self,
            other: &USVString,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for USVString {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl USVString {
        pub fn value(&self) -> &'static str {
            return "USVString";
        }
    }
    impl<'a> crate::Parse<'a> for USVString {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::USVString(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for USVString {}
    ///Represents the terminal symbol `
    ///any
    ///`
    pub struct Any;
    #[automatically_derived]
    impl ::core::marker::Copy for Any {}
    #[automatically_derived]
    impl ::core::default::Default for Any {
        #[inline]
        fn default() -> Any {
            Any {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Any {
        #[inline]
        fn clone(&self) -> Any {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Any {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Any")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Any {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Any {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Any {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Any {
        #[inline]
        fn eq(&self, other: &Any) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Any {
        #[inline]
        fn cmp(&self, other: &Any) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Any {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Any,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Any {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Any {
        pub fn value(&self) -> &'static str {
            return "any";
        }
    }
    impl<'a> crate::Parse<'a> for Any {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Any(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Any {}
    ///Represents the terminal symbol `
    ///bigint
    ///`
    pub struct Bigint;
    #[automatically_derived]
    impl ::core::marker::Copy for Bigint {}
    #[automatically_derived]
    impl ::core::default::Default for Bigint {
        #[inline]
        fn default() -> Bigint {
            Bigint {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bigint {
        #[inline]
        fn clone(&self) -> Bigint {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Bigint {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bigint")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Bigint {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Bigint {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bigint {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bigint {
        #[inline]
        fn eq(&self, other: &Bigint) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bigint {
        #[inline]
        fn cmp(&self, other: &Bigint) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bigint {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bigint,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bigint {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Bigint {
        pub fn value(&self) -> &'static str {
            return "bigint";
        }
    }
    impl<'a> crate::Parse<'a> for Bigint {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Bigint(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Bigint {}
    ///Represents the terminal symbol `
    ///boolean
    ///`
    pub struct Boolean;
    #[automatically_derived]
    impl ::core::marker::Copy for Boolean {}
    #[automatically_derived]
    impl ::core::default::Default for Boolean {
        #[inline]
        fn default() -> Boolean {
            Boolean {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Boolean {
        #[inline]
        fn clone(&self) -> Boolean {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Boolean {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Boolean")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Boolean {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Boolean {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Boolean {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Boolean {
        #[inline]
        fn eq(&self, other: &Boolean) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Boolean {
        #[inline]
        fn cmp(&self, other: &Boolean) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Boolean {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Boolean,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Boolean {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Boolean {
        pub fn value(&self) -> &'static str {
            return "boolean";
        }
    }
    impl<'a> crate::Parse<'a> for Boolean {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Boolean(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Boolean {}
    ///Represents the terminal symbol `
    ///byte
    ///`
    pub struct Byte;
    #[automatically_derived]
    impl ::core::marker::Copy for Byte {}
    #[automatically_derived]
    impl ::core::default::Default for Byte {
        #[inline]
        fn default() -> Byte {
            Byte {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Byte {
        #[inline]
        fn clone(&self) -> Byte {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Byte {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Byte")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Byte {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Byte {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Byte {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Byte {
        #[inline]
        fn eq(&self, other: &Byte) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Byte {
        #[inline]
        fn cmp(&self, other: &Byte) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Byte {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Byte,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Byte {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Byte {
        pub fn value(&self) -> &'static str {
            return "byte";
        }
    }
    impl<'a> crate::Parse<'a> for Byte {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Byte(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Byte {}
    ///Represents the terminal symbol `
    ///double
    ///`
    pub struct Double;
    #[automatically_derived]
    impl ::core::marker::Copy for Double {}
    #[automatically_derived]
    impl ::core::default::Default for Double {
        #[inline]
        fn default() -> Double {
            Double {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Double {
        #[inline]
        fn clone(&self) -> Double {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Double {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Double")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Double {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Double {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Double {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Double {
        #[inline]
        fn eq(&self, other: &Double) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Double {
        #[inline]
        fn cmp(&self, other: &Double) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Double {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Double,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Double {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Double {
        pub fn value(&self) -> &'static str {
            return "double";
        }
    }
    impl<'a> crate::Parse<'a> for Double {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Double(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Double {}
    ///Represents the terminal symbol `
    ///false
    ///`
    pub struct False;
    #[automatically_derived]
    impl ::core::marker::Copy for False {}
    #[automatically_derived]
    impl ::core::default::Default for False {
        #[inline]
        fn default() -> False {
            False {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for False {
        #[inline]
        fn clone(&self) -> False {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for False {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "False")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for False {}
    #[automatically_derived]
    impl ::core::cmp::Eq for False {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for False {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for False {
        #[inline]
        fn eq(&self, other: &False) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for False {
        #[inline]
        fn cmp(&self, other: &False) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for False {
        #[inline]
        fn partial_cmp(
            &self,
            other: &False,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for False {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl False {
        pub fn value(&self) -> &'static str {
            return "false";
        }
    }
    impl<'a> crate::Parse<'a> for False {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::False(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for False {}
    ///Represents the terminal symbol `
    ///float
    ///`
    pub struct Float;
    #[automatically_derived]
    impl ::core::marker::Copy for Float {}
    #[automatically_derived]
    impl ::core::default::Default for Float {
        #[inline]
        fn default() -> Float {
            Float {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Float {
        #[inline]
        fn clone(&self) -> Float {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Float {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Float")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Float {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Float {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Float {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Float {
        #[inline]
        fn eq(&self, other: &Float) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Float {
        #[inline]
        fn cmp(&self, other: &Float) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Float {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Float,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Float {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Float {
        pub fn value(&self) -> &'static str {
            return "float";
        }
    }
    impl<'a> crate::Parse<'a> for Float {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Float(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Float {}
    ///Represents the terminal symbol `
    ///long
    ///`
    pub struct Long;
    #[automatically_derived]
    impl ::core::marker::Copy for Long {}
    #[automatically_derived]
    impl ::core::default::Default for Long {
        #[inline]
        fn default() -> Long {
            Long {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Long {
        #[inline]
        fn clone(&self) -> Long {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Long {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Long")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Long {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Long {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Long {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Long {
        #[inline]
        fn eq(&self, other: &Long) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Long {
        #[inline]
        fn cmp(&self, other: &Long) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Long {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Long,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Long {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Long {
        pub fn value(&self) -> &'static str {
            return "long";
        }
    }
    impl<'a> crate::Parse<'a> for Long {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Long(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Long {}
    ///Represents the terminal symbol `
    ///null
    ///`
    pub struct Null;
    #[automatically_derived]
    impl ::core::marker::Copy for Null {}
    #[automatically_derived]
    impl ::core::default::Default for Null {
        #[inline]
        fn default() -> Null {
            Null {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Null {
        #[inline]
        fn clone(&self) -> Null {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Null {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Null")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Null {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Null {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Null {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Null {
        #[inline]
        fn eq(&self, other: &Null) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Null {
        #[inline]
        fn cmp(&self, other: &Null) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Null {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Null,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Null {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Null {
        pub fn value(&self) -> &'static str {
            return "null";
        }
    }
    impl<'a> crate::Parse<'a> for Null {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Null(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Null {}
    ///Represents the terminal symbol `
    ///object
    ///`
    pub struct Object;
    #[automatically_derived]
    impl ::core::marker::Copy for Object {}
    #[automatically_derived]
    impl ::core::default::Default for Object {
        #[inline]
        fn default() -> Object {
            Object {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Object {
        #[inline]
        fn clone(&self) -> Object {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Object {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Object")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Object {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Object {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Object {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Object {
        #[inline]
        fn eq(&self, other: &Object) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Object {
        #[inline]
        fn cmp(&self, other: &Object) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Object {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Object,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Object {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Object {
        pub fn value(&self) -> &'static str {
            return "object";
        }
    }
    impl<'a> crate::Parse<'a> for Object {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Object(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Object {}
    ///Represents the terminal symbol `
    ///octet
    ///`
    pub struct Octet;
    #[automatically_derived]
    impl ::core::marker::Copy for Octet {}
    #[automatically_derived]
    impl ::core::default::Default for Octet {
        #[inline]
        fn default() -> Octet {
            Octet {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Octet {
        #[inline]
        fn clone(&self) -> Octet {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Octet {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Octet")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Octet {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Octet {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Octet {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Octet {
        #[inline]
        fn eq(&self, other: &Octet) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Octet {
        #[inline]
        fn cmp(&self, other: &Octet) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Octet {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Octet,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Octet {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Octet {
        pub fn value(&self) -> &'static str {
            return "octet";
        }
    }
    impl<'a> crate::Parse<'a> for Octet {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Octet(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Octet {}
    ///Represents the terminal symbol `
    ///sequence
    ///`
    pub struct Sequence;
    #[automatically_derived]
    impl ::core::marker::Copy for Sequence {}
    #[automatically_derived]
    impl ::core::default::Default for Sequence {
        #[inline]
        fn default() -> Sequence {
            Sequence {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sequence {
        #[inline]
        fn clone(&self) -> Sequence {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sequence {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Sequence")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Sequence {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Sequence {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sequence {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sequence {
        #[inline]
        fn eq(&self, other: &Sequence) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Sequence {
        #[inline]
        fn cmp(&self, other: &Sequence) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Sequence {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Sequence,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Sequence {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Sequence {
        pub fn value(&self) -> &'static str {
            return "sequence";
        }
    }
    impl<'a> crate::Parse<'a> for Sequence {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Sequence(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Sequence {}
    ///Represents the terminal symbol `
    ///short
    ///`
    pub struct Short;
    #[automatically_derived]
    impl ::core::marker::Copy for Short {}
    #[automatically_derived]
    impl ::core::default::Default for Short {
        #[inline]
        fn default() -> Short {
            Short {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Short {
        #[inline]
        fn clone(&self) -> Short {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Short {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Short")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Short {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Short {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Short {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Short {
        #[inline]
        fn eq(&self, other: &Short) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Short {
        #[inline]
        fn cmp(&self, other: &Short) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Short {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Short,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Short {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Short {
        pub fn value(&self) -> &'static str {
            return "short";
        }
    }
    impl<'a> crate::Parse<'a> for Short {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Short(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Short {}
    ///Represents the terminal symbol `
    ///true
    ///`
    pub struct True;
    #[automatically_derived]
    impl ::core::marker::Copy for True {}
    #[automatically_derived]
    impl ::core::default::Default for True {
        #[inline]
        fn default() -> True {
            True {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for True {
        #[inline]
        fn clone(&self) -> True {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for True {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "True")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for True {}
    #[automatically_derived]
    impl ::core::cmp::Eq for True {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for True {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for True {
        #[inline]
        fn eq(&self, other: &True) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for True {
        #[inline]
        fn cmp(&self, other: &True) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for True {
        #[inline]
        fn partial_cmp(
            &self,
            other: &True,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for True {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl True {
        pub fn value(&self) -> &'static str {
            return "true";
        }
    }
    impl<'a> crate::Parse<'a> for True {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::True(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for True {}
    ///Represents the terminal symbol `
    ///unsigned
    ///`
    pub struct Unsigned;
    #[automatically_derived]
    impl ::core::marker::Copy for Unsigned {}
    #[automatically_derived]
    impl ::core::default::Default for Unsigned {
        #[inline]
        fn default() -> Unsigned {
            Unsigned {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Unsigned {
        #[inline]
        fn clone(&self) -> Unsigned {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Unsigned {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Unsigned")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Unsigned {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Unsigned {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Unsigned {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Unsigned {
        #[inline]
        fn eq(&self, other: &Unsigned) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Unsigned {
        #[inline]
        fn cmp(&self, other: &Unsigned) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Unsigned {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Unsigned,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Unsigned {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Unsigned {
        pub fn value(&self) -> &'static str {
            return "unsigned";
        }
    }
    impl<'a> crate::Parse<'a> for Unsigned {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Unsigned(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Unsigned {}
    ///Represents the terminal symbol `
    ///undefined
    ///`
    pub struct Undefined;
    #[automatically_derived]
    impl ::core::marker::Copy for Undefined {}
    #[automatically_derived]
    impl ::core::default::Default for Undefined {
        #[inline]
        fn default() -> Undefined {
            Undefined {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Undefined {
        #[inline]
        fn clone(&self) -> Undefined {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Undefined {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Undefined")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Undefined {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Undefined {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Undefined {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Undefined {
        #[inline]
        fn eq(&self, other: &Undefined) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Undefined {
        #[inline]
        fn cmp(&self, other: &Undefined) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Undefined {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Undefined,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Undefined {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Undefined {
        pub fn value(&self) -> &'static str {
            return "undefined";
        }
    }
    impl<'a> crate::Parse<'a> for Undefined {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Undefined(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Undefined {}
    ///Represents the terminal symbol `
    ///record
    ///`
    pub struct Record;
    #[automatically_derived]
    impl ::core::marker::Copy for Record {}
    #[automatically_derived]
    impl ::core::default::Default for Record {
        #[inline]
        fn default() -> Record {
            Record {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Record {
        #[inline]
        fn clone(&self) -> Record {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Record {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Record")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Record {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Record {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Record {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Record {
        #[inline]
        fn eq(&self, other: &Record) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Record {
        #[inline]
        fn cmp(&self, other: &Record) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Record {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Record,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Record {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Record {
        pub fn value(&self) -> &'static str {
            return "record";
        }
    }
    impl<'a> crate::Parse<'a> for Record {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Record(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Record {}
    ///Represents the terminal symbol `
    ///ArrayBuffer
    ///`
    pub struct ArrayBuffer;
    #[automatically_derived]
    impl ::core::marker::Copy for ArrayBuffer {}
    #[automatically_derived]
    impl ::core::default::Default for ArrayBuffer {
        #[inline]
        fn default() -> ArrayBuffer {
            ArrayBuffer {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ArrayBuffer {
        #[inline]
        fn clone(&self) -> ArrayBuffer {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ArrayBuffer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ArrayBuffer")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ArrayBuffer {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ArrayBuffer {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ArrayBuffer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ArrayBuffer {
        #[inline]
        fn eq(&self, other: &ArrayBuffer) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ArrayBuffer {
        #[inline]
        fn cmp(&self, other: &ArrayBuffer) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ArrayBuffer {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ArrayBuffer,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ArrayBuffer {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl ArrayBuffer {
        pub fn value(&self) -> &'static str {
            return "ArrayBuffer";
        }
    }
    impl<'a> crate::Parse<'a> for ArrayBuffer {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::ArrayBuffer(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for ArrayBuffer {}
    ///Represents the terminal symbol `
    ///DataView
    ///`
    pub struct DataView;
    #[automatically_derived]
    impl ::core::marker::Copy for DataView {}
    #[automatically_derived]
    impl ::core::default::Default for DataView {
        #[inline]
        fn default() -> DataView {
            DataView {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DataView {
        #[inline]
        fn clone(&self) -> DataView {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DataView {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "DataView")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DataView {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DataView {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DataView {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DataView {
        #[inline]
        fn eq(&self, other: &DataView) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DataView {
        #[inline]
        fn cmp(&self, other: &DataView) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DataView {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DataView,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DataView {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl DataView {
        pub fn value(&self) -> &'static str {
            return "DataView";
        }
    }
    impl<'a> crate::Parse<'a> for DataView {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::DataView(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for DataView {}
    ///Represents the terminal symbol `
    ///Int8Array
    ///`
    pub struct Int8Array;
    #[automatically_derived]
    impl ::core::marker::Copy for Int8Array {}
    #[automatically_derived]
    impl ::core::default::Default for Int8Array {
        #[inline]
        fn default() -> Int8Array {
            Int8Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Int8Array {
        #[inline]
        fn clone(&self) -> Int8Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Int8Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Int8Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Int8Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Int8Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Int8Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Int8Array {
        #[inline]
        fn eq(&self, other: &Int8Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Int8Array {
        #[inline]
        fn cmp(&self, other: &Int8Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Int8Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Int8Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Int8Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Int8Array {
        pub fn value(&self) -> &'static str {
            return "Int8Array";
        }
    }
    impl<'a> crate::Parse<'a> for Int8Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Int8Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Int8Array {}
    ///Represents the terminal symbol `
    ///Int16Array
    ///`
    pub struct Int16Array;
    #[automatically_derived]
    impl ::core::marker::Copy for Int16Array {}
    #[automatically_derived]
    impl ::core::default::Default for Int16Array {
        #[inline]
        fn default() -> Int16Array {
            Int16Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Int16Array {
        #[inline]
        fn clone(&self) -> Int16Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Int16Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Int16Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Int16Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Int16Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Int16Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Int16Array {
        #[inline]
        fn eq(&self, other: &Int16Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Int16Array {
        #[inline]
        fn cmp(&self, other: &Int16Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Int16Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Int16Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Int16Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Int16Array {
        pub fn value(&self) -> &'static str {
            return "Int16Array";
        }
    }
    impl<'a> crate::Parse<'a> for Int16Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Int16Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Int16Array {}
    ///Represents the terminal symbol `
    ///Int32Array
    ///`
    pub struct Int32Array;
    #[automatically_derived]
    impl ::core::marker::Copy for Int32Array {}
    #[automatically_derived]
    impl ::core::default::Default for Int32Array {
        #[inline]
        fn default() -> Int32Array {
            Int32Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Int32Array {
        #[inline]
        fn clone(&self) -> Int32Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Int32Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Int32Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Int32Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Int32Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Int32Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Int32Array {
        #[inline]
        fn eq(&self, other: &Int32Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Int32Array {
        #[inline]
        fn cmp(&self, other: &Int32Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Int32Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Int32Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Int32Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Int32Array {
        pub fn value(&self) -> &'static str {
            return "Int32Array";
        }
    }
    impl<'a> crate::Parse<'a> for Int32Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Int32Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Int32Array {}
    ///Represents the terminal symbol `
    ///Uint8Array
    ///`
    pub struct Uint8Array;
    #[automatically_derived]
    impl ::core::marker::Copy for Uint8Array {}
    #[automatically_derived]
    impl ::core::default::Default for Uint8Array {
        #[inline]
        fn default() -> Uint8Array {
            Uint8Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uint8Array {
        #[inline]
        fn clone(&self) -> Uint8Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uint8Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uint8Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Uint8Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Uint8Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uint8Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uint8Array {
        #[inline]
        fn eq(&self, other: &Uint8Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Uint8Array {
        #[inline]
        fn cmp(&self, other: &Uint8Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Uint8Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint8Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Uint8Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Uint8Array {
        pub fn value(&self) -> &'static str {
            return "Uint8Array";
        }
    }
    impl<'a> crate::Parse<'a> for Uint8Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Uint8Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Uint8Array {}
    ///Represents the terminal symbol `
    ///Uint16Array
    ///`
    pub struct Uint16Array;
    #[automatically_derived]
    impl ::core::marker::Copy for Uint16Array {}
    #[automatically_derived]
    impl ::core::default::Default for Uint16Array {
        #[inline]
        fn default() -> Uint16Array {
            Uint16Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uint16Array {
        #[inline]
        fn clone(&self) -> Uint16Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uint16Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uint16Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Uint16Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Uint16Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uint16Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uint16Array {
        #[inline]
        fn eq(&self, other: &Uint16Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Uint16Array {
        #[inline]
        fn cmp(&self, other: &Uint16Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Uint16Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint16Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Uint16Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Uint16Array {
        pub fn value(&self) -> &'static str {
            return "Uint16Array";
        }
    }
    impl<'a> crate::Parse<'a> for Uint16Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Uint16Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Uint16Array {}
    ///Represents the terminal symbol `
    ///Uint32Array
    ///`
    pub struct Uint32Array;
    #[automatically_derived]
    impl ::core::marker::Copy for Uint32Array {}
    #[automatically_derived]
    impl ::core::default::Default for Uint32Array {
        #[inline]
        fn default() -> Uint32Array {
            Uint32Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uint32Array {
        #[inline]
        fn clone(&self) -> Uint32Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uint32Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uint32Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Uint32Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Uint32Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uint32Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uint32Array {
        #[inline]
        fn eq(&self, other: &Uint32Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Uint32Array {
        #[inline]
        fn cmp(&self, other: &Uint32Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Uint32Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint32Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Uint32Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Uint32Array {
        pub fn value(&self) -> &'static str {
            return "Uint32Array";
        }
    }
    impl<'a> crate::Parse<'a> for Uint32Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Uint32Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Uint32Array {}
    ///Represents the terminal symbol `
    ///Uint8ClampedArray
    ///`
    pub struct Uint8ClampedArray;
    #[automatically_derived]
    impl ::core::marker::Copy for Uint8ClampedArray {}
    #[automatically_derived]
    impl ::core::default::Default for Uint8ClampedArray {
        #[inline]
        fn default() -> Uint8ClampedArray {
            Uint8ClampedArray {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Uint8ClampedArray {
        #[inline]
        fn clone(&self) -> Uint8ClampedArray {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Uint8ClampedArray {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uint8ClampedArray")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Uint8ClampedArray {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Uint8ClampedArray {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uint8ClampedArray {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uint8ClampedArray {
        #[inline]
        fn eq(&self, other: &Uint8ClampedArray) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Uint8ClampedArray {
        #[inline]
        fn cmp(&self, other: &Uint8ClampedArray) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Uint8ClampedArray {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint8ClampedArray,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Uint8ClampedArray {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Uint8ClampedArray {
        pub fn value(&self) -> &'static str {
            return "Uint8ClampedArray";
        }
    }
    impl<'a> crate::Parse<'a> for Uint8ClampedArray {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(
                                Keyword::Uint8ClampedArray(variant),
                            ),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Uint8ClampedArray {}
    ///Represents the terminal symbol `
    ///BigInt64Array
    ///`
    pub struct BigInt64Array;
    #[automatically_derived]
    impl ::core::marker::Copy for BigInt64Array {}
    #[automatically_derived]
    impl ::core::default::Default for BigInt64Array {
        #[inline]
        fn default() -> BigInt64Array {
            BigInt64Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BigInt64Array {
        #[inline]
        fn clone(&self) -> BigInt64Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BigInt64Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "BigInt64Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BigInt64Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BigInt64Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BigInt64Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BigInt64Array {
        #[inline]
        fn eq(&self, other: &BigInt64Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for BigInt64Array {
        #[inline]
        fn cmp(&self, other: &BigInt64Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for BigInt64Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &BigInt64Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for BigInt64Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl BigInt64Array {
        pub fn value(&self) -> &'static str {
            return "BigInt64Array";
        }
    }
    impl<'a> crate::Parse<'a> for BigInt64Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::BigInt64Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for BigInt64Array {}
    ///Represents the terminal symbol `
    ///BigUint64Array
    ///`
    pub struct BigUint64Array;
    #[automatically_derived]
    impl ::core::marker::Copy for BigUint64Array {}
    #[automatically_derived]
    impl ::core::default::Default for BigUint64Array {
        #[inline]
        fn default() -> BigUint64Array {
            BigUint64Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BigUint64Array {
        #[inline]
        fn clone(&self) -> BigUint64Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BigUint64Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "BigUint64Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BigUint64Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BigUint64Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BigUint64Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BigUint64Array {
        #[inline]
        fn eq(&self, other: &BigUint64Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for BigUint64Array {
        #[inline]
        fn cmp(&self, other: &BigUint64Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for BigUint64Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &BigUint64Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for BigUint64Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl BigUint64Array {
        pub fn value(&self) -> &'static str {
            return "BigUint64Array";
        }
    }
    impl<'a> crate::Parse<'a> for BigUint64Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::BigUint64Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for BigUint64Array {}
    ///Represents the terminal symbol `
    ///Float32Array
    ///`
    pub struct Float32Array;
    #[automatically_derived]
    impl ::core::marker::Copy for Float32Array {}
    #[automatically_derived]
    impl ::core::default::Default for Float32Array {
        #[inline]
        fn default() -> Float32Array {
            Float32Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Float32Array {
        #[inline]
        fn clone(&self) -> Float32Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Float32Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Float32Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Float32Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Float32Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Float32Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Float32Array {
        #[inline]
        fn eq(&self, other: &Float32Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Float32Array {
        #[inline]
        fn cmp(&self, other: &Float32Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Float32Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Float32Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Float32Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Float32Array {
        pub fn value(&self) -> &'static str {
            return "Float32Array";
        }
    }
    impl<'a> crate::Parse<'a> for Float32Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Float32Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Float32Array {}
    ///Represents the terminal symbol `
    ///Float64Array
    ///`
    pub struct Float64Array;
    #[automatically_derived]
    impl ::core::marker::Copy for Float64Array {}
    #[automatically_derived]
    impl ::core::default::Default for Float64Array {
        #[inline]
        fn default() -> Float64Array {
            Float64Array {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Float64Array {
        #[inline]
        fn clone(&self) -> Float64Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Float64Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Float64Array")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Float64Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Float64Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Float64Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Float64Array {
        #[inline]
        fn eq(&self, other: &Float64Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Float64Array {
        #[inline]
        fn cmp(&self, other: &Float64Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Float64Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Float64Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Float64Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Float64Array {
        pub fn value(&self) -> &'static str {
            return "Float64Array";
        }
    }
    impl<'a> crate::Parse<'a> for Float64Array {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Float64Array(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Float64Array {}
    ///Represents the terminal symbol `
    ///Promise
    ///`
    pub struct Promise;
    #[automatically_derived]
    impl ::core::marker::Copy for Promise {}
    #[automatically_derived]
    impl ::core::default::Default for Promise {
        #[inline]
        fn default() -> Promise {
            Promise {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Promise {
        #[inline]
        fn clone(&self) -> Promise {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Promise {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Promise")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Promise {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Promise {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Promise {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Promise {
        #[inline]
        fn eq(&self, other: &Promise) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Promise {
        #[inline]
        fn cmp(&self, other: &Promise) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Promise {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Promise,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Promise {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Promise {
        pub fn value(&self) -> &'static str {
            return "Promise";
        }
    }
    impl<'a> crate::Parse<'a> for Promise {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Promise(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Promise {}
    ///Represents the terminal symbol `
    ///readonly
    ///`
    pub struct ReadOnly;
    #[automatically_derived]
    impl ::core::marker::Copy for ReadOnly {}
    #[automatically_derived]
    impl ::core::default::Default for ReadOnly {
        #[inline]
        fn default() -> ReadOnly {
            ReadOnly {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ReadOnly {
        #[inline]
        fn clone(&self) -> ReadOnly {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ReadOnly {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ReadOnly")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ReadOnly {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ReadOnly {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ReadOnly {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ReadOnly {
        #[inline]
        fn eq(&self, other: &ReadOnly) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ReadOnly {
        #[inline]
        fn cmp(&self, other: &ReadOnly) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ReadOnly {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ReadOnly,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ReadOnly {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl ReadOnly {
        pub fn value(&self) -> &'static str {
            return "readonly";
        }
    }
    impl<'a> crate::Parse<'a> for ReadOnly {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::ReadOnly(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for ReadOnly {}
    ///Represents the terminal symbol `
    ///mixin
    ///`
    pub struct Mixin;
    #[automatically_derived]
    impl ::core::marker::Copy for Mixin {}
    #[automatically_derived]
    impl ::core::default::Default for Mixin {
        #[inline]
        fn default() -> Mixin {
            Mixin {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Mixin {
        #[inline]
        fn clone(&self) -> Mixin {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Mixin {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Mixin")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Mixin {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Mixin {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mixin {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mixin {
        #[inline]
        fn eq(&self, other: &Mixin) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Mixin {
        #[inline]
        fn cmp(&self, other: &Mixin) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Mixin {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Mixin,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Mixin {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Mixin {
        pub fn value(&self) -> &'static str {
            return "mixin";
        }
    }
    impl<'a> crate::Parse<'a> for Mixin {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Mixin(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Mixin {}
    ///Represents the terminal symbol `
    ///constructor
    ///`
    pub struct Constructor;
    #[automatically_derived]
    impl ::core::marker::Copy for Constructor {}
    #[automatically_derived]
    impl ::core::default::Default for Constructor {
        #[inline]
        fn default() -> Constructor {
            Constructor {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Constructor {
        #[inline]
        fn clone(&self) -> Constructor {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Constructor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Constructor")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Constructor {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Constructor {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Constructor {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Constructor {
        #[inline]
        fn eq(&self, other: &Constructor) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Constructor {
        #[inline]
        fn cmp(&self, other: &Constructor) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Constructor {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Constructor,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Constructor {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    impl Constructor {
        pub fn value(&self) -> &'static str {
            return "constructor";
        }
    }
    impl<'a> crate::Parse<'a> for Constructor {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                use crate::lexer::Terminal;
                use crate::term::Keyword;
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: Terminal::Keyword(Keyword::Constructor(variant)),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Constructor {}
    pub enum Keyword {
        /// Represents the terminal symbol `(`
        OpenParen(OpenParen),
        /// Represents the terminal symbol `)`
        CloseParen(CloseParen),
        /// Represents the terminal symbol `[`
        OpenBracket(OpenBracket),
        /// Represents the terminal symbol `]`
        CloseBracket(CloseBracket),
        /// Represents the terminal symbol `{`
        OpenBrace(OpenBrace),
        /// Represents the terminal symbol `}`
        CloseBrace(CloseBrace),
        /// Represents the terminal symbol `,`
        Comma(Comma),
        /// Represents the terminal symbol `-`
        Minus(Minus),
        /// Represents the terminal symbol `...`
        Ellipsis(Ellipsis),
        /// Represents the terminal symbol `.`
        Dot(Dot),
        /// Represents the terminal symbol `:`
        Colon(Colon),
        /// Represents the terminal symbol `;`
        SemiColon(SemiColon),
        /// Represents the terminal symbol `<`
        LessThan(LessThan),
        /// Represents the terminal symbol `=`
        Assign(Assign),
        /// Represents the terminal symbol `>`
        GreaterThan(GreaterThan),
        /// Represents the terminal symbol `?`
        QMark(QMark),
        /// Represents the terminal symbol `*`
        Wildcard(Wildcard),
        ///Represents the terminal symbol `
        ///or
        ///`
        Or(Or),
        ///Represents the terminal symbol `
        ///optional
        ///`
        Optional(Optional),
        ///Represents the terminal symbol `
        ///async
        ///`
        Async(Async),
        ///Represents the terminal symbol `
        ///attribute
        ///`
        Attribute(Attribute),
        ///Represents the terminal symbol `
        ///callback
        ///`
        Callback(Callback),
        ///Represents the terminal symbol `
        ///const
        ///`
        Const(Const),
        ///Represents the terminal symbol `
        ///deleter
        ///`
        Deleter(Deleter),
        ///Represents the terminal symbol `
        ///dictionary
        ///`
        Dictionary(Dictionary),
        ///Represents the terminal symbol `
        ///enum
        ///`
        Enum(Enum),
        ///Represents the terminal symbol `
        ///getter
        ///`
        Getter(Getter),
        ///Represents the terminal symbol `
        ///includes
        ///`
        Includes(Includes),
        ///Represents the terminal symbol `
        ///inherit
        ///`
        Inherit(Inherit),
        ///Represents the terminal symbol `
        ///interface
        ///`
        Interface(Interface),
        ///Represents the terminal symbol `
        ///iterable
        ///`
        Iterable(Iterable),
        ///Represents the terminal symbol `
        ///maplike
        ///`
        Maplike(Maplike),
        ///Represents the terminal symbol `
        ///namespace
        ///`
        Namespace(Namespace),
        ///Represents the terminal symbol `
        ///partial
        ///`
        Partial(Partial),
        ///Represents the terminal symbol `
        ///required
        ///`
        Required(Required),
        ///Represents the terminal symbol `
        ///setlike
        ///`
        Setlike(Setlike),
        ///Represents the terminal symbol `
        ///setter
        ///`
        Setter(Setter),
        ///Represents the terminal symbol `
        ///static
        ///`
        Static(Static),
        ///Represents the terminal symbol `
        ///stringifier
        ///`
        Stringifier(Stringifier),
        ///Represents the terminal symbol `
        ///typedef
        ///`
        Typedef(Typedef),
        ///Represents the terminal symbol `
        ///unrestricted
        ///`
        Unrestricted(Unrestricted),
        ///Represents the terminal symbol `
        ///symbol
        ///`
        Symbol(Symbol),
        ///Represents the terminal symbol `
        ///-Infinity
        ///`
        NegInfinity(NegInfinity),
        ///Represents the terminal symbol `
        ///ByteString
        ///`
        ByteString(ByteString),
        ///Represents the terminal symbol `
        ///DOMString
        ///`
        DOMString(DOMString),
        ///Represents the terminal symbol `
        ///FrozenArray
        ///`
        FrozenArray(FrozenArray),
        ///Represents the terminal symbol `
        ///Infinity
        ///`
        Infinity(Infinity),
        ///Represents the terminal symbol `
        ///NaN
        ///`
        NaN(NaN),
        ///Represents the terminal symbol `
        ///ObservableArray
        ///`
        ObservableArray(ObservableArray),
        ///Represents the terminal symbol `
        ///USVString
        ///`
        USVString(USVString),
        ///Represents the terminal symbol `
        ///any
        ///`
        Any(Any),
        ///Represents the terminal symbol `
        ///bigint
        ///`
        Bigint(Bigint),
        ///Represents the terminal symbol `
        ///boolean
        ///`
        Boolean(Boolean),
        ///Represents the terminal symbol `
        ///byte
        ///`
        Byte(Byte),
        ///Represents the terminal symbol `
        ///double
        ///`
        Double(Double),
        ///Represents the terminal symbol `
        ///false
        ///`
        False(False),
        ///Represents the terminal symbol `
        ///float
        ///`
        Float(Float),
        ///Represents the terminal symbol `
        ///long
        ///`
        Long(Long),
        ///Represents the terminal symbol `
        ///null
        ///`
        Null(Null),
        ///Represents the terminal symbol `
        ///object
        ///`
        Object(Object),
        ///Represents the terminal symbol `
        ///octet
        ///`
        Octet(Octet),
        ///Represents the terminal symbol `
        ///sequence
        ///`
        Sequence(Sequence),
        ///Represents the terminal symbol `
        ///short
        ///`
        Short(Short),
        ///Represents the terminal symbol `
        ///true
        ///`
        True(True),
        ///Represents the terminal symbol `
        ///unsigned
        ///`
        Unsigned(Unsigned),
        ///Represents the terminal symbol `
        ///undefined
        ///`
        Undefined(Undefined),
        ///Represents the terminal symbol `
        ///record
        ///`
        Record(Record),
        ///Represents the terminal symbol `
        ///ArrayBuffer
        ///`
        ArrayBuffer(ArrayBuffer),
        ///Represents the terminal symbol `
        ///DataView
        ///`
        DataView(DataView),
        ///Represents the terminal symbol `
        ///Int8Array
        ///`
        Int8Array(Int8Array),
        ///Represents the terminal symbol `
        ///Int16Array
        ///`
        Int16Array(Int16Array),
        ///Represents the terminal symbol `
        ///Int32Array
        ///`
        Int32Array(Int32Array),
        ///Represents the terminal symbol `
        ///Uint8Array
        ///`
        Uint8Array(Uint8Array),
        ///Represents the terminal symbol `
        ///Uint16Array
        ///`
        Uint16Array(Uint16Array),
        ///Represents the terminal symbol `
        ///Uint32Array
        ///`
        Uint32Array(Uint32Array),
        ///Represents the terminal symbol `
        ///Uint8ClampedArray
        ///`
        Uint8ClampedArray(Uint8ClampedArray),
        ///Represents the terminal symbol `
        ///BigInt64Array
        ///`
        BigInt64Array(BigInt64Array),
        ///Represents the terminal symbol `
        ///BigUint64Array
        ///`
        BigUint64Array(BigUint64Array),
        ///Represents the terminal symbol `
        ///Float32Array
        ///`
        Float32Array(Float32Array),
        ///Represents the terminal symbol `
        ///Float64Array
        ///`
        Float64Array(Float64Array),
        ///Represents the terminal symbol `
        ///Promise
        ///`
        Promise(Promise),
        ///Represents the terminal symbol `
        ///readonly
        ///`
        ReadOnly(ReadOnly),
        ///Represents the terminal symbol `
        ///mixin
        ///`
        Mixin(Mixin),
        ///Represents the terminal symbol `
        ///constructor
        ///`
        Constructor(Constructor),
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Keyword {}
    #[automatically_derived]
    impl ::core::clone::Clone for Keyword {
        #[inline]
        fn clone(&self) -> Keyword {
            let _: ::core::clone::AssertParamIsClone<OpenParen>;
            let _: ::core::clone::AssertParamIsClone<CloseParen>;
            let _: ::core::clone::AssertParamIsClone<OpenBracket>;
            let _: ::core::clone::AssertParamIsClone<CloseBracket>;
            let _: ::core::clone::AssertParamIsClone<OpenBrace>;
            let _: ::core::clone::AssertParamIsClone<CloseBrace>;
            let _: ::core::clone::AssertParamIsClone<Comma>;
            let _: ::core::clone::AssertParamIsClone<Minus>;
            let _: ::core::clone::AssertParamIsClone<Ellipsis>;
            let _: ::core::clone::AssertParamIsClone<Dot>;
            let _: ::core::clone::AssertParamIsClone<Colon>;
            let _: ::core::clone::AssertParamIsClone<SemiColon>;
            let _: ::core::clone::AssertParamIsClone<LessThan>;
            let _: ::core::clone::AssertParamIsClone<Assign>;
            let _: ::core::clone::AssertParamIsClone<GreaterThan>;
            let _: ::core::clone::AssertParamIsClone<QMark>;
            let _: ::core::clone::AssertParamIsClone<Wildcard>;
            let _: ::core::clone::AssertParamIsClone<Or>;
            let _: ::core::clone::AssertParamIsClone<Optional>;
            let _: ::core::clone::AssertParamIsClone<Async>;
            let _: ::core::clone::AssertParamIsClone<Attribute>;
            let _: ::core::clone::AssertParamIsClone<Callback>;
            let _: ::core::clone::AssertParamIsClone<Const>;
            let _: ::core::clone::AssertParamIsClone<Deleter>;
            let _: ::core::clone::AssertParamIsClone<Dictionary>;
            let _: ::core::clone::AssertParamIsClone<Enum>;
            let _: ::core::clone::AssertParamIsClone<Getter>;
            let _: ::core::clone::AssertParamIsClone<Includes>;
            let _: ::core::clone::AssertParamIsClone<Inherit>;
            let _: ::core::clone::AssertParamIsClone<Interface>;
            let _: ::core::clone::AssertParamIsClone<Iterable>;
            let _: ::core::clone::AssertParamIsClone<Maplike>;
            let _: ::core::clone::AssertParamIsClone<Namespace>;
            let _: ::core::clone::AssertParamIsClone<Partial>;
            let _: ::core::clone::AssertParamIsClone<Required>;
            let _: ::core::clone::AssertParamIsClone<Setlike>;
            let _: ::core::clone::AssertParamIsClone<Setter>;
            let _: ::core::clone::AssertParamIsClone<Static>;
            let _: ::core::clone::AssertParamIsClone<Stringifier>;
            let _: ::core::clone::AssertParamIsClone<Typedef>;
            let _: ::core::clone::AssertParamIsClone<Unrestricted>;
            let _: ::core::clone::AssertParamIsClone<Symbol>;
            let _: ::core::clone::AssertParamIsClone<NegInfinity>;
            let _: ::core::clone::AssertParamIsClone<ByteString>;
            let _: ::core::clone::AssertParamIsClone<DOMString>;
            let _: ::core::clone::AssertParamIsClone<FrozenArray>;
            let _: ::core::clone::AssertParamIsClone<Infinity>;
            let _: ::core::clone::AssertParamIsClone<NaN>;
            let _: ::core::clone::AssertParamIsClone<ObservableArray>;
            let _: ::core::clone::AssertParamIsClone<USVString>;
            let _: ::core::clone::AssertParamIsClone<Any>;
            let _: ::core::clone::AssertParamIsClone<Bigint>;
            let _: ::core::clone::AssertParamIsClone<Boolean>;
            let _: ::core::clone::AssertParamIsClone<Byte>;
            let _: ::core::clone::AssertParamIsClone<Double>;
            let _: ::core::clone::AssertParamIsClone<False>;
            let _: ::core::clone::AssertParamIsClone<Float>;
            let _: ::core::clone::AssertParamIsClone<Long>;
            let _: ::core::clone::AssertParamIsClone<Null>;
            let _: ::core::clone::AssertParamIsClone<Object>;
            let _: ::core::clone::AssertParamIsClone<Octet>;
            let _: ::core::clone::AssertParamIsClone<Sequence>;
            let _: ::core::clone::AssertParamIsClone<Short>;
            let _: ::core::clone::AssertParamIsClone<True>;
            let _: ::core::clone::AssertParamIsClone<Unsigned>;
            let _: ::core::clone::AssertParamIsClone<Undefined>;
            let _: ::core::clone::AssertParamIsClone<Record>;
            let _: ::core::clone::AssertParamIsClone<ArrayBuffer>;
            let _: ::core::clone::AssertParamIsClone<DataView>;
            let _: ::core::clone::AssertParamIsClone<Int8Array>;
            let _: ::core::clone::AssertParamIsClone<Int16Array>;
            let _: ::core::clone::AssertParamIsClone<Int32Array>;
            let _: ::core::clone::AssertParamIsClone<Uint8Array>;
            let _: ::core::clone::AssertParamIsClone<Uint16Array>;
            let _: ::core::clone::AssertParamIsClone<Uint32Array>;
            let _: ::core::clone::AssertParamIsClone<Uint8ClampedArray>;
            let _: ::core::clone::AssertParamIsClone<BigInt64Array>;
            let _: ::core::clone::AssertParamIsClone<BigUint64Array>;
            let _: ::core::clone::AssertParamIsClone<Float32Array>;
            let _: ::core::clone::AssertParamIsClone<Float64Array>;
            let _: ::core::clone::AssertParamIsClone<Promise>;
            let _: ::core::clone::AssertParamIsClone<ReadOnly>;
            let _: ::core::clone::AssertParamIsClone<Mixin>;
            let _: ::core::clone::AssertParamIsClone<Constructor>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Keyword {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Keyword::OpenParen(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OpenParen",
                        &__self_0,
                    )
                }
                Keyword::CloseParen(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CloseParen",
                        &__self_0,
                    )
                }
                Keyword::OpenBracket(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OpenBracket",
                        &__self_0,
                    )
                }
                Keyword::CloseBracket(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CloseBracket",
                        &__self_0,
                    )
                }
                Keyword::OpenBrace(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "OpenBrace",
                        &__self_0,
                    )
                }
                Keyword::CloseBrace(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CloseBrace",
                        &__self_0,
                    )
                }
                Keyword::Comma(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Comma",
                        &__self_0,
                    )
                }
                Keyword::Minus(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Minus",
                        &__self_0,
                    )
                }
                Keyword::Ellipsis(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ellipsis",
                        &__self_0,
                    )
                }
                Keyword::Dot(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dot",
                        &__self_0,
                    )
                }
                Keyword::Colon(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Colon",
                        &__self_0,
                    )
                }
                Keyword::SemiColon(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SemiColon",
                        &__self_0,
                    )
                }
                Keyword::LessThan(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LessThan",
                        &__self_0,
                    )
                }
                Keyword::Assign(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Assign",
                        &__self_0,
                    )
                }
                Keyword::GreaterThan(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "GreaterThan",
                        &__self_0,
                    )
                }
                Keyword::QMark(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "QMark",
                        &__self_0,
                    )
                }
                Keyword::Wildcard(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Wildcard",
                        &__self_0,
                    )
                }
                Keyword::Or(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Or", &__self_0)
                }
                Keyword::Optional(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Optional",
                        &__self_0,
                    )
                }
                Keyword::Async(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Async",
                        &__self_0,
                    )
                }
                Keyword::Attribute(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Attribute",
                        &__self_0,
                    )
                }
                Keyword::Callback(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Callback",
                        &__self_0,
                    )
                }
                Keyword::Const(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Const",
                        &__self_0,
                    )
                }
                Keyword::Deleter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Deleter",
                        &__self_0,
                    )
                }
                Keyword::Dictionary(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dictionary",
                        &__self_0,
                    )
                }
                Keyword::Enum(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Enum",
                        &__self_0,
                    )
                }
                Keyword::Getter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Getter",
                        &__self_0,
                    )
                }
                Keyword::Includes(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Includes",
                        &__self_0,
                    )
                }
                Keyword::Inherit(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Inherit",
                        &__self_0,
                    )
                }
                Keyword::Interface(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Interface",
                        &__self_0,
                    )
                }
                Keyword::Iterable(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Iterable",
                        &__self_0,
                    )
                }
                Keyword::Maplike(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Maplike",
                        &__self_0,
                    )
                }
                Keyword::Namespace(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Namespace",
                        &__self_0,
                    )
                }
                Keyword::Partial(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Partial",
                        &__self_0,
                    )
                }
                Keyword::Required(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Required",
                        &__self_0,
                    )
                }
                Keyword::Setlike(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Setlike",
                        &__self_0,
                    )
                }
                Keyword::Setter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Setter",
                        &__self_0,
                    )
                }
                Keyword::Static(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Static",
                        &__self_0,
                    )
                }
                Keyword::Stringifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stringifier",
                        &__self_0,
                    )
                }
                Keyword::Typedef(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Typedef",
                        &__self_0,
                    )
                }
                Keyword::Unrestricted(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Unrestricted",
                        &__self_0,
                    )
                }
                Keyword::Symbol(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Symbol",
                        &__self_0,
                    )
                }
                Keyword::NegInfinity(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NegInfinity",
                        &__self_0,
                    )
                }
                Keyword::ByteString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ByteString",
                        &__self_0,
                    )
                }
                Keyword::DOMString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DOMString",
                        &__self_0,
                    )
                }
                Keyword::FrozenArray(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FrozenArray",
                        &__self_0,
                    )
                }
                Keyword::Infinity(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Infinity",
                        &__self_0,
                    )
                }
                Keyword::NaN(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NaN",
                        &__self_0,
                    )
                }
                Keyword::ObservableArray(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ObservableArray",
                        &__self_0,
                    )
                }
                Keyword::USVString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "USVString",
                        &__self_0,
                    )
                }
                Keyword::Any(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Any",
                        &__self_0,
                    )
                }
                Keyword::Bigint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bigint",
                        &__self_0,
                    )
                }
                Keyword::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                Keyword::Byte(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Byte",
                        &__self_0,
                    )
                }
                Keyword::Double(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Double",
                        &__self_0,
                    )
                }
                Keyword::False(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "False",
                        &__self_0,
                    )
                }
                Keyword::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                Keyword::Long(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Long",
                        &__self_0,
                    )
                }
                Keyword::Null(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Null",
                        &__self_0,
                    )
                }
                Keyword::Object(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Object",
                        &__self_0,
                    )
                }
                Keyword::Octet(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Octet",
                        &__self_0,
                    )
                }
                Keyword::Sequence(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sequence",
                        &__self_0,
                    )
                }
                Keyword::Short(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Short",
                        &__self_0,
                    )
                }
                Keyword::True(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "True",
                        &__self_0,
                    )
                }
                Keyword::Unsigned(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Unsigned",
                        &__self_0,
                    )
                }
                Keyword::Undefined(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Undefined",
                        &__self_0,
                    )
                }
                Keyword::Record(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Record",
                        &__self_0,
                    )
                }
                Keyword::ArrayBuffer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ArrayBuffer",
                        &__self_0,
                    )
                }
                Keyword::DataView(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DataView",
                        &__self_0,
                    )
                }
                Keyword::Int8Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int8Array",
                        &__self_0,
                    )
                }
                Keyword::Int16Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int16Array",
                        &__self_0,
                    )
                }
                Keyword::Int32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int32Array",
                        &__self_0,
                    )
                }
                Keyword::Uint8Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint8Array",
                        &__self_0,
                    )
                }
                Keyword::Uint16Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint16Array",
                        &__self_0,
                    )
                }
                Keyword::Uint32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint32Array",
                        &__self_0,
                    )
                }
                Keyword::Uint8ClampedArray(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint8ClampedArray",
                        &__self_0,
                    )
                }
                Keyword::BigInt64Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BigInt64Array",
                        &__self_0,
                    )
                }
                Keyword::BigUint64Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BigUint64Array",
                        &__self_0,
                    )
                }
                Keyword::Float32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float32Array",
                        &__self_0,
                    )
                }
                Keyword::Float64Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float64Array",
                        &__self_0,
                    )
                }
                Keyword::Promise(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Promise",
                        &__self_0,
                    )
                }
                Keyword::ReadOnly(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ReadOnly",
                        &__self_0,
                    )
                }
                Keyword::Mixin(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mixin",
                        &__self_0,
                    )
                }
                Keyword::Constructor(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Constructor",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Keyword {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Keyword {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<OpenParen>;
            let _: ::core::cmp::AssertParamIsEq<CloseParen>;
            let _: ::core::cmp::AssertParamIsEq<OpenBracket>;
            let _: ::core::cmp::AssertParamIsEq<CloseBracket>;
            let _: ::core::cmp::AssertParamIsEq<OpenBrace>;
            let _: ::core::cmp::AssertParamIsEq<CloseBrace>;
            let _: ::core::cmp::AssertParamIsEq<Comma>;
            let _: ::core::cmp::AssertParamIsEq<Minus>;
            let _: ::core::cmp::AssertParamIsEq<Ellipsis>;
            let _: ::core::cmp::AssertParamIsEq<Dot>;
            let _: ::core::cmp::AssertParamIsEq<Colon>;
            let _: ::core::cmp::AssertParamIsEq<SemiColon>;
            let _: ::core::cmp::AssertParamIsEq<LessThan>;
            let _: ::core::cmp::AssertParamIsEq<Assign>;
            let _: ::core::cmp::AssertParamIsEq<GreaterThan>;
            let _: ::core::cmp::AssertParamIsEq<QMark>;
            let _: ::core::cmp::AssertParamIsEq<Wildcard>;
            let _: ::core::cmp::AssertParamIsEq<Or>;
            let _: ::core::cmp::AssertParamIsEq<Optional>;
            let _: ::core::cmp::AssertParamIsEq<Async>;
            let _: ::core::cmp::AssertParamIsEq<Attribute>;
            let _: ::core::cmp::AssertParamIsEq<Callback>;
            let _: ::core::cmp::AssertParamIsEq<Const>;
            let _: ::core::cmp::AssertParamIsEq<Deleter>;
            let _: ::core::cmp::AssertParamIsEq<Dictionary>;
            let _: ::core::cmp::AssertParamIsEq<Enum>;
            let _: ::core::cmp::AssertParamIsEq<Getter>;
            let _: ::core::cmp::AssertParamIsEq<Includes>;
            let _: ::core::cmp::AssertParamIsEq<Inherit>;
            let _: ::core::cmp::AssertParamIsEq<Interface>;
            let _: ::core::cmp::AssertParamIsEq<Iterable>;
            let _: ::core::cmp::AssertParamIsEq<Maplike>;
            let _: ::core::cmp::AssertParamIsEq<Namespace>;
            let _: ::core::cmp::AssertParamIsEq<Partial>;
            let _: ::core::cmp::AssertParamIsEq<Required>;
            let _: ::core::cmp::AssertParamIsEq<Setlike>;
            let _: ::core::cmp::AssertParamIsEq<Setter>;
            let _: ::core::cmp::AssertParamIsEq<Static>;
            let _: ::core::cmp::AssertParamIsEq<Stringifier>;
            let _: ::core::cmp::AssertParamIsEq<Typedef>;
            let _: ::core::cmp::AssertParamIsEq<Unrestricted>;
            let _: ::core::cmp::AssertParamIsEq<Symbol>;
            let _: ::core::cmp::AssertParamIsEq<NegInfinity>;
            let _: ::core::cmp::AssertParamIsEq<ByteString>;
            let _: ::core::cmp::AssertParamIsEq<DOMString>;
            let _: ::core::cmp::AssertParamIsEq<FrozenArray>;
            let _: ::core::cmp::AssertParamIsEq<Infinity>;
            let _: ::core::cmp::AssertParamIsEq<NaN>;
            let _: ::core::cmp::AssertParamIsEq<ObservableArray>;
            let _: ::core::cmp::AssertParamIsEq<USVString>;
            let _: ::core::cmp::AssertParamIsEq<Any>;
            let _: ::core::cmp::AssertParamIsEq<Bigint>;
            let _: ::core::cmp::AssertParamIsEq<Boolean>;
            let _: ::core::cmp::AssertParamIsEq<Byte>;
            let _: ::core::cmp::AssertParamIsEq<Double>;
            let _: ::core::cmp::AssertParamIsEq<False>;
            let _: ::core::cmp::AssertParamIsEq<Float>;
            let _: ::core::cmp::AssertParamIsEq<Long>;
            let _: ::core::cmp::AssertParamIsEq<Null>;
            let _: ::core::cmp::AssertParamIsEq<Object>;
            let _: ::core::cmp::AssertParamIsEq<Octet>;
            let _: ::core::cmp::AssertParamIsEq<Sequence>;
            let _: ::core::cmp::AssertParamIsEq<Short>;
            let _: ::core::cmp::AssertParamIsEq<True>;
            let _: ::core::cmp::AssertParamIsEq<Unsigned>;
            let _: ::core::cmp::AssertParamIsEq<Undefined>;
            let _: ::core::cmp::AssertParamIsEq<Record>;
            let _: ::core::cmp::AssertParamIsEq<ArrayBuffer>;
            let _: ::core::cmp::AssertParamIsEq<DataView>;
            let _: ::core::cmp::AssertParamIsEq<Int8Array>;
            let _: ::core::cmp::AssertParamIsEq<Int16Array>;
            let _: ::core::cmp::AssertParamIsEq<Int32Array>;
            let _: ::core::cmp::AssertParamIsEq<Uint8Array>;
            let _: ::core::cmp::AssertParamIsEq<Uint16Array>;
            let _: ::core::cmp::AssertParamIsEq<Uint32Array>;
            let _: ::core::cmp::AssertParamIsEq<Uint8ClampedArray>;
            let _: ::core::cmp::AssertParamIsEq<BigInt64Array>;
            let _: ::core::cmp::AssertParamIsEq<BigUint64Array>;
            let _: ::core::cmp::AssertParamIsEq<Float32Array>;
            let _: ::core::cmp::AssertParamIsEq<Float64Array>;
            let _: ::core::cmp::AssertParamIsEq<Promise>;
            let _: ::core::cmp::AssertParamIsEq<ReadOnly>;
            let _: ::core::cmp::AssertParamIsEq<Mixin>;
            let _: ::core::cmp::AssertParamIsEq<Constructor>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Keyword {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Keyword {
        #[inline]
        fn eq(&self, other: &Keyword) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Keyword::OpenParen(__self_0), Keyword::OpenParen(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::CloseParen(__self_0), Keyword::CloseParen(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::OpenBracket(__self_0), Keyword::OpenBracket(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        Keyword::CloseBracket(__self_0),
                        Keyword::CloseBracket(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (Keyword::OpenBrace(__self_0), Keyword::OpenBrace(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::CloseBrace(__self_0), Keyword::CloseBrace(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Comma(__self_0), Keyword::Comma(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Minus(__self_0), Keyword::Minus(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Ellipsis(__self_0), Keyword::Ellipsis(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Dot(__self_0), Keyword::Dot(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Colon(__self_0), Keyword::Colon(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::SemiColon(__self_0), Keyword::SemiColon(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::LessThan(__self_0), Keyword::LessThan(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Assign(__self_0), Keyword::Assign(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::GreaterThan(__self_0), Keyword::GreaterThan(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::QMark(__self_0), Keyword::QMark(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Wildcard(__self_0), Keyword::Wildcard(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Or(__self_0), Keyword::Or(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Optional(__self_0), Keyword::Optional(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Async(__self_0), Keyword::Async(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Attribute(__self_0), Keyword::Attribute(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Callback(__self_0), Keyword::Callback(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Const(__self_0), Keyword::Const(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Deleter(__self_0), Keyword::Deleter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Dictionary(__self_0), Keyword::Dictionary(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Enum(__self_0), Keyword::Enum(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Getter(__self_0), Keyword::Getter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Includes(__self_0), Keyword::Includes(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Inherit(__self_0), Keyword::Inherit(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Interface(__self_0), Keyword::Interface(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Iterable(__self_0), Keyword::Iterable(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Maplike(__self_0), Keyword::Maplike(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Namespace(__self_0), Keyword::Namespace(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Partial(__self_0), Keyword::Partial(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Required(__self_0), Keyword::Required(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Setlike(__self_0), Keyword::Setlike(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Setter(__self_0), Keyword::Setter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Static(__self_0), Keyword::Static(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Stringifier(__self_0), Keyword::Stringifier(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Typedef(__self_0), Keyword::Typedef(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        Keyword::Unrestricted(__self_0),
                        Keyword::Unrestricted(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (Keyword::Symbol(__self_0), Keyword::Symbol(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::NegInfinity(__self_0), Keyword::NegInfinity(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::ByteString(__self_0), Keyword::ByteString(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::DOMString(__self_0), Keyword::DOMString(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::FrozenArray(__self_0), Keyword::FrozenArray(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Infinity(__self_0), Keyword::Infinity(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::NaN(__self_0), Keyword::NaN(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        Keyword::ObservableArray(__self_0),
                        Keyword::ObservableArray(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (Keyword::USVString(__self_0), Keyword::USVString(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Any(__self_0), Keyword::Any(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Bigint(__self_0), Keyword::Bigint(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Boolean(__self_0), Keyword::Boolean(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Byte(__self_0), Keyword::Byte(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Double(__self_0), Keyword::Double(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::False(__self_0), Keyword::False(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Float(__self_0), Keyword::Float(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Long(__self_0), Keyword::Long(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Null(__self_0), Keyword::Null(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Object(__self_0), Keyword::Object(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Octet(__self_0), Keyword::Octet(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Sequence(__self_0), Keyword::Sequence(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Short(__self_0), Keyword::Short(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::True(__self_0), Keyword::True(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Unsigned(__self_0), Keyword::Unsigned(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Undefined(__self_0), Keyword::Undefined(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Record(__self_0), Keyword::Record(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::ArrayBuffer(__self_0), Keyword::ArrayBuffer(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::DataView(__self_0), Keyword::DataView(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Int8Array(__self_0), Keyword::Int8Array(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Int16Array(__self_0), Keyword::Int16Array(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Int32Array(__self_0), Keyword::Int32Array(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Uint8Array(__self_0), Keyword::Uint8Array(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Uint16Array(__self_0), Keyword::Uint16Array(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Uint32Array(__self_0), Keyword::Uint32Array(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        Keyword::Uint8ClampedArray(__self_0),
                        Keyword::Uint8ClampedArray(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        Keyword::BigInt64Array(__self_0),
                        Keyword::BigInt64Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        Keyword::BigUint64Array(__self_0),
                        Keyword::BigUint64Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        Keyword::Float32Array(__self_0),
                        Keyword::Float32Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        Keyword::Float64Array(__self_0),
                        Keyword::Float64Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (Keyword::Promise(__self_0), Keyword::Promise(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::ReadOnly(__self_0), Keyword::ReadOnly(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Mixin(__self_0), Keyword::Mixin(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Keyword::Constructor(__self_0), Keyword::Constructor(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Keyword {
        #[inline]
        fn cmp(&self, other: &Keyword) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Keyword::OpenParen(__self_0), Keyword::OpenParen(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::CloseParen(__self_0),
                            Keyword::CloseParen(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::OpenBracket(__self_0),
                            Keyword::OpenBracket(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::CloseBracket(__self_0),
                            Keyword::CloseBracket(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::OpenBrace(__self_0), Keyword::OpenBrace(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::CloseBrace(__self_0),
                            Keyword::CloseBrace(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::Comma(__self_0), Keyword::Comma(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Minus(__self_0), Keyword::Minus(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Ellipsis(__self_0), Keyword::Ellipsis(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Dot(__self_0), Keyword::Dot(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Colon(__self_0), Keyword::Colon(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::SemiColon(__self_0), Keyword::SemiColon(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::LessThan(__self_0), Keyword::LessThan(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Assign(__self_0), Keyword::Assign(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::GreaterThan(__self_0),
                            Keyword::GreaterThan(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::QMark(__self_0), Keyword::QMark(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Wildcard(__self_0), Keyword::Wildcard(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Or(__self_0), Keyword::Or(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Optional(__self_0), Keyword::Optional(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Async(__self_0), Keyword::Async(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Attribute(__self_0), Keyword::Attribute(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Callback(__self_0), Keyword::Callback(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Const(__self_0), Keyword::Const(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Deleter(__self_0), Keyword::Deleter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Dictionary(__self_0),
                            Keyword::Dictionary(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::Enum(__self_0), Keyword::Enum(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Getter(__self_0), Keyword::Getter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Includes(__self_0), Keyword::Includes(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Inherit(__self_0), Keyword::Inherit(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Interface(__self_0), Keyword::Interface(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Iterable(__self_0), Keyword::Iterable(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Maplike(__self_0), Keyword::Maplike(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Namespace(__self_0), Keyword::Namespace(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Partial(__self_0), Keyword::Partial(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Required(__self_0), Keyword::Required(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Setlike(__self_0), Keyword::Setlike(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Setter(__self_0), Keyword::Setter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Static(__self_0), Keyword::Static(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Stringifier(__self_0),
                            Keyword::Stringifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::Typedef(__self_0), Keyword::Typedef(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Unrestricted(__self_0),
                            Keyword::Unrestricted(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::Symbol(__self_0), Keyword::Symbol(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::NegInfinity(__self_0),
                            Keyword::NegInfinity(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::ByteString(__self_0),
                            Keyword::ByteString(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::DOMString(__self_0), Keyword::DOMString(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::FrozenArray(__self_0),
                            Keyword::FrozenArray(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::Infinity(__self_0), Keyword::Infinity(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::NaN(__self_0), Keyword::NaN(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::ObservableArray(__self_0),
                            Keyword::ObservableArray(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::USVString(__self_0), Keyword::USVString(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Any(__self_0), Keyword::Any(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Bigint(__self_0), Keyword::Bigint(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Boolean(__self_0), Keyword::Boolean(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Byte(__self_0), Keyword::Byte(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Double(__self_0), Keyword::Double(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::False(__self_0), Keyword::False(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Float(__self_0), Keyword::Float(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Long(__self_0), Keyword::Long(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Null(__self_0), Keyword::Null(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Object(__self_0), Keyword::Object(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Octet(__self_0), Keyword::Octet(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Sequence(__self_0), Keyword::Sequence(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Short(__self_0), Keyword::Short(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::True(__self_0), Keyword::True(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Unsigned(__self_0), Keyword::Unsigned(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Undefined(__self_0), Keyword::Undefined(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Record(__self_0), Keyword::Record(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::ArrayBuffer(__self_0),
                            Keyword::ArrayBuffer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::DataView(__self_0), Keyword::DataView(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Int8Array(__self_0), Keyword::Int8Array(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Int16Array(__self_0),
                            Keyword::Int16Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::Int32Array(__self_0),
                            Keyword::Int32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::Uint8Array(__self_0),
                            Keyword::Uint8Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::Uint16Array(__self_0),
                            Keyword::Uint16Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::Uint32Array(__self_0),
                            Keyword::Uint32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::Uint8ClampedArray(__self_0),
                            Keyword::Uint8ClampedArray(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::BigInt64Array(__self_0),
                            Keyword::BigInt64Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::BigUint64Array(__self_0),
                            Keyword::BigUint64Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::Float32Array(__self_0),
                            Keyword::Float32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Keyword::Float64Array(__self_0),
                            Keyword::Float64Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Keyword::Promise(__self_0), Keyword::Promise(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::ReadOnly(__self_0), Keyword::ReadOnly(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Mixin(__self_0), Keyword::Mixin(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Constructor(__self_0),
                            Keyword::Constructor(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Keyword {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Keyword,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Keyword::OpenParen(__self_0), Keyword::OpenParen(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::CloseParen(__self_0),
                            Keyword::CloseParen(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::OpenBracket(__self_0),
                            Keyword::OpenBracket(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::CloseBracket(__self_0),
                            Keyword::CloseBracket(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::OpenBrace(__self_0), Keyword::OpenBrace(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::CloseBrace(__self_0),
                            Keyword::CloseBrace(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::Comma(__self_0), Keyword::Comma(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Minus(__self_0), Keyword::Minus(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Ellipsis(__self_0), Keyword::Ellipsis(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Dot(__self_0), Keyword::Dot(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Colon(__self_0), Keyword::Colon(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::SemiColon(__self_0), Keyword::SemiColon(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::LessThan(__self_0), Keyword::LessThan(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Assign(__self_0), Keyword::Assign(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::GreaterThan(__self_0),
                            Keyword::GreaterThan(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::QMark(__self_0), Keyword::QMark(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Wildcard(__self_0), Keyword::Wildcard(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Or(__self_0), Keyword::Or(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Optional(__self_0), Keyword::Optional(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Async(__self_0), Keyword::Async(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Attribute(__self_0), Keyword::Attribute(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Callback(__self_0), Keyword::Callback(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Const(__self_0), Keyword::Const(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Deleter(__self_0), Keyword::Deleter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Dictionary(__self_0),
                            Keyword::Dictionary(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::Enum(__self_0), Keyword::Enum(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Getter(__self_0), Keyword::Getter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Includes(__self_0), Keyword::Includes(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Inherit(__self_0), Keyword::Inherit(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Interface(__self_0), Keyword::Interface(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Iterable(__self_0), Keyword::Iterable(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Maplike(__self_0), Keyword::Maplike(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Namespace(__self_0), Keyword::Namespace(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Partial(__self_0), Keyword::Partial(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Required(__self_0), Keyword::Required(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Setlike(__self_0), Keyword::Setlike(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Setter(__self_0), Keyword::Setter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Static(__self_0), Keyword::Static(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Stringifier(__self_0),
                            Keyword::Stringifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::Typedef(__self_0), Keyword::Typedef(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Unrestricted(__self_0),
                            Keyword::Unrestricted(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::Symbol(__self_0), Keyword::Symbol(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::NegInfinity(__self_0),
                            Keyword::NegInfinity(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::ByteString(__self_0),
                            Keyword::ByteString(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::DOMString(__self_0), Keyword::DOMString(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::FrozenArray(__self_0),
                            Keyword::FrozenArray(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::Infinity(__self_0), Keyword::Infinity(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::NaN(__self_0), Keyword::NaN(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::ObservableArray(__self_0),
                            Keyword::ObservableArray(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::USVString(__self_0), Keyword::USVString(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Any(__self_0), Keyword::Any(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Bigint(__self_0), Keyword::Bigint(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Boolean(__self_0), Keyword::Boolean(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Byte(__self_0), Keyword::Byte(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Double(__self_0), Keyword::Double(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::False(__self_0), Keyword::False(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Float(__self_0), Keyword::Float(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Long(__self_0), Keyword::Long(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Null(__self_0), Keyword::Null(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Object(__self_0), Keyword::Object(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Octet(__self_0), Keyword::Octet(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Sequence(__self_0), Keyword::Sequence(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Short(__self_0), Keyword::Short(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::True(__self_0), Keyword::True(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Unsigned(__self_0), Keyword::Unsigned(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Undefined(__self_0), Keyword::Undefined(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Record(__self_0), Keyword::Record(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::ArrayBuffer(__self_0),
                            Keyword::ArrayBuffer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::DataView(__self_0), Keyword::DataView(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Int8Array(__self_0), Keyword::Int8Array(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Int16Array(__self_0),
                            Keyword::Int16Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::Int32Array(__self_0),
                            Keyword::Int32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::Uint8Array(__self_0),
                            Keyword::Uint8Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::Uint16Array(__self_0),
                            Keyword::Uint16Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::Uint32Array(__self_0),
                            Keyword::Uint32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::Uint8ClampedArray(__self_0),
                            Keyword::Uint8ClampedArray(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::BigInt64Array(__self_0),
                            Keyword::BigInt64Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::BigUint64Array(__self_0),
                            Keyword::BigUint64Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::Float32Array(__self_0),
                            Keyword::Float32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Keyword::Float64Array(__self_0),
                            Keyword::Float64Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Keyword::Promise(__self_0), Keyword::Promise(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::ReadOnly(__self_0), Keyword::ReadOnly(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Keyword::Mixin(__self_0), Keyword::Mixin(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Keyword::Constructor(__self_0),
                            Keyword::Constructor(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Keyword {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Keyword::OpenParen(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::CloseParen(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::OpenBracket(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::CloseBracket(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::OpenBrace(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::CloseBrace(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Comma(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Minus(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Ellipsis(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Dot(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Colon(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::SemiColon(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::LessThan(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Assign(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::GreaterThan(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::QMark(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Wildcard(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Or(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Optional(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Async(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Attribute(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Callback(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Const(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Deleter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Dictionary(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Enum(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Getter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Includes(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Inherit(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Interface(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Iterable(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Maplike(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Namespace(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Partial(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Required(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Setlike(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Setter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Static(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Stringifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Typedef(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Unrestricted(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Symbol(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::NegInfinity(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::ByteString(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::DOMString(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::FrozenArray(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Infinity(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::NaN(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::ObservableArray(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::USVString(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Any(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Bigint(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Boolean(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Byte(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Double(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::False(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Float(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Long(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Null(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Object(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Octet(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Sequence(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Short(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::True(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Unsigned(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Undefined(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Record(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::ArrayBuffer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::DataView(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Int8Array(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Int16Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Int32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Uint8Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Uint16Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Uint32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Uint8ClampedArray(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::BigInt64Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::BigUint64Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Float32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Float64Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Keyword::Promise(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::ReadOnly(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Mixin(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Keyword::Constructor(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    impl Keyword {
        pub fn parse_punc(input: &str) -> crate::VerboseResult<&str, Keyword> {
            nom::branch::alt((
                nom::combinator::map(
                    nom::combinator::recognize(nom::bytes::complete::tag("(")),
                    |_| Keyword::OpenParen(OpenParen),
                ),
                nom::combinator::map(
                    nom::combinator::recognize(nom::bytes::complete::tag(")")),
                    |_| Keyword::CloseParen(CloseParen),
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        nom::combinator::recognize(nom::bytes::complete::tag("[")),
                        |_| Keyword::OpenBracket(OpenBracket),
                    ),
                    nom::combinator::map(
                        nom::combinator::recognize(nom::bytes::complete::tag("]")),
                        |_| Keyword::CloseBracket(CloseBracket),
                    ),
                    nom::branch::alt((
                        nom::combinator::map(
                            nom::combinator::recognize(nom::bytes::complete::tag("{")),
                            |_| Keyword::OpenBrace(OpenBrace),
                        ),
                        nom::combinator::map(
                            nom::combinator::recognize(nom::bytes::complete::tag("}")),
                            |_| Keyword::CloseBrace(CloseBrace),
                        ),
                        nom::branch::alt((
                            nom::combinator::map(
                                nom::combinator::recognize(nom::bytes::complete::tag(",")),
                                |_| Keyword::Comma(Comma),
                            ),
                            nom::combinator::map(
                                nom::combinator::recognize(nom::bytes::complete::tag("-")),
                                |_| Keyword::Minus(Minus),
                            ),
                            nom::branch::alt((
                                nom::combinator::map(
                                    nom::combinator::recognize(
                                        nom::bytes::complete::tag("..."),
                                    ),
                                    |_| Keyword::Ellipsis(Ellipsis),
                                ),
                                nom::combinator::map(
                                    nom::combinator::recognize(nom::bytes::complete::tag(".")),
                                    |_| Keyword::Dot(Dot),
                                ),
                                nom::branch::alt((
                                    nom::combinator::map(
                                        nom::combinator::recognize(nom::bytes::complete::tag(":")),
                                        |_| Keyword::Colon(Colon),
                                    ),
                                    nom::combinator::map(
                                        nom::combinator::recognize(nom::bytes::complete::tag(";")),
                                        |_| Keyword::SemiColon(SemiColon),
                                    ),
                                    nom::branch::alt((
                                        nom::combinator::map(
                                            nom::combinator::recognize(nom::bytes::complete::tag("<")),
                                            |_| Keyword::LessThan(LessThan),
                                        ),
                                        nom::combinator::map(
                                            nom::combinator::recognize(nom::bytes::complete::tag("=")),
                                            |_| Keyword::Assign(Assign),
                                        ),
                                        nom::branch::alt((
                                            nom::combinator::map(
                                                nom::combinator::recognize(nom::bytes::complete::tag(">")),
                                                |_| Keyword::GreaterThan(GreaterThan),
                                            ),
                                            nom::combinator::map(
                                                nom::combinator::recognize(nom::bytes::complete::tag("?")),
                                                |_| Keyword::QMark(QMark),
                                            ),
                                            nom::combinator::map(
                                                nom::combinator::recognize(nom::bytes::complete::tag("*")),
                                                |_| Keyword::Wildcard(Wildcard),
                                            ),
                                        )),
                                    )),
                                )),
                            )),
                        )),
                    )),
                )),
            ))(input)
        }
        pub fn match_word(input: &str) -> Option<Keyword> {
            match input {
                "or" => Some(Keyword::Or(Or)),
                "optional" => Some(Keyword::Optional(Optional)),
                "async" => Some(Keyword::Async(Async)),
                "attribute" => Some(Keyword::Attribute(Attribute)),
                "callback" => Some(Keyword::Callback(Callback)),
                "const" => Some(Keyword::Const(Const)),
                "deleter" => Some(Keyword::Deleter(Deleter)),
                "dictionary" => Some(Keyword::Dictionary(Dictionary)),
                "enum" => Some(Keyword::Enum(Enum)),
                "getter" => Some(Keyword::Getter(Getter)),
                "includes" => Some(Keyword::Includes(Includes)),
                "inherit" => Some(Keyword::Inherit(Inherit)),
                "interface" => Some(Keyword::Interface(Interface)),
                "iterable" => Some(Keyword::Iterable(Iterable)),
                "maplike" => Some(Keyword::Maplike(Maplike)),
                "namespace" => Some(Keyword::Namespace(Namespace)),
                "partial" => Some(Keyword::Partial(Partial)),
                "required" => Some(Keyword::Required(Required)),
                "setlike" => Some(Keyword::Setlike(Setlike)),
                "setter" => Some(Keyword::Setter(Setter)),
                "static" => Some(Keyword::Static(Static)),
                "stringifier" => Some(Keyword::Stringifier(Stringifier)),
                "typedef" => Some(Keyword::Typedef(Typedef)),
                "unrestricted" => Some(Keyword::Unrestricted(Unrestricted)),
                "symbol" => Some(Keyword::Symbol(Symbol)),
                "-Infinity" => Some(Keyword::NegInfinity(NegInfinity)),
                "ByteString" => Some(Keyword::ByteString(ByteString)),
                "DOMString" => Some(Keyword::DOMString(DOMString)),
                "FrozenArray" => Some(Keyword::FrozenArray(FrozenArray)),
                "Infinity" => Some(Keyword::Infinity(Infinity)),
                "NaN" => Some(Keyword::NaN(NaN)),
                "ObservableArray" => Some(Keyword::ObservableArray(ObservableArray)),
                "USVString" => Some(Keyword::USVString(USVString)),
                "any" => Some(Keyword::Any(Any)),
                "bigint" => Some(Keyword::Bigint(Bigint)),
                "boolean" => Some(Keyword::Boolean(Boolean)),
                "byte" => Some(Keyword::Byte(Byte)),
                "double" => Some(Keyword::Double(Double)),
                "false" => Some(Keyword::False(False)),
                "float" => Some(Keyword::Float(Float)),
                "long" => Some(Keyword::Long(Long)),
                "null" => Some(Keyword::Null(Null)),
                "object" => Some(Keyword::Object(Object)),
                "octet" => Some(Keyword::Octet(Octet)),
                "sequence" => Some(Keyword::Sequence(Sequence)),
                "short" => Some(Keyword::Short(Short)),
                "true" => Some(Keyword::True(True)),
                "unsigned" => Some(Keyword::Unsigned(Unsigned)),
                "undefined" => Some(Keyword::Undefined(Undefined)),
                "record" => Some(Keyword::Record(Record)),
                "ArrayBuffer" => Some(Keyword::ArrayBuffer(ArrayBuffer)),
                "DataView" => Some(Keyword::DataView(DataView)),
                "Int8Array" => Some(Keyword::Int8Array(Int8Array)),
                "Int16Array" => Some(Keyword::Int16Array(Int16Array)),
                "Int32Array" => Some(Keyword::Int32Array(Int32Array)),
                "Uint8Array" => Some(Keyword::Uint8Array(Uint8Array)),
                "Uint16Array" => Some(Keyword::Uint16Array(Uint16Array)),
                "Uint32Array" => Some(Keyword::Uint32Array(Uint32Array)),
                "Uint8ClampedArray" => {
                    Some(Keyword::Uint8ClampedArray(Uint8ClampedArray))
                }
                "BigInt64Array" => Some(Keyword::BigInt64Array(BigInt64Array)),
                "BigUint64Array" => Some(Keyword::BigUint64Array(BigUint64Array)),
                "Float32Array" => Some(Keyword::Float32Array(Float32Array)),
                "Float64Array" => Some(Keyword::Float64Array(Float64Array)),
                "Promise" => Some(Keyword::Promise(Promise)),
                "readonly" => Some(Keyword::ReadOnly(ReadOnly)),
                "mixin" => Some(Keyword::Mixin(Mixin)),
                "constructor" => Some(Keyword::Constructor(Constructor)),
                _ => None,
            }
        }
    }
}
pub mod argument {
    use weedle_derive::Weedle;
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Default, Identifier, Punctuated};
    use crate::tokens::Tokens;
    use crate::types::{AttributedType, Type};
    use crate::{Parse, ParsePost, VerboseResult};
    /// Parses a list of argument. Ex: `double v1, double v2, double v3, optional double alpha`
    pub type ArgumentList<'a> = Punctuated<Argument<'a>, crate::term::Comma>;
    struct ArgumentName<'a>(&'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ArgumentName<'a> {
        #[inline]
        fn clone(&self) -> ArgumentName<'a> {
            ArgumentName(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ArgumentName<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "ArgumentName",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ArgumentName<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ArgumentName<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ArgumentName<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ArgumentName<'a> {
        #[inline]
        fn eq(&self, other: &ArgumentName<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ArgumentName<'a> {
        #[inline]
        fn cmp(&self, other: &ArgumentName<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ArgumentName<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ArgumentName<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ArgumentName<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> Parse<'a> for ArgumentName<'a> {
        fn parse_body<'slice>(
            input: Tokens<'slice, 'a>,
        ) -> VerboseResult<Tokens<'slice, 'a>, Self> {
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: crate::lexer::Terminal::Identifier(variant),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.0)));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Async(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Attribute(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Callback(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Const(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Constructor(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Deleter(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Dictionary(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Enum(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Getter(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Includes(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Inherit(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Interface(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Iterable(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Maplike(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Mixin(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Namespace(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Partial(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::ReadOnly(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Required(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Setlike(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Setter(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Static(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Stringifier(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Typedef(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Unrestricted(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, ArgumentName(result.value())));
            }
            nom::combinator::fail(input)
        }
    }
    impl<'a> ParsePost<'a> for ArgumentName<'a> {}
    impl<'a> From<ArgumentName<'a>> for Identifier<'a> {
        fn from(value: ArgumentName<'a>) -> Self {
            Self(value.0)
        }
    }
    /// Parses `[attributes]? optional? attributedtype identifier ( = default )?`
    ///
    /// Note: `= default` is only allowed if `optional` is present
    pub struct SingleArgument<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub optional: Option<crate::term::Optional>,
        pub type_: AttributedType<'a>,
        #[weedle(from = "ArgumentName")]
        pub identifier: Identifier<'a>,
        #[weedle(cond = "optional.is_some()")]
        pub default: Option<Default<'a>>,
    }
    impl<'a> crate::Parse<'a> for SingleArgument<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, optional) = <Option<
                crate::term::Optional,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, type_) = <AttributedType<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, identifier) = nom::combinator::into(
                <ArgumentName as crate::Parse<'a>>::parse_tokens,
            )(input)?;
            let (input, default) = nom::combinator::map(
                nom::combinator::cond(
                    optional.is_some(),
                    <Option<Default<'a>> as crate::Parse<'a>>::parse_tokens,
                ),
                |opt| opt.flatten(),
            )(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    optional,
                    type_,
                    identifier,
                    default,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for SingleArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SingleArgument<'a> {
        #[inline]
        fn clone(&self) -> SingleArgument<'a> {
            SingleArgument {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                optional: ::core::clone::Clone::clone(&self.optional),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                default: ::core::clone::Clone::clone(&self.default),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SingleArgument<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SingleArgument",
                "attributes",
                &&self.attributes,
                "optional",
                &&self.optional,
                "type_",
                &&self.type_,
                "identifier",
                &&self.identifier,
                "default",
                &&self.default,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SingleArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SingleArgument<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Optional>>;
            let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Default<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SingleArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SingleArgument<'a> {
        #[inline]
        fn eq(&self, other: &SingleArgument<'a>) -> bool {
            self.attributes == other.attributes && self.optional == other.optional
                && self.type_ == other.type_ && self.identifier == other.identifier
                && self.default == other.default
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SingleArgument<'a> {
        #[inline]
        fn cmp(&self, other: &SingleArgument<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.optional, &other.optional) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.default, &other.default)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SingleArgument<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SingleArgument<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.optional,
                        &other.optional,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.type_,
                                &other.type_,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.default,
                                                &other.default,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SingleArgument<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.optional, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.default, state)
        }
    }
    /// Parses `[attributes]? type... identifier`
    pub struct VariadicArgument<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub type_: Type<'a>,
        pub ellipsis: crate::term::Ellipsis,
        pub identifier: Identifier<'a>,
    }
    impl<'a> crate::Parse<'a> for VariadicArgument<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, type_) = <Type<'a> as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, ellipsis) = <crate::term::Ellipsis as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    type_,
                    ellipsis,
                    identifier,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for VariadicArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for VariadicArgument<'a> {
        #[inline]
        fn clone(&self) -> VariadicArgument<'a> {
            VariadicArgument {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                type_: ::core::clone::Clone::clone(&self.type_),
                ellipsis: ::core::clone::Clone::clone(&self.ellipsis),
                identifier: ::core::clone::Clone::clone(&self.identifier),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for VariadicArgument<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "VariadicArgument",
                "attributes",
                &&self.attributes,
                "type_",
                &&self.type_,
                "ellipsis",
                &&self.ellipsis,
                "identifier",
                &&self.identifier,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for VariadicArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for VariadicArgument<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Ellipsis>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for VariadicArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for VariadicArgument<'a> {
        #[inline]
        fn eq(&self, other: &VariadicArgument<'a>) -> bool {
            self.attributes == other.attributes && self.type_ == other.type_
                && self.ellipsis == other.ellipsis && self.identifier == other.identifier
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for VariadicArgument<'a> {
        #[inline]
        fn cmp(&self, other: &VariadicArgument<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.ellipsis,
                                &other.ellipsis,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.identifier, &other.identifier)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for VariadicArgument<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &VariadicArgument<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.type_,
                        &other.type_,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.ellipsis,
                                &other.ellipsis,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for VariadicArgument<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.ellipsis, state);
            ::core::hash::Hash::hash(&self.identifier, state)
        }
    }
    /// Parses an argument. Ex: `double v1|double... v1s`
    pub enum Argument<'a> {
        Single(SingleArgument<'a>),
        Variadic(VariadicArgument<'a>),
    }
    impl<'a> crate::Parse<'a> for Argument<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <SingleArgument<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Single),
                <VariadicArgument<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Variadic),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Argument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Argument<'a> {
        #[inline]
        fn clone(&self) -> Argument<'a> {
            match self {
                Argument::Single(__self_0) => {
                    Argument::Single(::core::clone::Clone::clone(__self_0))
                }
                Argument::Variadic(__self_0) => {
                    Argument::Variadic(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Argument<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Argument::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                Argument::Variadic(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Variadic",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Argument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Argument<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<SingleArgument<'a>>;
            let _: ::core::cmp::AssertParamIsEq<VariadicArgument<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Argument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Argument<'a> {
        #[inline]
        fn eq(&self, other: &Argument<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Argument::Single(__self_0), Argument::Single(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Argument::Variadic(__self_0), Argument::Variadic(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Argument<'a> {
        #[inline]
        fn cmp(&self, other: &Argument<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Argument::Single(__self_0), Argument::Single(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Argument::Variadic(__self_0), Argument::Variadic(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Argument<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Argument<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Argument::Single(__self_0), Argument::Single(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Argument::Variadic(__self_0), Argument::Variadic(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Argument<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Argument::Single(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Argument::Variadic(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
}
pub mod attribute {
    use weedle_derive::Weedle;
    use crate::argument::ArgumentList;
    use crate::common::{
        Bracketed, Identifier, Parenthesized, Punctuated, PunctuatedNonEmpty,
    };
    use crate::literal::{FloatLit, IntegerLit, StringLit};
    /// Parses a list of attributes. Ex: `[ attribute1, attribute2 ]`
    pub type ExtendedAttributeList<'a> = Bracketed<
        PunctuatedNonEmpty<ExtendedAttribute<'a>, crate::term::Comma>,
    >;
    /// Matches comma separated identifier list
    pub type IdentifierListNonEmpty<'a> = PunctuatedNonEmpty<
        Identifier<'a>,
        crate::term::Comma,
    >;
    pub type IdentifierList<'a> = Punctuated<Identifier<'a>, crate::term::Comma>;
    pub type StringListNonEmpty<'a> = PunctuatedNonEmpty<
        StringLit<'a>,
        crate::term::Comma,
    >;
    pub type StringList<'a> = Punctuated<StringLit<'a>, crate::term::Comma>;
    pub type FloatListNonEmpty<'a> = PunctuatedNonEmpty<
        FloatLit<'a>,
        crate::term::Comma,
    >;
    pub type FloatList<'a> = Punctuated<FloatLit<'a>, crate::term::Comma>;
    pub type IntegerListNonEmpty<'a> = PunctuatedNonEmpty<
        IntegerLit<'a>,
        crate::term::Comma,
    >;
    pub type IntegerList<'a> = Punctuated<IntegerLit<'a>, crate::term::Comma>;
    /// Parses an argument list. Ex: `Constructor((double x, double y))`
    ///
    /// (( )) means ( ) chars
    pub struct ExtendedAttributeArgList<'a> {
        pub identifier: Identifier<'a>,
        pub args: Parenthesized<ArgumentList<'a>>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeArgList<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, args) = <Parenthesized<
                ArgumentList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { identifier, args }))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeArgList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeArgList<'a> {
            ExtendedAttributeArgList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                args: ::core::clone::Clone::clone(&self.args),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeArgList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ExtendedAttributeArgList",
                "identifier",
                &&self.identifier,
                "args",
                &&self.args,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeArgList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeArgList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeArgList<'a>) -> bool {
            self.identifier == other.identifier && self.args == other.args
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeArgList<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeArgList<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.args, &other.args)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeArgList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeArgList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.args, &other.args)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeArgList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.args, state)
        }
    }
    /// Parses a named argument list. Ex: `NamedConstructor=Image((DOMString src))`
    ///
    /// (( )) means ( ) chars
    pub struct ExtendedAttributeNamedArgList<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs_identifier: Identifier<'a>,
        pub args: Parenthesized<ArgumentList<'a>>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeNamedArgList<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, lhs_identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, rhs_identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, args) = <Parenthesized<
                ArgumentList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    lhs_identifier,
                    assign,
                    rhs_identifier,
                    args,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeNamedArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeNamedArgList<'a> {
            ExtendedAttributeNamedArgList {
                lhs_identifier: ::core::clone::Clone::clone(&self.lhs_identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                rhs_identifier: ::core::clone::Clone::clone(&self.rhs_identifier),
                args: ::core::clone::Clone::clone(&self.args),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeNamedArgList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ExtendedAttributeNamedArgList",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs_identifier",
                &&self.rhs_identifier,
                "args",
                &&self.args,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeNamedArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeNamedArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeNamedArgList<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs_identifier == other.rhs_identifier && self.args == other.args
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        fn cmp(
            &self,
            other: &ExtendedAttributeNamedArgList<'a>,
        ) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.rhs_identifier,
                                &other.rhs_identifier,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.args, &other.args)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeNamedArgList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.rhs_identifier,
                                &other.rhs_identifier,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.args,
                                        &other.args,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeNamedArgList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs_identifier, state);
            ::core::hash::Hash::hash(&self.args, state)
        }
    }
    /// Parses an identifier list. Ex: `Exposed=((Window,Worker))`
    ///
    /// (( )) means ( ) chars
    pub struct ExtendedAttributeIdentList<'a> {
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        #[weedle(from = "Parenthesized<IdentifierListNonEmpty<'a>>", generic_into)]
        pub list: Parenthesized<IdentifierList<'a>>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeIdentList<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, list) = nom::combinator::map(
                nom::combinator::into(
                    <Parenthesized<
                        IdentifierListNonEmpty<'a>,
                    > as crate::Parse<'a>>::parse_tokens,
                ),
                |g| g.generic_into(),
            )(input)?;
            Ok((input, Self { identifier, assign, list }))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeIdentList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeIdentList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeIdentList<'a> {
            ExtendedAttributeIdentList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                list: ::core::clone::Clone::clone(&self.list),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeIdentList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeIdentList",
                "identifier",
                &&self.identifier,
                "assign",
                &&self.assign,
                "list",
                &&self.list,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeIdentList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeIdentList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<IdentifierList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeIdentList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeIdentList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeIdentList<'a>) -> bool {
            self.identifier == other.identifier && self.assign == other.assign
                && self.list == other.list
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeIdentList<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeIdentList<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeIdentList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeIdentList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeIdentList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.list, state)
        }
    }
    /// Parses an attribute with an identifier. Ex: `PutForwards=name`
    pub struct ExtendedAttributeIdent<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs: Identifier<'a>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeIdent<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, lhs_identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, rhs) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    lhs_identifier,
                    assign,
                    rhs,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeIdent<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeIdent<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeIdent<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeIdent<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeIdent<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeIdent",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs",
                &&self.rhs,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeIdent<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeIdent<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeIdent<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeIdent<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeIdent<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs == other.rhs
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeIdent<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeIdent<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeIdent<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeIdent<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeIdent<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs, state)
        }
    }
    /// Parses an attribute with a wildcard. Ex: `Exposed=*`
    pub struct ExtendedAttributeWildcard<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub wildcard: crate::term::Wildcard,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeWildcard<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, lhs_identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, wildcard) = <crate::term::Wildcard as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    lhs_identifier,
                    assign,
                    wildcard,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeWildcard<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeWildcard<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeWildcard<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeWildcard<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Wildcard>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeWildcard<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeWildcard",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "wildcard",
                &&self.wildcard,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeWildcard<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeWildcard<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Wildcard>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeWildcard<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeWildcard<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeWildcard<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.wildcard == other.wildcard
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeWildcard<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeWildcard<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.wildcard, &other.wildcard)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeWildcard<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeWildcard<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.wildcard,
                                &other.wildcard,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeWildcard<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.wildcard, state)
        }
    }
    /// Parses an attribute with a string. E: `ReflectOnly="on"`
    pub struct ExtendedAttributeString<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs: StringLit<'a>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeString<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, lhs_identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, rhs) = <StringLit<'a> as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    lhs_identifier,
                    assign,
                    rhs,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeString<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeString<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeString<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeString<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<StringLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeString<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeString",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs",
                &&self.rhs,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeString<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeString<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<StringLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeString<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeString<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeString<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs == other.rhs
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeString<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeString<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeString<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeString<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeString<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs, state)
        }
    }
    pub struct ExtendedAttributeStringList<'a> {
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub list: Parenthesized<StringList<'a>>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeStringList<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, list) = <Parenthesized<
                StringList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { identifier, assign, list }))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeStringList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeStringList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeStringList<'a> {
            ExtendedAttributeStringList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                list: ::core::clone::Clone::clone(&self.list),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeStringList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeStringList",
                "identifier",
                &&self.identifier,
                "assign",
                &&self.assign,
                "list",
                &&self.list,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeStringList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeStringList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<StringList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeStringList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeStringList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeStringList<'a>) -> bool {
            self.identifier == other.identifier && self.assign == other.assign
                && self.list == other.list
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeStringList<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeStringList<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeStringList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeStringList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeStringList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.list, state)
        }
    }
    pub struct ExtendedAttributeFloat<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs: FloatLit<'a>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeFloat<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, lhs_identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, rhs) = <FloatLit<'a> as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    lhs_identifier,
                    assign,
                    rhs,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeFloat<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeFloat<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeFloat<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeFloat<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<FloatLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeFloat<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeFloat",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs",
                &&self.rhs,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeFloat<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeFloat<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<FloatLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeFloat<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeFloat<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeFloat<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs == other.rhs
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeFloat<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeFloat<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeFloat<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeFloat<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeFloat<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs, state)
        }
    }
    pub struct ExtendedAttributeFloatList<'a> {
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub list: Parenthesized<FloatList<'a>>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeFloatList<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, list) = <Parenthesized<
                FloatList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { identifier, assign, list }))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeFloatList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeFloatList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeFloatList<'a> {
            ExtendedAttributeFloatList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                list: ::core::clone::Clone::clone(&self.list),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeFloatList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeFloatList",
                "identifier",
                &&self.identifier,
                "assign",
                &&self.assign,
                "list",
                &&self.list,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeFloatList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeFloatList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<FloatList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeFloatList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeFloatList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeFloatList<'a>) -> bool {
            self.identifier == other.identifier && self.assign == other.assign
                && self.list == other.list
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeFloatList<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeFloatList<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeFloatList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeFloatList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeFloatList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.list, state)
        }
    }
    pub struct ExtendedAttributeInteger<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs: IntegerLit<'a>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeInteger<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, lhs_identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, rhs) = <IntegerLit<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    lhs_identifier,
                    assign,
                    rhs,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeInteger<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeInteger<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeInteger<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeInteger<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<IntegerLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeInteger<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeInteger",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs",
                &&self.rhs,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeInteger<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeInteger<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<IntegerLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeInteger<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeInteger<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeInteger<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs == other.rhs
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeInteger<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeInteger<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeInteger<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeInteger<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeInteger<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs, state)
        }
    }
    pub struct ExtendedAttributeIntegerList<'a> {
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub list: Parenthesized<IntegerList<'a>>,
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeIntegerList<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, list) = <Parenthesized<
                IntegerList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { identifier, assign, list }))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeIntegerList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeIntegerList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeIntegerList<'a> {
            ExtendedAttributeIntegerList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                list: ::core::clone::Clone::clone(&self.list),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeIntegerList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeIntegerList",
                "identifier",
                &&self.identifier,
                "assign",
                &&self.assign,
                "list",
                &&self.list,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeIntegerList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeIntegerList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<IntegerList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeIntegerList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeIntegerList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeIntegerList<'a>) -> bool {
            self.identifier == other.identifier && self.assign == other.assign
                && self.list == other.list
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeIntegerList<'a> {
        #[inline]
        fn cmp(
            &self,
            other: &ExtendedAttributeIntegerList<'a>,
        ) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeIntegerList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeIntegerList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeIntegerList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.list, state)
        }
    }
    /// Parses a plain attribute. Ex: `Replaceable`
    pub struct ExtendedAttributeNoArgs<'a>(pub Identifier<'a>);
    impl<'a> crate::Parse<'a> for ExtendedAttributeNoArgs<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, (m0,)) = nom::sequence::tuple((
                <Identifier<'a> as crate::Parse<'a>>::parse_tokens,
            ))(input)?;
            Ok((input, Self(m0)))
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttributeNoArgs<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeNoArgs<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeNoArgs<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeNoArgs<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeNoArgs<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "ExtendedAttributeNoArgs",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeNoArgs<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeNoArgs<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeNoArgs<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeNoArgs<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeNoArgs<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeNoArgs<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeNoArgs<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeNoArgs<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeNoArgs<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeNoArgs<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    /// Parses on of the forms of attribute
    pub enum ExtendedAttribute<'a> {
        ArgList(ExtendedAttributeArgList<'a>),
        NamedArgList(ExtendedAttributeNamedArgList<'a>),
        IdentList(ExtendedAttributeIdentList<'a>),
        Ident(ExtendedAttributeIdent<'a>),
        Wildcard(ExtendedAttributeWildcard<'a>),
        String(ExtendedAttributeString<'a>),
        StringList(ExtendedAttributeStringList<'a>),
        Float(ExtendedAttributeFloat<'a>),
        FloatList(ExtendedAttributeFloatList<'a>),
        Integer(ExtendedAttributeInteger<'a>),
        IntegerList(ExtendedAttributeIntegerList<'a>),
        NoArgs(ExtendedAttributeNoArgs<'a>),
    }
    impl<'a> crate::Parse<'a> for ExtendedAttribute<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <ExtendedAttributeArgList<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::ArgList),
                <ExtendedAttributeNamedArgList<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::NamedArgList),
                nom::branch::alt((
                    <ExtendedAttributeIdentList<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::IdentList),
                    <ExtendedAttributeIdent<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Ident),
                    nom::branch::alt((
                        <ExtendedAttributeWildcard<'a> as crate::Parse<'a>>::parse_tokens
                            .map(Self::Wildcard),
                        <ExtendedAttributeString<'a> as crate::Parse<'a>>::parse_tokens
                            .map(Self::String),
                        nom::branch::alt((
                            <ExtendedAttributeStringList<
                                'a,
                            > as crate::Parse<'a>>::parse_tokens
                                .map(Self::StringList),
                            <ExtendedAttributeFloat<
                                'a,
                            > as crate::Parse<'a>>::parse_tokens
                                .map(Self::Float),
                            nom::branch::alt((
                                <ExtendedAttributeFloatList<
                                    'a,
                                > as crate::Parse<'a>>::parse_tokens
                                    .map(Self::FloatList),
                                <ExtendedAttributeInteger<
                                    'a,
                                > as crate::Parse<'a>>::parse_tokens
                                    .map(Self::Integer),
                                nom::branch::alt((
                                    <ExtendedAttributeIntegerList<
                                        'a,
                                    > as crate::Parse<'a>>::parse_tokens
                                        .map(Self::IntegerList),
                                    <ExtendedAttributeNoArgs<
                                        'a,
                                    > as crate::Parse<'a>>::parse_tokens
                                        .map(Self::NoArgs),
                                )),
                            )),
                        )),
                    )),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for ExtendedAttribute<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttribute<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttribute<'a> {
            match self {
                ExtendedAttribute::ArgList(__self_0) => {
                    ExtendedAttribute::ArgList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::NamedArgList(__self_0) => {
                    ExtendedAttribute::NamedArgList(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                ExtendedAttribute::IdentList(__self_0) => {
                    ExtendedAttribute::IdentList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::Ident(__self_0) => {
                    ExtendedAttribute::Ident(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::Wildcard(__self_0) => {
                    ExtendedAttribute::Wildcard(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::String(__self_0) => {
                    ExtendedAttribute::String(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::StringList(__self_0) => {
                    ExtendedAttribute::StringList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::Float(__self_0) => {
                    ExtendedAttribute::Float(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::FloatList(__self_0) => {
                    ExtendedAttribute::FloatList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::Integer(__self_0) => {
                    ExtendedAttribute::Integer(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::IntegerList(__self_0) => {
                    ExtendedAttribute::IntegerList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::NoArgs(__self_0) => {
                    ExtendedAttribute::NoArgs(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttribute<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ExtendedAttribute::ArgList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ArgList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::NamedArgList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NamedArgList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::IdentList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "IdentList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::Ident(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ident",
                        &__self_0,
                    )
                }
                ExtendedAttribute::Wildcard(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Wildcard",
                        &__self_0,
                    )
                }
                ExtendedAttribute::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                ExtendedAttribute::StringList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StringList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                ExtendedAttribute::FloatList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FloatList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                ExtendedAttribute::IntegerList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "IntegerList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::NoArgs(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NoArgs",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttribute<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttribute<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeArgList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeNamedArgList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeIdentList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeIdent<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeWildcard<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeString<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeStringList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeFloat<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeFloatList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeInteger<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeIntegerList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeNoArgs<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttribute<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttribute<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttribute<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        ExtendedAttribute::ArgList(__self_0),
                        ExtendedAttribute::ArgList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::NamedArgList(__self_0),
                        ExtendedAttribute::NamedArgList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::IdentList(__self_0),
                        ExtendedAttribute::IdentList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::Ident(__self_0),
                        ExtendedAttribute::Ident(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::Wildcard(__self_0),
                        ExtendedAttribute::Wildcard(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::String(__self_0),
                        ExtendedAttribute::String(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::StringList(__self_0),
                        ExtendedAttribute::StringList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::Float(__self_0),
                        ExtendedAttribute::Float(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::FloatList(__self_0),
                        ExtendedAttribute::FloatList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::Integer(__self_0),
                        ExtendedAttribute::Integer(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::IntegerList(__self_0),
                        ExtendedAttribute::IntegerList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::NoArgs(__self_0),
                        ExtendedAttribute::NoArgs(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttribute<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttribute<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            ExtendedAttribute::ArgList(__self_0),
                            ExtendedAttribute::ArgList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::NamedArgList(__self_0),
                            ExtendedAttribute::NamedArgList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::IdentList(__self_0),
                            ExtendedAttribute::IdentList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Ident(__self_0),
                            ExtendedAttribute::Ident(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Wildcard(__self_0),
                            ExtendedAttribute::Wildcard(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::String(__self_0),
                            ExtendedAttribute::String(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::StringList(__self_0),
                            ExtendedAttribute::StringList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Float(__self_0),
                            ExtendedAttribute::Float(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::FloatList(__self_0),
                            ExtendedAttribute::FloatList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Integer(__self_0),
                            ExtendedAttribute::Integer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::IntegerList(__self_0),
                            ExtendedAttribute::IntegerList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::NoArgs(__self_0),
                            ExtendedAttribute::NoArgs(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttribute<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttribute<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            ExtendedAttribute::ArgList(__self_0),
                            ExtendedAttribute::ArgList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::NamedArgList(__self_0),
                            ExtendedAttribute::NamedArgList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::IdentList(__self_0),
                            ExtendedAttribute::IdentList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Ident(__self_0),
                            ExtendedAttribute::Ident(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Wildcard(__self_0),
                            ExtendedAttribute::Wildcard(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::String(__self_0),
                            ExtendedAttribute::String(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::StringList(__self_0),
                            ExtendedAttribute::StringList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Float(__self_0),
                            ExtendedAttribute::Float(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::FloatList(__self_0),
                            ExtendedAttribute::FloatList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Integer(__self_0),
                            ExtendedAttribute::Integer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::IntegerList(__self_0),
                            ExtendedAttribute::IntegerList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::NoArgs(__self_0),
                            ExtendedAttribute::NoArgs(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttribute<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                ExtendedAttribute::ArgList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::NamedArgList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::IdentList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::Ident(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::Wildcard(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::String(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::StringList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::Float(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::FloatList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::Integer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::IntegerList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::NoArgs(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
}
pub mod common {
    use weedle_derive::Weedle;
    use crate::literal::DefaultValue;
    use crate::tokens::{contextful_cut, Tokens};
    use crate::{term, Parse, ParsePost, VerboseResult};
    pub(crate) fn is_alphanum_underscore_dash(token: char) -> bool {
        nom::AsChar::is_alphanum(token)
            || match token {
                '_' | '-' => true,
                _ => false,
            }
    }
    fn marker<'slice, 'a, S>(
        i: Tokens<'slice, 'a>,
    ) -> VerboseResult<Tokens<'slice, 'a>, S>
    where
        S: ::std::default::Default,
    {
        Ok((i, S::default()))
    }
    impl<'a, T: Parse<'a>> Parse<'a> for Option<T> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            nom::combinator::opt(<T as crate::Parse<'a>>::parse_tokens)(input)
        }
    }
    impl<'a, T> ParsePost<'a> for Option<T> {}
    impl<'a, T: Parse<'a>> Parse<'a> for Box<T> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            nom::combinator::map(<T as crate::Parse<'a>>::parse_tokens, Box::new)(input)
        }
    }
    impl<'a, T> ParsePost<'a> for Box<T> {}
    /// Parses `item1 item2 item3...`
    impl<'a, T: Parse<'a>> Parse<'a> for Vec<T> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            nom::multi::many0(T::parse_tokens)(input)
        }
    }
    impl<'a, T> ParsePost<'a> for Vec<T> {}
    impl<'a, T: Parse<'a>, U: Parse<'a>> Parse<'a> for (T, U) {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            nom::sequence::tuple((T::parse_tokens, U::parse_tokens))(input)
        }
    }
    impl<'a, T, U> ParsePost<'a> for (T, U) {}
    impl<'a, T: Parse<'a>, U: Parse<'a>, V: Parse<'a>> Parse<'a> for (T, U, V) {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            nom::sequence::tuple((
                T::parse_tokens,
                U::parse_tokens,
                V::parse_tokens,
            ))(input)
        }
    }
    impl<'a, T, U, V> ParsePost<'a> for (T, U, V) {}
    /// Parses `( body )`
    #[weedle(impl_bound = "where T: Parse<'a>")]
    pub struct Parenthesized<T> {
        pub open_paren: term::OpenParen,
        pub body: T,
        pub close_paren: term::CloseParen,
    }
    impl<'a, T> crate::Parse<'a> for Parenthesized<T>
    where
        T: Parse<'a>,
    {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, open_paren) = <term::OpenParen as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, body) = <T as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, close_paren) = <term::CloseParen as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    open_paren,
                    body,
                    close_paren,
                },
            ))
        }
    }
    impl<'a, T> crate::ParsePost<'a> for Parenthesized<T>
    where
        T: Parse<'a>,
    {}
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for Parenthesized<T> {}
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for Parenthesized<T> {
        #[inline]
        fn default() -> Parenthesized<T> {
            Parenthesized {
                open_paren: ::core::default::Default::default(),
                body: ::core::default::Default::default(),
                close_paren: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Parenthesized<T> {
        #[inline]
        fn clone(&self) -> Parenthesized<T> {
            Parenthesized {
                open_paren: ::core::clone::Clone::clone(&self.open_paren),
                body: ::core::clone::Clone::clone(&self.body),
                close_paren: ::core::clone::Clone::clone(&self.close_paren),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Parenthesized<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Parenthesized",
                "open_paren",
                &&self.open_paren,
                "body",
                &&self.body,
                "close_paren",
                &&self.close_paren,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for Parenthesized<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Parenthesized<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<term::OpenParen>;
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<term::CloseParen>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for Parenthesized<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Parenthesized<T> {
        #[inline]
        fn eq(&self, other: &Parenthesized<T>) -> bool {
            self.open_paren == other.open_paren && self.body == other.body
                && self.close_paren == other.close_paren
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Parenthesized<T> {
        #[inline]
        fn cmp(&self, other: &Parenthesized<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_paren, &other.open_paren) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.close_paren, &other.close_paren)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Parenthesized<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Parenthesized<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_paren,
                &other.open_paren,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.body, &other.body) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.close_paren,
                                &other.close_paren,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for Parenthesized<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_paren, state);
            ::core::hash::Hash::hash(&self.body, state);
            ::core::hash::Hash::hash(&self.close_paren, state)
        }
    }
    impl<T> Parenthesized<T> {
        fn generic_into<S: From<T>>(self) -> Parenthesized<S> {
            let Parenthesized { open_paren, body, close_paren } = self;
            Parenthesized {
                open_paren,
                body: body.into(),
                close_paren,
            }
        }
    }
    /// Parses `[ body ]`
    #[weedle(impl_bound = "where T: Parse<'a>", post_check)]
    pub struct Bracketed<T> {
        pub open_bracket: term::OpenBracket,
        pub body: T,
        pub close_bracket: term::CloseBracket,
    }
    impl<'a, T> crate::Parse<'a> for Bracketed<T>
    where
        T: Parse<'a>,
    {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, open_bracket) = <term::OpenBracket as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, body) = <T as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, close_bracket) = <term::CloseBracket as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    open_bracket,
                    body,
                    close_bracket,
                },
            ))
        }
    }
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for Bracketed<T> {}
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for Bracketed<T> {
        #[inline]
        fn default() -> Bracketed<T> {
            Bracketed {
                open_bracket: ::core::default::Default::default(),
                body: ::core::default::Default::default(),
                close_bracket: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Bracketed<T> {
        #[inline]
        fn clone(&self) -> Bracketed<T> {
            Bracketed {
                open_bracket: ::core::clone::Clone::clone(&self.open_bracket),
                body: ::core::clone::Clone::clone(&self.body),
                close_bracket: ::core::clone::Clone::clone(&self.close_bracket),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Bracketed<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Bracketed",
                "open_bracket",
                &&self.open_bracket,
                "body",
                &&self.body,
                "close_bracket",
                &&self.close_bracket,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for Bracketed<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Bracketed<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<term::OpenBracket>;
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<term::CloseBracket>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for Bracketed<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Bracketed<T> {
        #[inline]
        fn eq(&self, other: &Bracketed<T>) -> bool {
            self.open_bracket == other.open_bracket && self.body == other.body
                && self.close_bracket == other.close_bracket
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Bracketed<T> {
        #[inline]
        fn cmp(&self, other: &Bracketed<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_bracket, &other.open_bracket) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(
                                &self.close_bracket,
                                &other.close_bracket,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Bracketed<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bracketed<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_bracket,
                &other.open_bracket,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.body, &other.body) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.close_bracket,
                                &other.close_bracket,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for Bracketed<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_bracket, state);
            ::core::hash::Hash::hash(&self.body, state);
            ::core::hash::Hash::hash(&self.close_bracket, state)
        }
    }
    impl<'a, T> crate::ParsePost<'a> for Bracketed<T> {
        fn parse_post<'slice>(
            input: Tokens<'slice, 'a>,
        ) -> VerboseResult<Tokens<'slice, 'a>, ()> {
            contextful_cut(
                "Illegal double extended attribute lists, consider merging them",
                nom::combinator::not(
                    nom::combinator::peek(
                        crate::macros::annotate(|
                            input: crate::tokens::Tokens,
                        | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                            use nom::{InputIter, Slice};
                            use crate::lexer::Terminal;
                            use crate::term::Keyword;
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        value: Terminal::Keyword(Keyword::OpenBracket(variant)),
                                        trivia: _,
                                    },
                                ) => Ok((input.slice(1..), variant)),
                                _ => nom::combinator::fail(input),
                            }
                        }),
                    ),
                ),
            )(input)
        }
    }
    /// Parses `{ body }`
    #[weedle(impl_bound = "where T: Parse<'a>")]
    pub struct Braced<T> {
        pub open_brace: term::OpenBrace,
        pub body: T,
        pub close_brace: term::CloseBrace,
    }
    impl<'a, T> crate::Parse<'a> for Braced<T>
    where
        T: Parse<'a>,
    {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, open_brace) = <term::OpenBrace as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, body) = <T as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, close_brace) = <term::CloseBrace as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    open_brace,
                    body,
                    close_brace,
                },
            ))
        }
    }
    impl<'a, T> crate::ParsePost<'a> for Braced<T>
    where
        T: Parse<'a>,
    {}
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for Braced<T> {}
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for Braced<T> {
        #[inline]
        fn default() -> Braced<T> {
            Braced {
                open_brace: ::core::default::Default::default(),
                body: ::core::default::Default::default(),
                close_brace: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Braced<T> {
        #[inline]
        fn clone(&self) -> Braced<T> {
            Braced {
                open_brace: ::core::clone::Clone::clone(&self.open_brace),
                body: ::core::clone::Clone::clone(&self.body),
                close_brace: ::core::clone::Clone::clone(&self.close_brace),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Braced<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Braced",
                "open_brace",
                &&self.open_brace,
                "body",
                &&self.body,
                "close_brace",
                &&self.close_brace,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for Braced<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Braced<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<term::OpenBrace>;
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<term::CloseBrace>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for Braced<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Braced<T> {
        #[inline]
        fn eq(&self, other: &Braced<T>) -> bool {
            self.open_brace == other.open_brace && self.body == other.body
                && self.close_brace == other.close_brace
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Braced<T> {
        #[inline]
        fn cmp(&self, other: &Braced<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_brace, &other.open_brace) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.close_brace, &other.close_brace)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Braced<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Braced<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_brace,
                &other.open_brace,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.body, &other.body) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.close_brace,
                                &other.close_brace,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for Braced<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_brace, state);
            ::core::hash::Hash::hash(&self.body, state);
            ::core::hash::Hash::hash(&self.close_brace, state)
        }
    }
    /// Parses `< body >`
    #[weedle(impl_bound = "where T: Parse<'a>")]
    pub struct Generics<T> {
        pub open_angle: term::LessThan,
        pub body: T,
        pub close_angle: term::GreaterThan,
    }
    impl<'a, T> crate::Parse<'a> for Generics<T>
    where
        T: Parse<'a>,
    {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, open_angle) = <term::LessThan as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, body) = <T as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, close_angle) = <term::GreaterThan as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    open_angle,
                    body,
                    close_angle,
                },
            ))
        }
    }
    impl<'a, T> crate::ParsePost<'a> for Generics<T>
    where
        T: Parse<'a>,
    {}
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for Generics<T> {}
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for Generics<T> {
        #[inline]
        fn default() -> Generics<T> {
            Generics {
                open_angle: ::core::default::Default::default(),
                body: ::core::default::Default::default(),
                close_angle: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Generics<T> {
        #[inline]
        fn clone(&self) -> Generics<T> {
            Generics {
                open_angle: ::core::clone::Clone::clone(&self.open_angle),
                body: ::core::clone::Clone::clone(&self.body),
                close_angle: ::core::clone::Clone::clone(&self.close_angle),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Generics<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Generics",
                "open_angle",
                &&self.open_angle,
                "body",
                &&self.body,
                "close_angle",
                &&self.close_angle,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for Generics<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Generics<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<term::LessThan>;
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<term::GreaterThan>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for Generics<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Generics<T> {
        #[inline]
        fn eq(&self, other: &Generics<T>) -> bool {
            self.open_angle == other.open_angle && self.body == other.body
                && self.close_angle == other.close_angle
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Generics<T> {
        #[inline]
        fn cmp(&self, other: &Generics<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_angle, &other.open_angle) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.close_angle, &other.close_angle)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Generics<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Generics<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_angle,
                &other.open_angle,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.body, &other.body) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.close_angle,
                                &other.close_angle,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for Generics<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_angle, state);
            ::core::hash::Hash::hash(&self.body, state);
            ::core::hash::Hash::hash(&self.close_angle, state)
        }
    }
    /// Parses `(item1, item2, item3,...)?`
    pub struct Punctuated<T, S> {
        pub list: Vec<T>,
        pub separator: S,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone, S: ::core::clone::Clone> ::core::clone::Clone
    for Punctuated<T, S> {
        #[inline]
        fn clone(&self) -> Punctuated<T, S> {
            Punctuated {
                list: ::core::clone::Clone::clone(&self.list),
                separator: ::core::clone::Clone::clone(&self.separator),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug, S: ::core::fmt::Debug> ::core::fmt::Debug
    for Punctuated<T, S> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Punctuated",
                "list",
                &&self.list,
                "separator",
                &&self.separator,
            )
        }
    }
    #[automatically_derived]
    impl<T, S> ::core::marker::StructuralEq for Punctuated<T, S> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq, S: ::core::cmp::Eq> ::core::cmp::Eq for Punctuated<T, S> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Vec<T>>;
            let _: ::core::cmp::AssertParamIsEq<S>;
        }
    }
    #[automatically_derived]
    impl<T, S> ::core::marker::StructuralPartialEq for Punctuated<T, S> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq, S: ::core::cmp::PartialEq> ::core::cmp::PartialEq
    for Punctuated<T, S> {
        #[inline]
        fn eq(&self, other: &Punctuated<T, S>) -> bool {
            self.list == other.list && self.separator == other.separator
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord, S: ::core::cmp::Ord> ::core::cmp::Ord
    for Punctuated<T, S> {
        #[inline]
        fn cmp(&self, other: &Punctuated<T, S>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.list, &other.list) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.separator, &other.separator)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd, S: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd
    for Punctuated<T, S> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Punctuated<T, S>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.separator,
                        &other.separator,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash, S: ::core::hash::Hash> ::core::hash::Hash
    for Punctuated<T, S> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.list, state);
            ::core::hash::Hash::hash(&self.separator, state)
        }
    }
    impl<'a, T, S> Parse<'a> for Punctuated<T, S>
    where
        T: Parse<'a>,
        S: Parse<'a> + ::std::default::Default,
    {
        fn parse_body<'slice>(
            input: Tokens<'slice, 'a>,
        ) -> VerboseResult<Tokens<'slice, 'a>, Self> {
            let (input, (list, separator)) = nom::sequence::tuple((
                nom::multi::separated_list0(
                    <S as crate::Parse<'a>>::parse_tokens,
                    <T as crate::Parse<'a>>::parse_tokens,
                ),
                marker,
            ))(input)?;
            Ok((input, Self { list, separator }))
        }
    }
    impl<'a, T, S> ParsePost<'a> for Punctuated<T, S> {}
    /// Parses `item1, item2, item3, ...`
    pub struct PunctuatedNonEmpty<T, S> {
        pub list: Vec<T>,
        pub separator: S,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone, S: ::core::clone::Clone> ::core::clone::Clone
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        fn clone(&self) -> PunctuatedNonEmpty<T, S> {
            PunctuatedNonEmpty {
                list: ::core::clone::Clone::clone(&self.list),
                separator: ::core::clone::Clone::clone(&self.separator),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug, S: ::core::fmt::Debug> ::core::fmt::Debug
    for PunctuatedNonEmpty<T, S> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "PunctuatedNonEmpty",
                "list",
                &&self.list,
                "separator",
                &&self.separator,
            )
        }
    }
    #[automatically_derived]
    impl<T, S> ::core::marker::StructuralEq for PunctuatedNonEmpty<T, S> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq, S: ::core::cmp::Eq> ::core::cmp::Eq
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Vec<T>>;
            let _: ::core::cmp::AssertParamIsEq<S>;
        }
    }
    #[automatically_derived]
    impl<T, S> ::core::marker::StructuralPartialEq for PunctuatedNonEmpty<T, S> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq, S: ::core::cmp::PartialEq> ::core::cmp::PartialEq
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        fn eq(&self, other: &PunctuatedNonEmpty<T, S>) -> bool {
            self.list == other.list && self.separator == other.separator
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord, S: ::core::cmp::Ord> ::core::cmp::Ord
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        fn cmp(&self, other: &PunctuatedNonEmpty<T, S>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.list, &other.list) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.separator, &other.separator)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd, S: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &PunctuatedNonEmpty<T, S>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.separator,
                        &other.separator,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash, S: ::core::hash::Hash> ::core::hash::Hash
    for PunctuatedNonEmpty<T, S> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.list, state);
            ::core::hash::Hash::hash(&self.separator, state)
        }
    }
    impl<'a, T, S> Parse<'a> for PunctuatedNonEmpty<T, S>
    where
        T: Parse<'a>,
        S: Parse<'a> + ::std::default::Default,
    {
        fn parse_body<'slice>(
            input: Tokens<'slice, 'a>,
        ) -> VerboseResult<Tokens<'slice, 'a>, Self> {
            let (input, (list, separator)) = nom::sequence::tuple((
                nom::sequence::terminated(
                    nom::multi::separated_list1(
                        <S as crate::Parse<'a>>::parse_tokens,
                        <T as crate::Parse<'a>>::parse_tokens,
                    ),
                    nom::combinator::opt(<S as crate::Parse<'a>>::parse_tokens),
                ),
                marker,
            ))(input)?;
            Ok((input, Self { list, separator }))
        }
    }
    impl<'a, T, S> ParsePost<'a> for PunctuatedNonEmpty<T, S> {}
    impl<T, S> From<PunctuatedNonEmpty<T, S>> for Punctuated<T, S> {
        fn from(value: PunctuatedNonEmpty<T, S>) -> Self {
            Self {
                list: value.list,
                separator: value.separator,
            }
        }
    }
    /// Represents an identifier
    ///
    /// Follows `/[_-]?[A-Za-z][0-9A-Z_a-z-]*/`
    pub struct Identifier<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Identifier<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Identifier<'a> {
        #[inline]
        fn clone(&self) -> Identifier<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Identifier<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Identifier", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Identifier<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Identifier<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Identifier<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Identifier<'a> {
        #[inline]
        fn eq(&self, other: &Identifier<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Identifier<'a> {
        #[inline]
        fn cmp(&self, other: &Identifier<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Identifier<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Identifier<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Identifier<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> Identifier<'a> {
        pub fn lex(input: &'a str) -> crate::VerboseResult<&'a str, Self> {
            nom::combinator::map(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(
                            nom::branch::alt((
                                nom::character::complete::char('_'),
                                nom::character::complete::char('-'),
                            )),
                        ),
                        nom::bytes::complete::take_while1(nom::AsChar::is_alpha),
                        nom::bytes::complete::take_while(is_alphanum_underscore_dash),
                    )),
                ),
                Identifier,
            )(input)
        }
    }
    impl<'a> Parse<'a> for Identifier<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: crate::lexer::Terminal::Identifier(variant),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> ParsePost<'a> for Identifier<'a> {}
    /// Parses rhs of an assignment expression. Ex: `= 45`
    pub struct Default<'a> {
        pub assign: crate::term::Assign,
        pub value: DefaultValue<'a>,
    }
    impl<'a> crate::Parse<'a> for Default<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, value) = <DefaultValue<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { assign, value }))
        }
    }
    impl<'a> crate::ParsePost<'a> for Default<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Default<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Default<'a> {
        #[inline]
        fn clone(&self) -> Default<'a> {
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<DefaultValue<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Default<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Default",
                "assign",
                &&self.assign,
                "value",
                &&self.value,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Default<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Default<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<DefaultValue<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Default<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Default<'a> {
        #[inline]
        fn eq(&self, other: &Default<'a>) -> bool {
            self.assign == other.assign && self.value == other.value
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Default<'a> {
        #[inline]
        fn cmp(&self, other: &Default<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.value, &other.value)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Default<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Default<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.assign, &other.assign) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.value, &other.value)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Default<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.value, state)
        }
    }
}
pub mod dictionary {
    use weedle_derive::Weedle;
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Default, Identifier};
    use crate::types::Type;
    /// Parses dictionary members
    pub type DictionaryMembers<'a> = Vec<DictionaryMember<'a>>;
    /// Parses dictionary member `[attributes]? required? type identifier ( = default )?;`
    pub struct DictionaryMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub required: Option<crate::term::Required>,
        pub type_: Type<'a>,
        pub identifier: Identifier<'a>,
        #[weedle(cond = "required.is_none()")]
        pub default: Option<Default<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for DictionaryMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, required) = <Option<
                crate::term::Required,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, type_) = <Type<'a> as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, default) = nom::combinator::map(
                nom::combinator::cond(
                    required.is_none(),
                    <Option<Default<'a>> as crate::Parse<'a>>::parse_tokens,
                ),
                |opt| opt.flatten(),
            )(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    required,
                    type_,
                    identifier,
                    default,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for DictionaryMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DictionaryMember<'a> {
        #[inline]
        fn clone(&self) -> DictionaryMember<'a> {
            DictionaryMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                required: ::core::clone::Clone::clone(&self.required),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                default: ::core::clone::Clone::clone(&self.default),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DictionaryMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "required",
                "type_",
                "identifier",
                "default",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.required,
                &&self.type_,
                &&self.identifier,
                &&self.default,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "DictionaryMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DictionaryMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DictionaryMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Required>>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Default<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DictionaryMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DictionaryMember<'a> {
        #[inline]
        fn eq(&self, other: &DictionaryMember<'a>) -> bool {
            self.attributes == other.attributes && self.required == other.required
                && self.type_ == other.type_ && self.identifier == other.identifier
                && self.default == other.default && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DictionaryMember<'a> {
        #[inline]
        fn cmp(&self, other: &DictionaryMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.required, &other.required) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.default, &other.default) {
                                                ::core::cmp::Ordering::Equal => {
                                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DictionaryMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DictionaryMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.required,
                        &other.required,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.type_,
                                &other.type_,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.default,
                                                &other.default,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.semi_colon,
                                                        &other.semi_colon,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DictionaryMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.required, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.default, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
}
pub mod interface {
    use weedle_derive::Weedle;
    use crate::argument::ArgumentList;
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Generics, Identifier, Parenthesized};
    use crate::members::{
        AttributeInterfaceMember, ConstMember, OperationInterfaceMember,
        RegularOperationMember,
    };
    use crate::types::AttributedType;
    /// Parses interface members
    pub type InterfaceMembers<'a> = Vec<InterfaceMember<'a>>;
    pub type CallbackInterfaceMembers<'a> = Vec<CallbackInterfaceMember<'a>>;
    /// Parses inheritance clause `: identifier`
    pub struct Inheritance<'a> {
        pub colon: crate::term::Colon,
        pub identifier: Identifier<'a>,
    }
    impl<'a> crate::Parse<'a> for Inheritance<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, colon) = <crate::term::Colon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { colon, identifier }))
        }
    }
    impl<'a> crate::ParsePost<'a> for Inheritance<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Inheritance<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Inheritance<'a> {
        #[inline]
        fn clone(&self) -> Inheritance<'a> {
            let _: ::core::clone::AssertParamIsClone<crate::term::Colon>;
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Inheritance<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Inheritance",
                "colon",
                &&self.colon,
                "identifier",
                &&self.identifier,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Inheritance<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Inheritance<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Colon>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Inheritance<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Inheritance<'a> {
        #[inline]
        fn eq(&self, other: &Inheritance<'a>) -> bool {
            self.colon == other.colon && self.identifier == other.identifier
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Inheritance<'a> {
        #[inline]
        fn cmp(&self, other: &Inheritance<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.colon, &other.colon) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.identifier, &other.identifier)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Inheritance<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Inheritance<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.colon, &other.colon) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.identifier,
                        &other.identifier,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Inheritance<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.colon, state);
            ::core::hash::Hash::hash(&self.identifier, state)
        }
    }
    /// Parses `[attributes]? constructor(( args ));`
    ///
    /// (( )) means ( ) chars
    pub struct ConstructorInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub constructor: crate::term::Constructor,
        pub args: Parenthesized<ArgumentList<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for ConstructorInterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, constructor) = <crate::term::Constructor as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, args) = <Parenthesized<
                ArgumentList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    constructor,
                    args,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for ConstructorInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstructorInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> ConstructorInterfaceMember<'a> {
            ConstructorInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                constructor: ::core::clone::Clone::clone(&self.constructor),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstructorInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ConstructorInterfaceMember",
                "attributes",
                &&self.attributes,
                "constructor",
                &&self.constructor,
                "args",
                &&self.args,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstructorInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstructorInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Constructor>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstructorInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstructorInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &ConstructorInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.constructor == other.constructor
                && self.args == other.args && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstructorInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &ConstructorInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.constructor, &other.constructor) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstructorInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstructorInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.constructor,
                        &other.constructor,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.args,
                                &other.args,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.semi_colon,
                                        &other.semi_colon,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstructorInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.constructor, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses an iterable declaration `[attributes]? iterable<attributedtype>;`
    pub struct SingleTypedIterable<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub iterable: crate::term::Iterable,
        pub generics: Generics<AttributedType<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for SingleTypedIterable<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, iterable) = <crate::term::Iterable as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                AttributedType<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    iterable,
                    generics,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for SingleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SingleTypedIterable<'a> {
        #[inline]
        fn clone(&self) -> SingleTypedIterable<'a> {
            SingleTypedIterable {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                iterable: ::core::clone::Clone::clone(&self.iterable),
                generics: ::core::clone::Clone::clone(&self.generics),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SingleTypedIterable<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "SingleTypedIterable",
                "attributes",
                &&self.attributes,
                "iterable",
                &&self.iterable,
                "generics",
                &&self.generics,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SingleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SingleTypedIterable<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Iterable>;
            let _: ::core::cmp::AssertParamIsEq<Generics<AttributedType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SingleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SingleTypedIterable<'a> {
        #[inline]
        fn eq(&self, other: &SingleTypedIterable<'a>) -> bool {
            self.attributes == other.attributes && self.iterable == other.iterable
                && self.generics == other.generics && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SingleTypedIterable<'a> {
        #[inline]
        fn cmp(&self, other: &SingleTypedIterable<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.iterable, &other.iterable) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SingleTypedIterable<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SingleTypedIterable<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.iterable,
                        &other.iterable,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.semi_colon,
                                        &other.semi_colon,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SingleTypedIterable<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.iterable, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses an iterable declaration `[attributes]? iterable<attributedtype, attributedtype>;`
    pub struct DoubleTypedIterable<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub iterable: crate::term::Iterable,
        pub generics: Generics<
            (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
        >,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for DoubleTypedIterable<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, iterable) = <crate::term::Iterable as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    iterable,
                    generics,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for DoubleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DoubleTypedIterable<'a> {
        #[inline]
        fn clone(&self) -> DoubleTypedIterable<'a> {
            DoubleTypedIterable {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                iterable: ::core::clone::Clone::clone(&self.iterable),
                generics: ::core::clone::Clone::clone(&self.generics),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DoubleTypedIterable<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "DoubleTypedIterable",
                "attributes",
                &&self.attributes,
                "iterable",
                &&self.iterable,
                "generics",
                &&self.generics,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DoubleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DoubleTypedIterable<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Iterable>;
            let _: ::core::cmp::AssertParamIsEq<
                Generics<(AttributedType<'a>, crate::term::Comma, AttributedType<'a>)>,
            >;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DoubleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DoubleTypedIterable<'a> {
        #[inline]
        fn eq(&self, other: &DoubleTypedIterable<'a>) -> bool {
            self.attributes == other.attributes && self.iterable == other.iterable
                && self.generics == other.generics && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DoubleTypedIterable<'a> {
        #[inline]
        fn cmp(&self, other: &DoubleTypedIterable<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.iterable, &other.iterable) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DoubleTypedIterable<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DoubleTypedIterable<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.iterable,
                        &other.iterable,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.semi_colon,
                                        &other.semi_colon,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DoubleTypedIterable<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.iterable, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses an iterable declaration `[attributes]? (iterable<attributedtype> | iterable<attributedtype, attributedtype>) ;`
    pub enum IterableInterfaceMember<'a> {
        Single(SingleTypedIterable<'a>),
        Double(DoubleTypedIterable<'a>),
    }
    impl<'a> crate::Parse<'a> for IterableInterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <SingleTypedIterable<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Single),
                <DoubleTypedIterable<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Double),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for IterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for IterableInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> IterableInterfaceMember<'a> {
            match self {
                IterableInterfaceMember::Single(__self_0) => {
                    IterableInterfaceMember::Single(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                IterableInterfaceMember::Double(__self_0) => {
                    IterableInterfaceMember::Double(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for IterableInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                IterableInterfaceMember::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                IterableInterfaceMember::Double(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Double",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for IterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for IterableInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<SingleTypedIterable<'a>>;
            let _: ::core::cmp::AssertParamIsEq<DoubleTypedIterable<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for IterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for IterableInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &IterableInterfaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        IterableInterfaceMember::Single(__self_0),
                        IterableInterfaceMember::Single(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        IterableInterfaceMember::Double(__self_0),
                        IterableInterfaceMember::Double(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for IterableInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &IterableInterfaceMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            IterableInterfaceMember::Single(__self_0),
                            IterableInterfaceMember::Single(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            IterableInterfaceMember::Double(__self_0),
                            IterableInterfaceMember::Double(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for IterableInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &IterableInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            IterableInterfaceMember::Single(__self_0),
                            IterableInterfaceMember::Single(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            IterableInterfaceMember::Double(__self_0),
                            IterableInterfaceMember::Double(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for IterableInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                IterableInterfaceMember::Single(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                IterableInterfaceMember::Double(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses an async iterable declaration `[attributes]? async iterable<attributedtype> (( args ))? ;`
    pub struct SingleTypedAsyncIterable<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub async_iterable: (crate::term::Async, crate::term::Iterable),
        pub generics: Generics<AttributedType<'a>>,
        pub args: Option<Parenthesized<ArgumentList<'a>>>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for SingleTypedAsyncIterable<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, async_iterable) = <(
                crate::term::Async,
                crate::term::Iterable,
            ) as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                AttributedType<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, args) = <Option<
                Parenthesized<ArgumentList<'a>>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    async_iterable,
                    generics,
                    args,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for SingleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SingleTypedAsyncIterable<'a> {
        #[inline]
        fn clone(&self) -> SingleTypedAsyncIterable<'a> {
            SingleTypedAsyncIterable {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                async_iterable: ::core::clone::Clone::clone(&self.async_iterable),
                generics: ::core::clone::Clone::clone(&self.generics),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SingleTypedAsyncIterable<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SingleTypedAsyncIterable",
                "attributes",
                &&self.attributes,
                "async_iterable",
                &&self.async_iterable,
                "generics",
                &&self.generics,
                "args",
                &&self.args,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SingleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SingleTypedAsyncIterable<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<
                (crate::term::Async, crate::term::Iterable),
            >;
            let _: ::core::cmp::AssertParamIsEq<Generics<AttributedType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Parenthesized<ArgumentList<'a>>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SingleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SingleTypedAsyncIterable<'a> {
        #[inline]
        fn eq(&self, other: &SingleTypedAsyncIterable<'a>) -> bool {
            self.attributes == other.attributes
                && self.async_iterable == other.async_iterable
                && self.generics == other.generics && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SingleTypedAsyncIterable<'a> {
        #[inline]
        fn cmp(&self, other: &SingleTypedAsyncIterable<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(
                        &self.async_iterable,
                        &other.async_iterable,
                    ) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SingleTypedAsyncIterable<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SingleTypedAsyncIterable<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.async_iterable,
                        &other.async_iterable,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.args,
                                        &other.args,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SingleTypedAsyncIterable<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.async_iterable, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses an async iterable declaration `[attributes]? async iterable<attributedtype, attributedtype> (( args ))? ;`
    pub struct DoubleTypedAsyncIterable<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub async_iterable: (crate::term::Async, crate::term::Iterable),
        pub generics: Generics<
            (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
        >,
        pub args: Option<Parenthesized<ArgumentList<'a>>>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for DoubleTypedAsyncIterable<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, async_iterable) = <(
                crate::term::Async,
                crate::term::Iterable,
            ) as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, args) = <Option<
                Parenthesized<ArgumentList<'a>>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    async_iterable,
                    generics,
                    args,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for DoubleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DoubleTypedAsyncIterable<'a> {
        #[inline]
        fn clone(&self) -> DoubleTypedAsyncIterable<'a> {
            DoubleTypedAsyncIterable {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                async_iterable: ::core::clone::Clone::clone(&self.async_iterable),
                generics: ::core::clone::Clone::clone(&self.generics),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DoubleTypedAsyncIterable<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "DoubleTypedAsyncIterable",
                "attributes",
                &&self.attributes,
                "async_iterable",
                &&self.async_iterable,
                "generics",
                &&self.generics,
                "args",
                &&self.args,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DoubleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DoubleTypedAsyncIterable<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<
                (crate::term::Async, crate::term::Iterable),
            >;
            let _: ::core::cmp::AssertParamIsEq<
                Generics<(AttributedType<'a>, crate::term::Comma, AttributedType<'a>)>,
            >;
            let _: ::core::cmp::AssertParamIsEq<Option<Parenthesized<ArgumentList<'a>>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DoubleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DoubleTypedAsyncIterable<'a> {
        #[inline]
        fn eq(&self, other: &DoubleTypedAsyncIterable<'a>) -> bool {
            self.attributes == other.attributes
                && self.async_iterable == other.async_iterable
                && self.generics == other.generics && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DoubleTypedAsyncIterable<'a> {
        #[inline]
        fn cmp(&self, other: &DoubleTypedAsyncIterable<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(
                        &self.async_iterable,
                        &other.async_iterable,
                    ) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DoubleTypedAsyncIterable<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DoubleTypedAsyncIterable<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.async_iterable,
                        &other.async_iterable,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.args,
                                        &other.args,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DoubleTypedAsyncIterable<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.async_iterable, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses an async iterable declaration `[attributes]? async (iterable<attributedtype> | iterable<attributedtype, attributedtype>) (( args ))? ;`
    pub enum AsyncIterableInterfaceMember<'a> {
        Single(SingleTypedAsyncIterable<'a>),
        Double(DoubleTypedAsyncIterable<'a>),
    }
    impl<'a> crate::Parse<'a> for AsyncIterableInterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <SingleTypedAsyncIterable<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Single),
                <DoubleTypedAsyncIterable<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Double),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for AsyncIterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AsyncIterableInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> AsyncIterableInterfaceMember<'a> {
            match self {
                AsyncIterableInterfaceMember::Single(__self_0) => {
                    AsyncIterableInterfaceMember::Single(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                AsyncIterableInterfaceMember::Double(__self_0) => {
                    AsyncIterableInterfaceMember::Double(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AsyncIterableInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                AsyncIterableInterfaceMember::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                AsyncIterableInterfaceMember::Double(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Double",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AsyncIterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AsyncIterableInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<SingleTypedAsyncIterable<'a>>;
            let _: ::core::cmp::AssertParamIsEq<DoubleTypedAsyncIterable<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AsyncIterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AsyncIterableInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &AsyncIterableInterfaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        AsyncIterableInterfaceMember::Single(__self_0),
                        AsyncIterableInterfaceMember::Single(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        AsyncIterableInterfaceMember::Double(__self_0),
                        AsyncIterableInterfaceMember::Double(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AsyncIterableInterfaceMember<'a> {
        #[inline]
        fn cmp(
            &self,
            other: &AsyncIterableInterfaceMember<'a>,
        ) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            AsyncIterableInterfaceMember::Single(__self_0),
                            AsyncIterableInterfaceMember::Single(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            AsyncIterableInterfaceMember::Double(__self_0),
                            AsyncIterableInterfaceMember::Double(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AsyncIterableInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AsyncIterableInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            AsyncIterableInterfaceMember::Single(__self_0),
                            AsyncIterableInterfaceMember::Single(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            AsyncIterableInterfaceMember::Double(__self_0),
                            AsyncIterableInterfaceMember::Double(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AsyncIterableInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                AsyncIterableInterfaceMember::Single(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                AsyncIterableInterfaceMember::Double(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses an maplike declaration `[attributes]? readonly? maplike<attributedtype, attributedtype>;`
    pub struct MaplikeInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub readonly: Option<crate::term::ReadOnly>,
        pub maplike: crate::term::Maplike,
        pub generics: Generics<
            (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
        >,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for MaplikeInterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, readonly) = <Option<
                crate::term::ReadOnly,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, maplike) = <crate::term::Maplike as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    readonly,
                    maplike,
                    generics,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for MaplikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for MaplikeInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> MaplikeInterfaceMember<'a> {
            MaplikeInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                maplike: ::core::clone::Clone::clone(&self.maplike),
                generics: ::core::clone::Clone::clone(&self.generics),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for MaplikeInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "MaplikeInterfaceMember",
                "attributes",
                &&self.attributes,
                "readonly",
                &&self.readonly,
                "maplike",
                &&self.maplike,
                "generics",
                &&self.generics,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for MaplikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for MaplikeInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::ReadOnly>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Maplike>;
            let _: ::core::cmp::AssertParamIsEq<
                Generics<(AttributedType<'a>, crate::term::Comma, AttributedType<'a>)>,
            >;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for MaplikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for MaplikeInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &MaplikeInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.readonly == other.readonly
                && self.maplike == other.maplike && self.generics == other.generics
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for MaplikeInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &MaplikeInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.readonly, &other.readonly) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.maplike, &other.maplike) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.generics,
                                        &other.generics,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for MaplikeInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MaplikeInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.readonly,
                        &other.readonly,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.maplike,
                                &other.maplike,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.generics,
                                        &other.generics,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for MaplikeInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.maplike, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    pub struct SetlikeInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub readonly: Option<crate::term::ReadOnly>,
        pub setlike: crate::term::Setlike,
        pub generics: Generics<AttributedType<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for SetlikeInterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, readonly) = <Option<
                crate::term::ReadOnly,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, setlike) = <crate::term::Setlike as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                AttributedType<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    readonly,
                    setlike,
                    generics,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for SetlikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SetlikeInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> SetlikeInterfaceMember<'a> {
            SetlikeInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                setlike: ::core::clone::Clone::clone(&self.setlike),
                generics: ::core::clone::Clone::clone(&self.generics),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SetlikeInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SetlikeInterfaceMember",
                "attributes",
                &&self.attributes,
                "readonly",
                &&self.readonly,
                "setlike",
                &&self.setlike,
                "generics",
                &&self.generics,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SetlikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SetlikeInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::ReadOnly>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Setlike>;
            let _: ::core::cmp::AssertParamIsEq<Generics<AttributedType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SetlikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SetlikeInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &SetlikeInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.readonly == other.readonly
                && self.setlike == other.setlike && self.generics == other.generics
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SetlikeInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &SetlikeInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.readonly, &other.readonly) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.setlike, &other.setlike) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.generics,
                                        &other.generics,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SetlikeInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SetlikeInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.readonly,
                        &other.readonly,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.setlike,
                                &other.setlike,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.generics,
                                        &other.generics,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SetlikeInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.setlike, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses `stringifier;`
    pub struct StringifierMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub stringifier: crate::term::Stringifier,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for StringifierMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, stringifier) = <crate::term::Stringifier as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    stringifier,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for StringifierMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::default::Default for StringifierMember<'a> {
        #[inline]
        fn default() -> StringifierMember<'a> {
            StringifierMember {
                attributes: ::core::default::Default::default(),
                stringifier: ::core::default::Default::default(),
                semi_colon: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for StringifierMember<'a> {
        #[inline]
        fn clone(&self) -> StringifierMember<'a> {
            StringifierMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                stringifier: ::core::clone::Clone::clone(&self.stringifier),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for StringifierMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StringifierMember",
                "attributes",
                &&self.attributes,
                "stringifier",
                &&self.stringifier,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for StringifierMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for StringifierMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Stringifier>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for StringifierMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for StringifierMember<'a> {
        #[inline]
        fn eq(&self, other: &StringifierMember<'a>) -> bool {
            self.attributes == other.attributes && self.stringifier == other.stringifier
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for StringifierMember<'a> {
        #[inline]
        fn cmp(&self, other: &StringifierMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.stringifier, &other.stringifier) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for StringifierMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StringifierMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.stringifier,
                        &other.stringifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.semi_colon,
                                &other.semi_colon,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for StringifierMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.stringifier, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses one of the interface member variants
    pub enum InterfaceMember<'a> {
        Const(ConstMember<'a>),
        Attribute(AttributeInterfaceMember<'a>),
        Constructor(ConstructorInterfaceMember<'a>),
        Operation(OperationInterfaceMember<'a>),
        Iterable(IterableInterfaceMember<'a>),
        AsyncIterable(AsyncIterableInterfaceMember<'a>),
        Maplike(MaplikeInterfaceMember<'a>),
        Setlike(SetlikeInterfaceMember<'a>),
        Stringifier(StringifierMember<'a>),
    }
    impl<'a> crate::Parse<'a> for InterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <ConstMember<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Const),
                <AttributeInterfaceMember<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Attribute),
                nom::branch::alt((
                    <ConstructorInterfaceMember<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Constructor),
                    <OperationInterfaceMember<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Operation),
                    nom::branch::alt((
                        <IterableInterfaceMember<'a> as crate::Parse<'a>>::parse_tokens
                            .map(Self::Iterable),
                        <AsyncIterableInterfaceMember<
                            'a,
                        > as crate::Parse<'a>>::parse_tokens
                            .map(Self::AsyncIterable),
                        nom::branch::alt((
                            <MaplikeInterfaceMember<
                                'a,
                            > as crate::Parse<'a>>::parse_tokens
                                .map(Self::Maplike),
                            <SetlikeInterfaceMember<
                                'a,
                            > as crate::Parse<'a>>::parse_tokens
                                .map(Self::Setlike),
                            <StringifierMember<'a> as crate::Parse<'a>>::parse_tokens
                                .map(Self::Stringifier),
                        )),
                    )),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for InterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for InterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> InterfaceMember<'a> {
            match self {
                InterfaceMember::Const(__self_0) => {
                    InterfaceMember::Const(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Attribute(__self_0) => {
                    InterfaceMember::Attribute(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Constructor(__self_0) => {
                    InterfaceMember::Constructor(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Operation(__self_0) => {
                    InterfaceMember::Operation(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Iterable(__self_0) => {
                    InterfaceMember::Iterable(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::AsyncIterable(__self_0) => {
                    InterfaceMember::AsyncIterable(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Maplike(__self_0) => {
                    InterfaceMember::Maplike(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Setlike(__self_0) => {
                    InterfaceMember::Setlike(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Stringifier(__self_0) => {
                    InterfaceMember::Stringifier(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for InterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                InterfaceMember::Const(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Const",
                        &__self_0,
                    )
                }
                InterfaceMember::Attribute(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Attribute",
                        &__self_0,
                    )
                }
                InterfaceMember::Constructor(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Constructor",
                        &__self_0,
                    )
                }
                InterfaceMember::Operation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Operation",
                        &__self_0,
                    )
                }
                InterfaceMember::Iterable(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Iterable",
                        &__self_0,
                    )
                }
                InterfaceMember::AsyncIterable(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AsyncIterable",
                        &__self_0,
                    )
                }
                InterfaceMember::Maplike(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Maplike",
                        &__self_0,
                    )
                }
                InterfaceMember::Setlike(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Setlike",
                        &__self_0,
                    )
                }
                InterfaceMember::Stringifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stringifier",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for InterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for InterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<AttributeInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ConstructorInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<OperationInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<IterableInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<AsyncIterableInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<MaplikeInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<SetlikeInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<StringifierMember<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for InterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for InterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &InterfaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        InterfaceMember::Const(__self_0),
                        InterfaceMember::Const(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Attribute(__self_0),
                        InterfaceMember::Attribute(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Constructor(__self_0),
                        InterfaceMember::Constructor(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Operation(__self_0),
                        InterfaceMember::Operation(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Iterable(__self_0),
                        InterfaceMember::Iterable(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::AsyncIterable(__self_0),
                        InterfaceMember::AsyncIterable(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Maplike(__self_0),
                        InterfaceMember::Maplike(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Setlike(__self_0),
                        InterfaceMember::Setlike(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Stringifier(__self_0),
                        InterfaceMember::Stringifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for InterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &InterfaceMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            InterfaceMember::Const(__self_0),
                            InterfaceMember::Const(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Attribute(__self_0),
                            InterfaceMember::Attribute(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Constructor(__self_0),
                            InterfaceMember::Constructor(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Operation(__self_0),
                            InterfaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Iterable(__self_0),
                            InterfaceMember::Iterable(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::AsyncIterable(__self_0),
                            InterfaceMember::AsyncIterable(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Maplike(__self_0),
                            InterfaceMember::Maplike(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Setlike(__self_0),
                            InterfaceMember::Setlike(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Stringifier(__self_0),
                            InterfaceMember::Stringifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for InterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &InterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            InterfaceMember::Const(__self_0),
                            InterfaceMember::Const(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Attribute(__self_0),
                            InterfaceMember::Attribute(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Constructor(__self_0),
                            InterfaceMember::Constructor(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Operation(__self_0),
                            InterfaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Iterable(__self_0),
                            InterfaceMember::Iterable(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::AsyncIterable(__self_0),
                            InterfaceMember::AsyncIterable(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Maplike(__self_0),
                            InterfaceMember::Maplike(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Setlike(__self_0),
                            InterfaceMember::Setlike(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Stringifier(__self_0),
                            InterfaceMember::Stringifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for InterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                InterfaceMember::Const(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Attribute(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Constructor(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Operation(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Iterable(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::AsyncIterable(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Maplike(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Setlike(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Stringifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses one of the interface member variants
    pub enum CallbackInterfaceMember<'a> {
        Const(ConstMember<'a>),
        Operation(RegularOperationMember<'a>),
    }
    impl<'a> crate::Parse<'a> for CallbackInterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <ConstMember<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Const),
                <RegularOperationMember<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Operation),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for CallbackInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for CallbackInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> CallbackInterfaceMember<'a> {
            match self {
                CallbackInterfaceMember::Const(__self_0) => {
                    CallbackInterfaceMember::Const(::core::clone::Clone::clone(__self_0))
                }
                CallbackInterfaceMember::Operation(__self_0) => {
                    CallbackInterfaceMember::Operation(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for CallbackInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                CallbackInterfaceMember::Const(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Const",
                        &__self_0,
                    )
                }
                CallbackInterfaceMember::Operation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Operation",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for CallbackInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for CallbackInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<RegularOperationMember<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for CallbackInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for CallbackInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &CallbackInterfaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        CallbackInterfaceMember::Const(__self_0),
                        CallbackInterfaceMember::Const(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        CallbackInterfaceMember::Operation(__self_0),
                        CallbackInterfaceMember::Operation(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for CallbackInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &CallbackInterfaceMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            CallbackInterfaceMember::Const(__self_0),
                            CallbackInterfaceMember::Const(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            CallbackInterfaceMember::Operation(__self_0),
                            CallbackInterfaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for CallbackInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &CallbackInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            CallbackInterfaceMember::Const(__self_0),
                            CallbackInterfaceMember::Const(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            CallbackInterfaceMember::Operation(__self_0),
                            CallbackInterfaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for CallbackInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                CallbackInterfaceMember::Const(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                CallbackInterfaceMember::Operation(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
}
pub mod literal {
    use nom::Parser;
    use weedle_derive::Weedle;
    use crate::{Parse, ParsePost};
    /// Parses `-?[1-9][0-9]*`
    pub struct DecLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for DecLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DecLit<'a> {
        #[inline]
        fn clone(&self) -> DecLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DecLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "DecLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DecLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DecLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DecLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DecLit<'a> {
        #[inline]
        fn eq(&self, other: &DecLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DecLit<'a> {
        #[inline]
        fn cmp(&self, other: &DecLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DecLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DecLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DecLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> DecLit<'a> {
        pub fn lex(input: &'a str) -> crate::VerboseResult<&'a str, Self> {
            nom::combinator::map(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(nom::character::complete::char('-')),
                        nom::character::complete::one_of("123456789"),
                        nom::bytes::complete::take_while(nom::AsChar::is_dec_digit),
                    )),
                ),
                DecLit,
            )(input)
        }
    }
    /// Parses `-?0[Xx][0-9A-Fa-f]+)`
    pub struct HexLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for HexLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for HexLit<'a> {
        #[inline]
        fn clone(&self) -> HexLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for HexLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "HexLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for HexLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for HexLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for HexLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for HexLit<'a> {
        #[inline]
        fn eq(&self, other: &HexLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for HexLit<'a> {
        #[inline]
        fn cmp(&self, other: &HexLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for HexLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &HexLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for HexLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> HexLit<'a> {
        pub fn lex(input: &'a str) -> crate::VerboseResult<&'a str, Self> {
            nom::combinator::map(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(nom::character::complete::char('-')),
                        nom::character::complete::char('0'),
                        nom::character::complete::one_of("xX"),
                        nom::bytes::complete::take_while(nom::AsChar::is_hex_digit),
                    )),
                ),
                HexLit,
            )(input)
        }
    }
    /// Parses `-?0[0-7]*`
    pub struct OctLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for OctLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for OctLit<'a> {
        #[inline]
        fn clone(&self) -> OctLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for OctLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "OctLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for OctLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for OctLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for OctLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for OctLit<'a> {
        #[inline]
        fn eq(&self, other: &OctLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for OctLit<'a> {
        #[inline]
        fn cmp(&self, other: &OctLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for OctLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OctLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for OctLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> OctLit<'a> {
        pub fn lex(input: &'a str) -> crate::VerboseResult<&'a str, Self> {
            nom::combinator::map(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(nom::character::complete::char('-')),
                        nom::character::complete::char('0'),
                        nom::bytes::complete::take_while(nom::AsChar::is_oct_digit),
                    )),
                ),
                OctLit,
            )(input)
        }
    }
    /// Represents an integer value
    pub enum IntegerLit<'a> {
        Dec(DecLit<'a>),
        Hex(HexLit<'a>),
        Oct(OctLit<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for IntegerLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for IntegerLit<'a> {
        #[inline]
        fn clone(&self) -> IntegerLit<'a> {
            let _: ::core::clone::AssertParamIsClone<DecLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<HexLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<OctLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for IntegerLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                IntegerLit::Dec(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dec",
                        &__self_0,
                    )
                }
                IntegerLit::Hex(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Hex",
                        &__self_0,
                    )
                }
                IntegerLit::Oct(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Oct",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for IntegerLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for IntegerLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<DecLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<HexLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<OctLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for IntegerLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for IntegerLit<'a> {
        #[inline]
        fn eq(&self, other: &IntegerLit<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (IntegerLit::Dec(__self_0), IntegerLit::Dec(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (IntegerLit::Hex(__self_0), IntegerLit::Hex(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (IntegerLit::Oct(__self_0), IntegerLit::Oct(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for IntegerLit<'a> {
        #[inline]
        fn cmp(&self, other: &IntegerLit<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (IntegerLit::Dec(__self_0), IntegerLit::Dec(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (IntegerLit::Hex(__self_0), IntegerLit::Hex(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (IntegerLit::Oct(__self_0), IntegerLit::Oct(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for IntegerLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &IntegerLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (IntegerLit::Dec(__self_0), IntegerLit::Dec(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (IntegerLit::Hex(__self_0), IntegerLit::Hex(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (IntegerLit::Oct(__self_0), IntegerLit::Oct(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for IntegerLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                IntegerLit::Dec(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                IntegerLit::Hex(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                IntegerLit::Oct(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    impl<'a> IntegerLit<'a> {
        pub fn lex(input: &'a str) -> crate::VerboseResult<&'a str, Self> {
            nom::branch::alt((
                DecLit::lex.map(IntegerLit::Dec),
                HexLit::lex.map(IntegerLit::Hex),
                OctLit::lex.map(IntegerLit::Oct),
            ))(input)
        }
    }
    impl<'a> Parse<'a> for IntegerLit<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: crate::lexer::Terminal::Integer(variant),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> ParsePost<'a> for IntegerLit<'a> {}
    /// Represents a string value
    ///
    /// Follow `/"[^"]*"/`
    pub struct StringLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for StringLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for StringLit<'a> {
        #[inline]
        fn clone(&self) -> StringLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for StringLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "StringLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for StringLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for StringLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for StringLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for StringLit<'a> {
        #[inline]
        fn eq(&self, other: &StringLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for StringLit<'a> {
        #[inline]
        fn cmp(&self, other: &StringLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for StringLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StringLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for StringLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> StringLit<'a> {
        pub fn lex(input: &'a str) -> crate::VerboseResult<&'a str, Self> {
            nom::combinator::map(
                nom::sequence::delimited(
                    nom::character::complete::char('\"'),
                    nom::bytes::complete::take_while(|c| c != '\"'),
                    nom::character::complete::char('\"'),
                ),
                StringLit,
            )(input)
        }
    }
    impl<'a> Parse<'a> for StringLit<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: crate::lexer::Terminal::String(variant),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> ParsePost<'a> for StringLit<'a> {}
    /// Represents `[ ]`
    pub struct EmptyArrayLit {
        pub open_bracket: crate::term::OpenBracket,
        pub close_bracket: crate::term::CloseBracket,
    }
    impl<'a> crate::Parse<'a> for EmptyArrayLit {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, open_bracket) = <crate::term::OpenBracket as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, close_bracket) = <crate::term::CloseBracket as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    open_bracket,
                    close_bracket,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for EmptyArrayLit {}
    #[automatically_derived]
    impl ::core::marker::Copy for EmptyArrayLit {}
    #[automatically_derived]
    impl ::core::default::Default for EmptyArrayLit {
        #[inline]
        fn default() -> EmptyArrayLit {
            EmptyArrayLit {
                open_bracket: ::core::default::Default::default(),
                close_bracket: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EmptyArrayLit {
        #[inline]
        fn clone(&self) -> EmptyArrayLit {
            let _: ::core::clone::AssertParamIsClone<crate::term::OpenBracket>;
            let _: ::core::clone::AssertParamIsClone<crate::term::CloseBracket>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EmptyArrayLit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "EmptyArrayLit",
                "open_bracket",
                &&self.open_bracket,
                "close_bracket",
                &&self.close_bracket,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EmptyArrayLit {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EmptyArrayLit {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::OpenBracket>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::CloseBracket>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EmptyArrayLit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EmptyArrayLit {
        #[inline]
        fn eq(&self, other: &EmptyArrayLit) -> bool {
            self.open_bracket == other.open_bracket
                && self.close_bracket == other.close_bracket
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for EmptyArrayLit {
        #[inline]
        fn cmp(&self, other: &EmptyArrayLit) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_bracket, &other.open_bracket) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.close_bracket, &other.close_bracket)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for EmptyArrayLit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &EmptyArrayLit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_bracket,
                &other.open_bracket,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.close_bracket,
                        &other.close_bracket,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for EmptyArrayLit {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_bracket, state);
            ::core::hash::Hash::hash(&self.close_bracket, state)
        }
    }
    /// Represents `{ }`
    pub struct EmptyDictionaryLit {
        pub open_brace: crate::term::OpenBrace,
        pub close_brace: crate::term::CloseBrace,
    }
    impl<'a> crate::Parse<'a> for EmptyDictionaryLit {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, open_brace) = <crate::term::OpenBrace as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, close_brace) = <crate::term::CloseBrace as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((input, Self { open_brace, close_brace }))
        }
    }
    impl<'a> crate::ParsePost<'a> for EmptyDictionaryLit {}
    #[automatically_derived]
    impl ::core::marker::Copy for EmptyDictionaryLit {}
    #[automatically_derived]
    impl ::core::default::Default for EmptyDictionaryLit {
        #[inline]
        fn default() -> EmptyDictionaryLit {
            EmptyDictionaryLit {
                open_brace: ::core::default::Default::default(),
                close_brace: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EmptyDictionaryLit {
        #[inline]
        fn clone(&self) -> EmptyDictionaryLit {
            let _: ::core::clone::AssertParamIsClone<crate::term::OpenBrace>;
            let _: ::core::clone::AssertParamIsClone<crate::term::CloseBrace>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EmptyDictionaryLit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "EmptyDictionaryLit",
                "open_brace",
                &&self.open_brace,
                "close_brace",
                &&self.close_brace,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EmptyDictionaryLit {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EmptyDictionaryLit {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::OpenBrace>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::CloseBrace>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EmptyDictionaryLit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EmptyDictionaryLit {
        #[inline]
        fn eq(&self, other: &EmptyDictionaryLit) -> bool {
            self.open_brace == other.open_brace && self.close_brace == other.close_brace
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for EmptyDictionaryLit {
        #[inline]
        fn cmp(&self, other: &EmptyDictionaryLit) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_brace, &other.open_brace) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.close_brace, &other.close_brace)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for EmptyDictionaryLit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &EmptyDictionaryLit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_brace,
                &other.open_brace,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.close_brace,
                        &other.close_brace,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for EmptyDictionaryLit {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_brace, state);
            ::core::hash::Hash::hash(&self.close_brace, state)
        }
    }
    /// Represents a default literal value. Ex: `34|34.23|"value"|[ ]|true|false|null`
    pub enum DefaultValue<'a> {
        Boolean(BooleanLit),
        EmptyArray(EmptyArrayLit),
        EmptyDictionary(EmptyDictionaryLit),
        Float(FloatLit<'a>),
        Integer(IntegerLit<'a>),
        Null(crate::term::Null),
        String(StringLit<'a>),
    }
    impl<'a> crate::Parse<'a> for DefaultValue<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <BooleanLit as crate::Parse<'a>>::parse_tokens.map(Self::Boolean),
                <EmptyArrayLit as crate::Parse<'a>>::parse_tokens.map(Self::EmptyArray),
                nom::branch::alt((
                    <EmptyDictionaryLit as crate::Parse<'a>>::parse_tokens
                        .map(Self::EmptyDictionary),
                    <FloatLit<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Float),
                    nom::branch::alt((
                        <IntegerLit<'a> as crate::Parse<'a>>::parse_tokens
                            .map(Self::Integer),
                        <crate::term::Null as crate::Parse<'a>>::parse_tokens
                            .map(Self::Null),
                        <StringLit<'a> as crate::Parse<'a>>::parse_tokens
                            .map(Self::String),
                    )),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for DefaultValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for DefaultValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DefaultValue<'a> {
        #[inline]
        fn clone(&self) -> DefaultValue<'a> {
            let _: ::core::clone::AssertParamIsClone<BooleanLit>;
            let _: ::core::clone::AssertParamIsClone<EmptyArrayLit>;
            let _: ::core::clone::AssertParamIsClone<EmptyDictionaryLit>;
            let _: ::core::clone::AssertParamIsClone<FloatLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<IntegerLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Null>;
            let _: ::core::clone::AssertParamIsClone<StringLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DefaultValue<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DefaultValue::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                DefaultValue::EmptyArray(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EmptyArray",
                        &__self_0,
                    )
                }
                DefaultValue::EmptyDictionary(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EmptyDictionary",
                        &__self_0,
                    )
                }
                DefaultValue::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                DefaultValue::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                DefaultValue::Null(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Null",
                        &__self_0,
                    )
                }
                DefaultValue::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DefaultValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DefaultValue<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<BooleanLit>;
            let _: ::core::cmp::AssertParamIsEq<EmptyArrayLit>;
            let _: ::core::cmp::AssertParamIsEq<EmptyDictionaryLit>;
            let _: ::core::cmp::AssertParamIsEq<FloatLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<IntegerLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Null>;
            let _: ::core::cmp::AssertParamIsEq<StringLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DefaultValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DefaultValue<'a> {
        #[inline]
        fn eq(&self, other: &DefaultValue<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        DefaultValue::Boolean(__self_0),
                        DefaultValue::Boolean(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DefaultValue::EmptyArray(__self_0),
                        DefaultValue::EmptyArray(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DefaultValue::EmptyDictionary(__self_0),
                        DefaultValue::EmptyDictionary(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (DefaultValue::Float(__self_0), DefaultValue::Float(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        DefaultValue::Integer(__self_0),
                        DefaultValue::Integer(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (DefaultValue::Null(__self_0), DefaultValue::Null(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (DefaultValue::String(__self_0), DefaultValue::String(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DefaultValue<'a> {
        #[inline]
        fn cmp(&self, other: &DefaultValue<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            DefaultValue::Boolean(__self_0),
                            DefaultValue::Boolean(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::EmptyArray(__self_0),
                            DefaultValue::EmptyArray(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::EmptyDictionary(__self_0),
                            DefaultValue::EmptyDictionary(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::Float(__self_0),
                            DefaultValue::Float(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::Integer(__self_0),
                            DefaultValue::Integer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (DefaultValue::Null(__self_0), DefaultValue::Null(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            DefaultValue::String(__self_0),
                            DefaultValue::String(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DefaultValue<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DefaultValue<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            DefaultValue::Boolean(__self_0),
                            DefaultValue::Boolean(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::EmptyArray(__self_0),
                            DefaultValue::EmptyArray(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::EmptyDictionary(__self_0),
                            DefaultValue::EmptyDictionary(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::Float(__self_0),
                            DefaultValue::Float(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::Integer(__self_0),
                            DefaultValue::Integer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (DefaultValue::Null(__self_0), DefaultValue::Null(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            DefaultValue::String(__self_0),
                            DefaultValue::String(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DefaultValue<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                DefaultValue::Boolean(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::EmptyArray(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::EmptyDictionary(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::Float(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::Integer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::Null(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                DefaultValue::String(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Represents `true`, `false`, `34.23`, `null`, `56`, ...
    pub enum ConstValue<'a> {
        Boolean(BooleanLit),
        Float(FloatLit<'a>),
        Integer(IntegerLit<'a>),
    }
    impl<'a> crate::Parse<'a> for ConstValue<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <BooleanLit as crate::Parse<'a>>::parse_tokens.map(Self::Boolean),
                <FloatLit<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Float),
                <IntegerLit<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Integer),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for ConstValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ConstValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstValue<'a> {
        #[inline]
        fn clone(&self) -> ConstValue<'a> {
            let _: ::core::clone::AssertParamIsClone<BooleanLit>;
            let _: ::core::clone::AssertParamIsClone<FloatLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<IntegerLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstValue<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ConstValue::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                ConstValue::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                ConstValue::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstValue<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<BooleanLit>;
            let _: ::core::cmp::AssertParamIsEq<FloatLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<IntegerLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstValue<'a> {
        #[inline]
        fn eq(&self, other: &ConstValue<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (ConstValue::Boolean(__self_0), ConstValue::Boolean(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstValue::Float(__self_0), ConstValue::Float(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstValue::Integer(__self_0), ConstValue::Integer(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstValue<'a> {
        #[inline]
        fn cmp(&self, other: &ConstValue<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            ConstValue::Boolean(__self_0),
                            ConstValue::Boolean(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (ConstValue::Float(__self_0), ConstValue::Float(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstValue::Integer(__self_0),
                            ConstValue::Integer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstValue<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstValue<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            ConstValue::Boolean(__self_0),
                            ConstValue::Boolean(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (ConstValue::Float(__self_0), ConstValue::Float(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstValue::Integer(__self_0),
                            ConstValue::Integer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstValue<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                ConstValue::Boolean(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ConstValue::Float(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstValue::Integer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Represents either `true` or `false`
    pub struct BooleanLit(bool);
    #[automatically_derived]
    impl ::core::marker::Copy for BooleanLit {}
    #[automatically_derived]
    impl ::core::clone::Clone for BooleanLit {
        #[inline]
        fn clone(&self) -> BooleanLit {
            let _: ::core::clone::AssertParamIsClone<bool>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BooleanLit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "BooleanLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BooleanLit {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BooleanLit {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<bool>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BooleanLit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BooleanLit {
        #[inline]
        fn eq(&self, other: &BooleanLit) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for BooleanLit {
        #[inline]
        fn cmp(&self, other: &BooleanLit) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for BooleanLit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &BooleanLit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for BooleanLit {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> Parse<'a> for BooleanLit {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            nom::combinator::map(
                nom::branch::alt((
                    nom::combinator::value(
                        true,
                        <crate::term::True as crate::Parse<'a>>::parse_tokens,
                    ),
                    nom::combinator::value(
                        false,
                        <crate::term::False as crate::Parse<'a>>::parse_tokens,
                    ),
                )),
                BooleanLit,
            )(input)
        }
    }
    impl<'a> ParsePost<'a> for BooleanLit {}
    /// Parses `/-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/`
    pub struct FloatValueLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for FloatValueLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for FloatValueLit<'a> {
        #[inline]
        fn clone(&self) -> FloatValueLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for FloatValueLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "FloatValueLit",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for FloatValueLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for FloatValueLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for FloatValueLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for FloatValueLit<'a> {
        #[inline]
        fn eq(&self, other: &FloatValueLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for FloatValueLit<'a> {
        #[inline]
        fn cmp(&self, other: &FloatValueLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for FloatValueLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FloatValueLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for FloatValueLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> FloatValueLit<'a> {
        pub fn lex(input: &'a str) -> crate::VerboseResult<&'a str, Self> {
            nom::combinator::map(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(nom::character::complete::char('-')),
                        nom::branch::alt((
                            nom::combinator::value(
                                (),
                                nom::sequence::tuple((
                                    nom::branch::alt((
                                        nom::sequence::tuple((
                                            nom::bytes::complete::take_while1(
                                                nom::AsChar::is_dec_digit,
                                            ),
                                            nom::character::complete::char('.'),
                                            nom::bytes::complete::take_while(nom::AsChar::is_dec_digit),
                                        )),
                                        nom::sequence::tuple((
                                            nom::bytes::complete::take_while(nom::AsChar::is_dec_digit),
                                            nom::character::complete::char('.'),
                                            nom::bytes::complete::take_while1(nom::AsChar::is_dec_digit),
                                        )),
                                    )),
                                    nom::combinator::opt(
                                        nom::sequence::tuple((
                                            nom::character::complete::one_of("eE"),
                                            nom::combinator::opt(
                                                nom::character::complete::one_of("+-"),
                                            ),
                                            nom::bytes::complete::take_while1(nom::AsChar::is_dec_digit),
                                        )),
                                    ),
                                )),
                            ),
                            nom::combinator::value(
                                (),
                                nom::sequence::tuple((
                                    nom::bytes::complete::take_while1(
                                        nom::AsChar::is_dec_digit,
                                    ),
                                    nom::character::complete::one_of("eE"),
                                    nom::combinator::opt(
                                        nom::character::complete::one_of("+-"),
                                    ),
                                    nom::bytes::complete::take_while1(nom::AsChar::is_dec_digit),
                                )),
                            ),
                        )),
                    )),
                ),
                FloatValueLit,
            )(input)
        }
    }
    impl<'a> Parse<'a> for FloatValueLit<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            crate::macros::annotate(|
                input: crate::tokens::Tokens,
            | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                use nom::{InputIter, Slice};
                match input.iter_elements().next() {
                    Some(
                        crate::lexer::Token {
                            value: crate::lexer::Terminal::Decimal(variant),
                            trivia: _,
                        },
                    ) => Ok((input.slice(1..), variant)),
                    _ => nom::combinator::fail(input),
                }
            })(input)
        }
    }
    impl<'a> ParsePost<'a> for FloatValueLit<'a> {}
    /// Represents a floating point value, `NaN`, `Infinity`, '+Infinity`
    pub enum FloatLit<'a> {
        Value(FloatValueLit<'a>),
        NegInfinity(crate::term::NegInfinity),
        Infinity(crate::term::Infinity),
        NaN(crate::term::NaN),
    }
    impl<'a> crate::Parse<'a> for FloatLit<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <FloatValueLit<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Value),
                <crate::term::NegInfinity as crate::Parse<'a>>::parse_tokens
                    .map(Self::NegInfinity),
                nom::branch::alt((
                    <crate::term::Infinity as crate::Parse<'a>>::parse_tokens
                        .map(Self::Infinity),
                    <crate::term::NaN as crate::Parse<'a>>::parse_tokens.map(Self::NaN),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for FloatLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for FloatLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for FloatLit<'a> {
        #[inline]
        fn clone(&self) -> FloatLit<'a> {
            let _: ::core::clone::AssertParamIsClone<FloatValueLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::NegInfinity>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Infinity>;
            let _: ::core::clone::AssertParamIsClone<crate::term::NaN>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for FloatLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FloatLit::Value(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Value",
                        &__self_0,
                    )
                }
                FloatLit::NegInfinity(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NegInfinity",
                        &__self_0,
                    )
                }
                FloatLit::Infinity(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Infinity",
                        &__self_0,
                    )
                }
                FloatLit::NaN(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NaN",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for FloatLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for FloatLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<FloatValueLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::NegInfinity>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Infinity>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::NaN>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for FloatLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for FloatLit<'a> {
        #[inline]
        fn eq(&self, other: &FloatLit<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        FloatLit::NegInfinity(__self_0),
                        FloatLit::NegInfinity(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (FloatLit::Infinity(__self_0), FloatLit::Infinity(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for FloatLit<'a> {
        #[inline]
        fn cmp(&self, other: &FloatLit<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            FloatLit::NegInfinity(__self_0),
                            FloatLit::NegInfinity(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (FloatLit::Infinity(__self_0), FloatLit::Infinity(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for FloatLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FloatLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            FloatLit::NegInfinity(__self_0),
                            FloatLit::NegInfinity(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (FloatLit::Infinity(__self_0), FloatLit::Infinity(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for FloatLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                FloatLit::Value(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                FloatLit::NegInfinity(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                FloatLit::Infinity(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                FloatLit::NaN(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
}
pub mod members {
    use weedle_derive::Weedle;
    use crate::{
        argument::ArgumentList, attribute::ExtendedAttributeList,
        common::{Identifier, Parenthesized},
        literal::ConstValue, types::{AttributedType, ConstType, Type},
        VerboseResult,
    };
    /// Parses a const interface member `[attributes]? const type identifier = value;`
    pub struct ConstMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub const_: crate::term::Const,
        pub const_type: ConstType<'a>,
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub const_value: ConstValue<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for ConstMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, const_) = <crate::term::Const as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, const_type) = <ConstType<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, identifier) = <Identifier<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, assign) = <crate::term::Assign as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, const_value) = <ConstValue<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    const_,
                    const_type,
                    identifier,
                    assign,
                    const_value,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for ConstMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstMember<'a> {
        #[inline]
        fn clone(&self) -> ConstMember<'a> {
            ConstMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                const_: ::core::clone::Clone::clone(&self.const_),
                const_type: ::core::clone::Clone::clone(&self.const_type),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                const_value: ::core::clone::Clone::clone(&self.const_value),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "const_",
                "const_type",
                "identifier",
                "assign",
                "const_value",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.const_,
                &&self.const_type,
                &&self.identifier,
                &&self.assign,
                &&self.const_value,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ConstMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Const>;
            let _: ::core::cmp::AssertParamIsEq<ConstType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<ConstValue<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstMember<'a> {
        #[inline]
        fn eq(&self, other: &ConstMember<'a>) -> bool {
            self.attributes == other.attributes && self.const_ == other.const_
                && self.const_type == other.const_type
                && self.identifier == other.identifier && self.assign == other.assign
                && self.const_value == other.const_value
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstMember<'a> {
        #[inline]
        fn cmp(&self, other: &ConstMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.const_, &other.const_) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.const_type,
                                &other.const_type,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.const_value,
                                                        &other.const_value,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.const_,
                        &other.const_,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.const_type,
                                &other.const_type,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.assign,
                                                &other.assign,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.const_value,
                                                        &other.const_value,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.const_, state);
            ::core::hash::Hash::hash(&self.const_type, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.const_value, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses `stringifier|inherit|static`
    pub enum StringifierOrInheritOrStatic {
        Stringifier(crate::term::Stringifier),
        Inherit(crate::term::Inherit),
        Static(crate::term::Static),
    }
    impl<'a> crate::Parse<'a> for StringifierOrInheritOrStatic {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <crate::term::Stringifier as crate::Parse<'a>>::parse_tokens
                    .map(Self::Stringifier),
                <crate::term::Inherit as crate::Parse<'a>>::parse_tokens
                    .map(Self::Inherit),
                <crate::term::Static as crate::Parse<'a>>::parse_tokens.map(Self::Static),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for StringifierOrInheritOrStatic {}
    #[automatically_derived]
    impl ::core::marker::Copy for StringifierOrInheritOrStatic {}
    #[automatically_derived]
    impl ::core::clone::Clone for StringifierOrInheritOrStatic {
        #[inline]
        fn clone(&self) -> StringifierOrInheritOrStatic {
            let _: ::core::clone::AssertParamIsClone<crate::term::Stringifier>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Inherit>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Static>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StringifierOrInheritOrStatic {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                StringifierOrInheritOrStatic::Stringifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stringifier",
                        &__self_0,
                    )
                }
                StringifierOrInheritOrStatic::Inherit(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Inherit",
                        &__self_0,
                    )
                }
                StringifierOrInheritOrStatic::Static(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Static",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for StringifierOrInheritOrStatic {}
    #[automatically_derived]
    impl ::core::cmp::Eq for StringifierOrInheritOrStatic {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Stringifier>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Inherit>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Static>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StringifierOrInheritOrStatic {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StringifierOrInheritOrStatic {
        #[inline]
        fn eq(&self, other: &StringifierOrInheritOrStatic) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        StringifierOrInheritOrStatic::Stringifier(__self_0),
                        StringifierOrInheritOrStatic::Stringifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        StringifierOrInheritOrStatic::Inherit(__self_0),
                        StringifierOrInheritOrStatic::Inherit(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        StringifierOrInheritOrStatic::Static(__self_0),
                        StringifierOrInheritOrStatic::Static(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for StringifierOrInheritOrStatic {
        #[inline]
        fn cmp(&self, other: &StringifierOrInheritOrStatic) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            StringifierOrInheritOrStatic::Stringifier(__self_0),
                            StringifierOrInheritOrStatic::Stringifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            StringifierOrInheritOrStatic::Inherit(__self_0),
                            StringifierOrInheritOrStatic::Inherit(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            StringifierOrInheritOrStatic::Static(__self_0),
                            StringifierOrInheritOrStatic::Static(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for StringifierOrInheritOrStatic {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StringifierOrInheritOrStatic,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            StringifierOrInheritOrStatic::Stringifier(__self_0),
                            StringifierOrInheritOrStatic::Stringifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            StringifierOrInheritOrStatic::Inherit(__self_0),
                            StringifierOrInheritOrStatic::Inherit(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            StringifierOrInheritOrStatic::Static(__self_0),
                            StringifierOrInheritOrStatic::Static(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for StringifierOrInheritOrStatic {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                StringifierOrInheritOrStatic::Stringifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                StringifierOrInheritOrStatic::Inherit(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                StringifierOrInheritOrStatic::Static(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    struct AttributeName<'a>(&'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributeName<'a> {
        #[inline]
        fn clone(&self) -> AttributeName<'a> {
            AttributeName(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributeName<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "AttributeName",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributeName<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributeName<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributeName<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributeName<'a> {
        #[inline]
        fn eq(&self, other: &AttributeName<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributeName<'a> {
        #[inline]
        fn cmp(&self, other: &AttributeName<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributeName<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributeName<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributeName<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> crate::Parse<'a> for AttributeName<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: crate::lexer::Terminal::Identifier(variant),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, AttributeName(result.0)));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Async(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, AttributeName(result.value())));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Required(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, AttributeName(result.value())));
            }
            nom::combinator::fail(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for AttributeName<'a> {}
    impl<'a> From<AttributeName<'a>> for Identifier<'a> {
        fn from(value: AttributeName<'a>) -> Self {
            Self(value.0)
        }
    }
    /// Parses `[attributes]? (stringifier|inherit|static)? readonly? attribute attributedtype identifier;`
    pub struct AttributeInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub modifier: Option<StringifierOrInheritOrStatic>,
        pub readonly: Option<crate::term::ReadOnly>,
        pub attribute: crate::term::Attribute,
        pub type_: AttributedType<'a>,
        #[weedle(from = "AttributeName")]
        pub identifier: Identifier<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for AttributeInterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, modifier) = <Option<
                StringifierOrInheritOrStatic,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, readonly) = <Option<
                crate::term::ReadOnly,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, attribute) = <crate::term::Attribute as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, type_) = <AttributedType<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, identifier) = nom::combinator::into(
                <AttributeName as crate::Parse<'a>>::parse_tokens,
            )(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    modifier,
                    readonly,
                    attribute,
                    type_,
                    identifier,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for AttributeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributeInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> AttributeInterfaceMember<'a> {
            AttributeInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                modifier: ::core::clone::Clone::clone(&self.modifier),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                attribute: ::core::clone::Clone::clone(&self.attribute),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributeInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "modifier",
                "readonly",
                "attribute",
                "type_",
                "identifier",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.modifier,
                &&self.readonly,
                &&self.attribute,
                &&self.type_,
                &&self.identifier,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AttributeInterfaceMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributeInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<StringifierOrInheritOrStatic>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::ReadOnly>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Attribute>;
            let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributeInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &AttributeInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.modifier == other.modifier
                && self.readonly == other.readonly && self.attribute == other.attribute
                && self.type_ == other.type_ && self.identifier == other.identifier
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributeInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &AttributeInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.modifier, &other.modifier) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.readonly,
                                &other.readonly,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.attribute,
                                        &other.attribute,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.identifier,
                                                        &other.identifier,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributeInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributeInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.modifier,
                        &other.modifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.readonly,
                                &other.readonly,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.attribute,
                                        &other.attribute,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.type_,
                                                &other.type_,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.identifier,
                                                        &other.identifier,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributeInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.modifier, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.attribute, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses `[attributes]? stringifier? readonly? attribute attributedtype identifier;`
    pub struct AttributeMixinMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub stringifier: Option<crate::term::Stringifier>,
        pub readonly: Option<crate::term::ReadOnly>,
        pub attribute: crate::term::Attribute,
        pub type_: AttributedType<'a>,
        #[weedle(from = "AttributeName")]
        pub identifier: Identifier<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for AttributeMixinMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, stringifier) = <Option<
                crate::term::Stringifier,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, readonly) = <Option<
                crate::term::ReadOnly,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, attribute) = <crate::term::Attribute as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, type_) = <AttributedType<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, identifier) = nom::combinator::into(
                <AttributeName as crate::Parse<'a>>::parse_tokens,
            )(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    stringifier,
                    readonly,
                    attribute,
                    type_,
                    identifier,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for AttributeMixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributeMixinMember<'a> {
        #[inline]
        fn clone(&self) -> AttributeMixinMember<'a> {
            AttributeMixinMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                stringifier: ::core::clone::Clone::clone(&self.stringifier),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                attribute: ::core::clone::Clone::clone(&self.attribute),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributeMixinMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "stringifier",
                "readonly",
                "attribute",
                "type_",
                "identifier",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.stringifier,
                &&self.readonly,
                &&self.attribute,
                &&self.type_,
                &&self.identifier,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AttributeMixinMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributeMixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributeMixinMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Stringifier>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::ReadOnly>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Attribute>;
            let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributeMixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributeMixinMember<'a> {
        #[inline]
        fn eq(&self, other: &AttributeMixinMember<'a>) -> bool {
            self.attributes == other.attributes && self.stringifier == other.stringifier
                && self.readonly == other.readonly && self.attribute == other.attribute
                && self.type_ == other.type_ && self.identifier == other.identifier
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributeMixinMember<'a> {
        #[inline]
        fn cmp(&self, other: &AttributeMixinMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.stringifier, &other.stringifier) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.readonly,
                                &other.readonly,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.attribute,
                                        &other.attribute,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.identifier,
                                                        &other.identifier,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributeMixinMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributeMixinMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.stringifier,
                        &other.stringifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.readonly,
                                &other.readonly,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.attribute,
                                        &other.attribute,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.type_,
                                                &other.type_,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.identifier,
                                                        &other.identifier,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributeMixinMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.stringifier, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.attribute, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses `[attribute]? readonly attributetype type identifier;`
    pub struct AttributeNamespaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub readonly: crate::term::ReadOnly,
        pub attribute: crate::term::Attribute,
        pub type_: AttributedType<'a>,
        #[weedle(from = "AttributeName")]
        pub identifier: Identifier<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for AttributeNamespaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, readonly) = <crate::term::ReadOnly as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, attribute) = <crate::term::Attribute as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, type_) = <AttributedType<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, identifier) = nom::combinator::into(
                <AttributeName as crate::Parse<'a>>::parse_tokens,
            )(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    readonly,
                    attribute,
                    type_,
                    identifier,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for AttributeNamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributeNamespaceMember<'a> {
        #[inline]
        fn clone(&self) -> AttributeNamespaceMember<'a> {
            AttributeNamespaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                attribute: ::core::clone::Clone::clone(&self.attribute),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributeNamespaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "readonly",
                "attribute",
                "type_",
                "identifier",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.readonly,
                &&self.attribute,
                &&self.type_,
                &&self.identifier,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AttributeNamespaceMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributeNamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributeNamespaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::ReadOnly>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Attribute>;
            let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributeNamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributeNamespaceMember<'a> {
        #[inline]
        fn eq(&self, other: &AttributeNamespaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.readonly == other.readonly
                && self.attribute == other.attribute && self.type_ == other.type_
                && self.identifier == other.identifier
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributeNamespaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &AttributeNamespaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.readonly, &other.readonly) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.attribute,
                                &other.attribute,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.identifier,
                                                &other.identifier,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributeNamespaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributeNamespaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.readonly,
                        &other.readonly,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.attribute,
                                &other.attribute,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.type_,
                                        &other.type_,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.identifier,
                                                &other.identifier,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.semi_colon,
                                                        &other.semi_colon,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributeNamespaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.attribute, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses one of the special keyword `getter|setter|deleter` or `static`.
    pub enum Modifier {
        Getter(crate::term::Getter),
        Setter(crate::term::Setter),
        Deleter(crate::term::Deleter),
        Static(crate::term::Static),
    }
    impl<'a> crate::Parse<'a> for Modifier {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <crate::term::Getter as crate::Parse<'a>>::parse_tokens
                    .map(Self::Getter),
                <crate::term::Setter as crate::Parse<'a>>::parse_tokens
                    .map(Self::Setter),
                nom::branch::alt((
                    <crate::term::Deleter as crate::Parse<'a>>::parse_tokens
                        .map(Self::Deleter),
                    <crate::term::Static as crate::Parse<'a>>::parse_tokens
                        .map(Self::Static),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Modifier {}
    #[automatically_derived]
    impl ::core::marker::Copy for Modifier {}
    #[automatically_derived]
    impl ::core::clone::Clone for Modifier {
        #[inline]
        fn clone(&self) -> Modifier {
            let _: ::core::clone::AssertParamIsClone<crate::term::Getter>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Setter>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Deleter>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Static>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Modifier {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Modifier::Getter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Getter",
                        &__self_0,
                    )
                }
                Modifier::Setter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Setter",
                        &__self_0,
                    )
                }
                Modifier::Deleter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Deleter",
                        &__self_0,
                    )
                }
                Modifier::Static(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Static",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Modifier {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Modifier {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Getter>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Setter>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Deleter>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Static>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Modifier {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Modifier {
        #[inline]
        fn eq(&self, other: &Modifier) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Modifier::Getter(__self_0), Modifier::Getter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Modifier::Setter(__self_0), Modifier::Setter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Modifier::Deleter(__self_0), Modifier::Deleter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Modifier::Static(__self_0), Modifier::Static(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Modifier {
        #[inline]
        fn cmp(&self, other: &Modifier) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Modifier::Getter(__self_0), Modifier::Getter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Modifier::Setter(__self_0), Modifier::Setter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Modifier::Deleter(__self_0), Modifier::Deleter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Modifier::Static(__self_0), Modifier::Static(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Modifier {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Modifier,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Modifier::Getter(__self_0), Modifier::Getter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Modifier::Setter(__self_0), Modifier::Setter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Modifier::Deleter(__self_0), Modifier::Deleter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Modifier::Static(__self_0), Modifier::Static(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Modifier {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Modifier::Getter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Modifier::Setter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Modifier::Deleter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Modifier::Static(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    struct OperationName<'a>(&'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for OperationName<'a> {
        #[inline]
        fn clone(&self) -> OperationName<'a> {
            OperationName(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for OperationName<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "OperationName",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for OperationName<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for OperationName<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for OperationName<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for OperationName<'a> {
        #[inline]
        fn eq(&self, other: &OperationName<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for OperationName<'a> {
        #[inline]
        fn cmp(&self, other: &OperationName<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for OperationName<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OperationName<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for OperationName<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'a> crate::Parse<'a> for OperationName<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: crate::lexer::Terminal::Identifier(variant),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, OperationName(result.0)));
            }
            if let Ok((tokens, result))
                = crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    use crate::lexer::Terminal;
                    use crate::term::Keyword;
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: Terminal::Keyword(Keyword::Includes(variant)),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                })(input) {
                return Ok((tokens, OperationName(result.value())));
            }
            nom::combinator::fail(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for OperationName<'a> {}
    impl<'a> From<OperationName<'a>> for Identifier<'a> {
        fn from(value: OperationName<'a>) -> Self {
            Self(value.0)
        }
    }
    /// Parses `[attributes]? (stringifier|static)? special? returntype identifier? (( args ));`
    ///
    /// (( )) means ( ) chars
    pub struct OperationInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub modifier: Option<Modifier>,
        pub return_type: Type<'a>,
        #[weedle(from = "OperationName", opt)]
        pub identifier: Option<Identifier<'a>>,
        pub args: Parenthesized<ArgumentList<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for OperationInterfaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, modifier) = <Option<
                Modifier,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, return_type) = <Type<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, identifier) = nom::combinator::opt(
                nom::combinator::into(<OperationName as crate::Parse<'a>>::parse_tokens),
            )(input)?;
            let (input, args) = <Parenthesized<
                ArgumentList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    modifier,
                    return_type,
                    identifier,
                    args,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for OperationInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for OperationInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> OperationInterfaceMember<'a> {
            OperationInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                modifier: ::core::clone::Clone::clone(&self.modifier),
                return_type: ::core::clone::Clone::clone(&self.return_type),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for OperationInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "modifier",
                "return_type",
                "identifier",
                "args",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.modifier,
                &&self.return_type,
                &&self.identifier,
                &&self.args,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "OperationInterfaceMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for OperationInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for OperationInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Modifier>>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Identifier<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for OperationInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for OperationInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &OperationInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.modifier == other.modifier
                && self.return_type == other.return_type
                && self.identifier == other.identifier && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for OperationInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &OperationInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.modifier, &other.modifier) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.return_type,
                                &other.return_type,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                                ::core::cmp::Ordering::Equal => {
                                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for OperationInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OperationInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.modifier,
                        &other.modifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.return_type,
                                &other.return_type,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.args,
                                                &other.args,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.semi_colon,
                                                        &other.semi_colon,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for OperationInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.modifier, state);
            ::core::hash::Hash::hash(&self.return_type, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    /// Parses `[attributes]? returntype identifier? (( args ));`
    ///
    /// (( )) means ( ) chars
    pub struct RegularOperationMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub return_type: Type<'a>,
        #[weedle(from = "OperationName", opt)]
        pub identifier: Option<Identifier<'a>>,
        pub args: Parenthesized<ArgumentList<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for RegularOperationMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, return_type) = <Type<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, identifier) = nom::combinator::opt(
                nom::combinator::into(<OperationName as crate::Parse<'a>>::parse_tokens),
            )(input)?;
            let (input, args) = <Parenthesized<
                ArgumentList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((
                input,
                Self {
                    attributes,
                    return_type,
                    identifier,
                    args,
                    semi_colon,
                },
            ))
        }
    }
    impl<'a> crate::ParsePost<'a> for RegularOperationMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for RegularOperationMember<'a> {
        #[inline]
        fn clone(&self) -> RegularOperationMember<'a> {
            RegularOperationMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                return_type: ::core::clone::Clone::clone(&self.return_type),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for RegularOperationMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "RegularOperationMember",
                "attributes",
                &&self.attributes,
                "return_type",
                &&self.return_type,
                "identifier",
                &&self.identifier,
                "args",
                &&self.args,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for RegularOperationMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for RegularOperationMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Identifier<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for RegularOperationMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for RegularOperationMember<'a> {
        #[inline]
        fn eq(&self, other: &RegularOperationMember<'a>) -> bool {
            self.attributes == other.attributes && self.return_type == other.return_type
                && self.identifier == other.identifier && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for RegularOperationMember<'a> {
        #[inline]
        fn cmp(&self, other: &RegularOperationMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.return_type, &other.return_type) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.identifier,
                                &other.identifier,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for RegularOperationMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RegularOperationMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.return_type,
                        &other.return_type,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.identifier,
                                &other.identifier,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.args,
                                        &other.args,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for RegularOperationMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.return_type, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
}
pub mod mixin {
    use weedle_derive::Weedle;
    use crate::interface::StringifierMember;
    use crate::members::{AttributeMixinMember, ConstMember, RegularOperationMember};
    /// Parses the members declarations of a mixin
    pub type MixinMembers<'a> = Vec<MixinMember<'a>>;
    /// Parses one of the variants of a mixin member
    pub enum MixinMember<'a> {
        Const(ConstMember<'a>),
        Operation(RegularOperationMember<'a>),
        Attribute(AttributeMixinMember<'a>),
        Stringifier(StringifierMember<'a>),
    }
    impl<'a> crate::Parse<'a> for MixinMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <ConstMember<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Const),
                <RegularOperationMember<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Operation),
                nom::branch::alt((
                    <AttributeMixinMember<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Attribute),
                    <StringifierMember<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Stringifier),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for MixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for MixinMember<'a> {
        #[inline]
        fn clone(&self) -> MixinMember<'a> {
            match self {
                MixinMember::Const(__self_0) => {
                    MixinMember::Const(::core::clone::Clone::clone(__self_0))
                }
                MixinMember::Operation(__self_0) => {
                    MixinMember::Operation(::core::clone::Clone::clone(__self_0))
                }
                MixinMember::Attribute(__self_0) => {
                    MixinMember::Attribute(::core::clone::Clone::clone(__self_0))
                }
                MixinMember::Stringifier(__self_0) => {
                    MixinMember::Stringifier(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for MixinMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                MixinMember::Const(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Const",
                        &__self_0,
                    )
                }
                MixinMember::Operation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Operation",
                        &__self_0,
                    )
                }
                MixinMember::Attribute(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Attribute",
                        &__self_0,
                    )
                }
                MixinMember::Stringifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stringifier",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for MixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for MixinMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<RegularOperationMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<AttributeMixinMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<StringifierMember<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for MixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for MixinMember<'a> {
        #[inline]
        fn eq(&self, other: &MixinMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (MixinMember::Const(__self_0), MixinMember::Const(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        MixinMember::Operation(__self_0),
                        MixinMember::Operation(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MixinMember::Attribute(__self_0),
                        MixinMember::Attribute(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MixinMember::Stringifier(__self_0),
                        MixinMember::Stringifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for MixinMember<'a> {
        #[inline]
        fn cmp(&self, other: &MixinMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (MixinMember::Const(__self_0), MixinMember::Const(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            MixinMember::Operation(__self_0),
                            MixinMember::Operation(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            MixinMember::Attribute(__self_0),
                            MixinMember::Attribute(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            MixinMember::Stringifier(__self_0),
                            MixinMember::Stringifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for MixinMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MixinMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (MixinMember::Const(__self_0), MixinMember::Const(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            MixinMember::Operation(__self_0),
                            MixinMember::Operation(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            MixinMember::Attribute(__self_0),
                            MixinMember::Attribute(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            MixinMember::Stringifier(__self_0),
                            MixinMember::Stringifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for MixinMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                MixinMember::Const(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                MixinMember::Operation(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                MixinMember::Attribute(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                MixinMember::Stringifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
}
pub mod namespace {
    use weedle_derive::Weedle;
    use crate::members::{AttributeNamespaceMember, ConstMember, RegularOperationMember};
    /// Parses namespace members declaration
    pub type NamespaceMembers<'a> = Vec<NamespaceMember<'a>>;
    /// Parses namespace member declaration
    pub enum NamespaceMember<'a> {
        Operation(RegularOperationMember<'a>),
        Attribute(AttributeNamespaceMember<'a>),
        Const(ConstMember<'a>),
    }
    impl<'a> crate::Parse<'a> for NamespaceMember<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <RegularOperationMember<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Operation),
                <AttributeNamespaceMember<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Attribute),
                <ConstMember<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Const),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for NamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for NamespaceMember<'a> {
        #[inline]
        fn clone(&self) -> NamespaceMember<'a> {
            match self {
                NamespaceMember::Operation(__self_0) => {
                    NamespaceMember::Operation(::core::clone::Clone::clone(__self_0))
                }
                NamespaceMember::Attribute(__self_0) => {
                    NamespaceMember::Attribute(::core::clone::Clone::clone(__self_0))
                }
                NamespaceMember::Const(__self_0) => {
                    NamespaceMember::Const(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for NamespaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                NamespaceMember::Operation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Operation",
                        &__self_0,
                    )
                }
                NamespaceMember::Attribute(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Attribute",
                        &__self_0,
                    )
                }
                NamespaceMember::Const(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Const",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for NamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for NamespaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<RegularOperationMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<AttributeNamespaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for NamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for NamespaceMember<'a> {
        #[inline]
        fn eq(&self, other: &NamespaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        NamespaceMember::Operation(__self_0),
                        NamespaceMember::Operation(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NamespaceMember::Attribute(__self_0),
                        NamespaceMember::Attribute(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NamespaceMember::Const(__self_0),
                        NamespaceMember::Const(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for NamespaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &NamespaceMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            NamespaceMember::Operation(__self_0),
                            NamespaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NamespaceMember::Attribute(__self_0),
                            NamespaceMember::Attribute(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NamespaceMember::Const(__self_0),
                            NamespaceMember::Const(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for NamespaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &NamespaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            NamespaceMember::Operation(__self_0),
                            NamespaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NamespaceMember::Attribute(__self_0),
                            NamespaceMember::Attribute(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NamespaceMember::Const(__self_0),
                            NamespaceMember::Const(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for NamespaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                NamespaceMember::Operation(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NamespaceMember::Attribute(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NamespaceMember::Const(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
}
pub mod types {
    use weedle_derive::Weedle;
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Generics, Identifier, Parenthesized, Punctuated};
    use crate::term;
    use crate::Parse;
    /// Parses a union of types
    pub type UnionType<'a> = Parenthesized<
        Punctuated<UnionMemberType<'a>, crate::term::Or>,
    >;
    pub enum SingleType<'a> {
        Any(crate::term::Any),
        Promise(PromiseType<'a>),
        Distinguishable(DistinguishableType<'a>),
    }
    impl<'a> crate::Parse<'a> for SingleType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <crate::term::Any as crate::Parse<'a>>::parse_tokens.map(Self::Any),
                <PromiseType<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Promise),
                <DistinguishableType<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Distinguishable),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for SingleType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SingleType<'a> {
        #[inline]
        fn clone(&self) -> SingleType<'a> {
            match self {
                SingleType::Any(__self_0) => {
                    SingleType::Any(::core::clone::Clone::clone(__self_0))
                }
                SingleType::Promise(__self_0) => {
                    SingleType::Promise(::core::clone::Clone::clone(__self_0))
                }
                SingleType::Distinguishable(__self_0) => {
                    SingleType::Distinguishable(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SingleType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                SingleType::Any(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Any",
                        &__self_0,
                    )
                }
                SingleType::Promise(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Promise",
                        &__self_0,
                    )
                }
                SingleType::Distinguishable(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Distinguishable",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SingleType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SingleType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Any>;
            let _: ::core::cmp::AssertParamIsEq<PromiseType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<DistinguishableType<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SingleType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SingleType<'a> {
        #[inline]
        fn eq(&self, other: &SingleType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (SingleType::Any(__self_0), SingleType::Any(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (SingleType::Promise(__self_0), SingleType::Promise(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        SingleType::Distinguishable(__self_0),
                        SingleType::Distinguishable(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SingleType<'a> {
        #[inline]
        fn cmp(&self, other: &SingleType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (SingleType::Any(__self_0), SingleType::Any(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            SingleType::Promise(__self_0),
                            SingleType::Promise(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            SingleType::Distinguishable(__self_0),
                            SingleType::Distinguishable(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SingleType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SingleType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (SingleType::Any(__self_0), SingleType::Any(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            SingleType::Promise(__self_0),
                            SingleType::Promise(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            SingleType::Distinguishable(__self_0),
                            SingleType::Distinguishable(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SingleType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                SingleType::Any(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                SingleType::Promise(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                SingleType::Distinguishable(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses either single type or a union type
    pub enum Type<'a> {
        Single(SingleType<'a>),
        Union(MayBeNull<UnionType<'a>>),
    }
    impl<'a> crate::Parse<'a> for Type<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <SingleType<'a> as crate::Parse<'a>>::parse_tokens.map(Self::Single),
                <MayBeNull<UnionType<'a>> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Union),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for Type<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Type<'a> {
        #[inline]
        fn clone(&self) -> Type<'a> {
            match self {
                Type::Single(__self_0) => {
                    Type::Single(::core::clone::Clone::clone(__self_0))
                }
                Type::Union(__self_0) => {
                    Type::Union(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Type<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Type::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                Type::Union(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Union",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Type<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Type<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<SingleType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<UnionType<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Type<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Type<'a> {
        #[inline]
        fn eq(&self, other: &Type<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Type::Single(__self_0), Type::Single(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Type::Union(__self_0), Type::Union(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Type<'a> {
        #[inline]
        fn cmp(&self, other: &Type<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Type::Single(__self_0), Type::Single(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Type::Union(__self_0), Type::Union(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Type<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Type<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Type::Single(__self_0), Type::Single(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Type::Union(__self_0), Type::Union(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Type<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Type::Single(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Type::Union(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    pub enum DistinguishableType<'a> {
        Integer(MayBeNull<IntegerType>),
        FloatingPoint(MayBeNull<FloatingPointType>),
        Boolean(MayBeNull<crate::term::Boolean>),
        Byte(MayBeNull<crate::term::Byte>),
        Octet(MayBeNull<crate::term::Octet>),
        Bigint(MayBeNull<crate::term::Bigint>),
        ByteString(MayBeNull<crate::term::ByteString>),
        DOMString(MayBeNull<crate::term::DOMString>),
        USVString(MayBeNull<crate::term::USVString>),
        Sequence(MayBeNull<SequenceType<'a>>),
        Object(MayBeNull<crate::term::Object>),
        Symbol(MayBeNull<crate::term::Symbol>),
        ArrayBuffer(MayBeNull<crate::term::ArrayBuffer>),
        DataView(MayBeNull<crate::term::DataView>),
        Int8Array(MayBeNull<crate::term::Int8Array>),
        Int16Array(MayBeNull<crate::term::Int16Array>),
        Int32Array(MayBeNull<crate::term::Int32Array>),
        Uint8Array(MayBeNull<crate::term::Uint8Array>),
        Uint16Array(MayBeNull<crate::term::Uint16Array>),
        Uint32Array(MayBeNull<crate::term::Uint32Array>),
        Uint8ClampedArray(MayBeNull<crate::term::Uint8ClampedArray>),
        BigInt64Array(MayBeNull<crate::term::BigInt64Array>),
        BigUint64Array(MayBeNull<crate::term::BigUint64Array>),
        Float32Array(MayBeNull<crate::term::Float32Array>),
        Float64Array(MayBeNull<crate::term::Float64Array>),
        FrozenArrayType(MayBeNull<FrozenArrayType<'a>>),
        ObservableArrayType(MayBeNull<ObservableArrayType<'a>>),
        RecordType(MayBeNull<RecordType<'a>>),
        Undefined(MayBeNull<crate::term::Undefined>),
        Identifier(MayBeNull<Identifier<'a>>),
    }
    impl<'a> crate::Parse<'a> for DistinguishableType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <MayBeNull<IntegerType> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Integer),
                <MayBeNull<FloatingPointType> as crate::Parse<'a>>::parse_tokens
                    .map(Self::FloatingPoint),
                nom::branch::alt((
                    <MayBeNull<crate::term::Boolean> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Boolean),
                    <MayBeNull<crate::term::Byte> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Byte),
                    nom::branch::alt((
                        <MayBeNull<crate::term::Octet> as crate::Parse<'a>>::parse_tokens
                            .map(Self::Octet),
                        <MayBeNull<
                            crate::term::Bigint,
                        > as crate::Parse<'a>>::parse_tokens
                            .map(Self::Bigint),
                        nom::branch::alt((
                            <MayBeNull<
                                crate::term::ByteString,
                            > as crate::Parse<'a>>::parse_tokens
                                .map(Self::ByteString),
                            <MayBeNull<
                                crate::term::DOMString,
                            > as crate::Parse<'a>>::parse_tokens
                                .map(Self::DOMString),
                            nom::branch::alt((
                                <MayBeNull<
                                    crate::term::USVString,
                                > as crate::Parse<'a>>::parse_tokens
                                    .map(Self::USVString),
                                <MayBeNull<
                                    SequenceType<'a>,
                                > as crate::Parse<'a>>::parse_tokens
                                    .map(Self::Sequence),
                                nom::branch::alt((
                                    <MayBeNull<
                                        crate::term::Object,
                                    > as crate::Parse<'a>>::parse_tokens
                                        .map(Self::Object),
                                    <MayBeNull<
                                        crate::term::Symbol,
                                    > as crate::Parse<'a>>::parse_tokens
                                        .map(Self::Symbol),
                                    nom::branch::alt((
                                        <MayBeNull<
                                            crate::term::ArrayBuffer,
                                        > as crate::Parse<'a>>::parse_tokens
                                            .map(Self::ArrayBuffer),
                                        <MayBeNull<
                                            crate::term::DataView,
                                        > as crate::Parse<'a>>::parse_tokens
                                            .map(Self::DataView),
                                        nom::branch::alt((
                                            <MayBeNull<
                                                crate::term::Int8Array,
                                            > as crate::Parse<'a>>::parse_tokens
                                                .map(Self::Int8Array),
                                            <MayBeNull<
                                                crate::term::Int16Array,
                                            > as crate::Parse<'a>>::parse_tokens
                                                .map(Self::Int16Array),
                                            nom::branch::alt((
                                                <MayBeNull<
                                                    crate::term::Int32Array,
                                                > as crate::Parse<'a>>::parse_tokens
                                                    .map(Self::Int32Array),
                                                <MayBeNull<
                                                    crate::term::Uint8Array,
                                                > as crate::Parse<'a>>::parse_tokens
                                                    .map(Self::Uint8Array),
                                                nom::branch::alt((
                                                    <MayBeNull<
                                                        crate::term::Uint16Array,
                                                    > as crate::Parse<'a>>::parse_tokens
                                                        .map(Self::Uint16Array),
                                                    <MayBeNull<
                                                        crate::term::Uint32Array,
                                                    > as crate::Parse<'a>>::parse_tokens
                                                        .map(Self::Uint32Array),
                                                    nom::branch::alt((
                                                        <MayBeNull<
                                                            crate::term::Uint8ClampedArray,
                                                        > as crate::Parse<'a>>::parse_tokens
                                                            .map(Self::Uint8ClampedArray),
                                                        <MayBeNull<
                                                            crate::term::BigInt64Array,
                                                        > as crate::Parse<'a>>::parse_tokens
                                                            .map(Self::BigInt64Array),
                                                        nom::branch::alt((
                                                            <MayBeNull<
                                                                crate::term::BigUint64Array,
                                                            > as crate::Parse<'a>>::parse_tokens
                                                                .map(Self::BigUint64Array),
                                                            <MayBeNull<
                                                                crate::term::Float32Array,
                                                            > as crate::Parse<'a>>::parse_tokens
                                                                .map(Self::Float32Array),
                                                            nom::branch::alt((
                                                                <MayBeNull<
                                                                    crate::term::Float64Array,
                                                                > as crate::Parse<'a>>::parse_tokens
                                                                    .map(Self::Float64Array),
                                                                <MayBeNull<
                                                                    FrozenArrayType<'a>,
                                                                > as crate::Parse<'a>>::parse_tokens
                                                                    .map(Self::FrozenArrayType),
                                                                nom::branch::alt((
                                                                    <MayBeNull<
                                                                        ObservableArrayType<'a>,
                                                                    > as crate::Parse<'a>>::parse_tokens
                                                                        .map(Self::ObservableArrayType),
                                                                    <MayBeNull<
                                                                        RecordType<'a>,
                                                                    > as crate::Parse<'a>>::parse_tokens
                                                                        .map(Self::RecordType),
                                                                    nom::branch::alt((
                                                                        <MayBeNull<
                                                                            crate::term::Undefined,
                                                                        > as crate::Parse<'a>>::parse_tokens
                                                                            .map(Self::Undefined),
                                                                        <MayBeNull<
                                                                            Identifier<'a>,
                                                                        > as crate::Parse<'a>>::parse_tokens
                                                                            .map(Self::Identifier),
                                                                    )),
                                                                )),
                                                            )),
                                                        )),
                                                    )),
                                                )),
                                            )),
                                        )),
                                    )),
                                )),
                            )),
                        )),
                    )),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for DistinguishableType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DistinguishableType<'a> {
        #[inline]
        fn clone(&self) -> DistinguishableType<'a> {
            match self {
                DistinguishableType::Integer(__self_0) => {
                    DistinguishableType::Integer(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::FloatingPoint(__self_0) => {
                    DistinguishableType::FloatingPoint(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Boolean(__self_0) => {
                    DistinguishableType::Boolean(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Byte(__self_0) => {
                    DistinguishableType::Byte(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Octet(__self_0) => {
                    DistinguishableType::Octet(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Bigint(__self_0) => {
                    DistinguishableType::Bigint(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::ByteString(__self_0) => {
                    DistinguishableType::ByteString(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::DOMString(__self_0) => {
                    DistinguishableType::DOMString(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::USVString(__self_0) => {
                    DistinguishableType::USVString(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Sequence(__self_0) => {
                    DistinguishableType::Sequence(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Object(__self_0) => {
                    DistinguishableType::Object(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Symbol(__self_0) => {
                    DistinguishableType::Symbol(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::ArrayBuffer(__self_0) => {
                    DistinguishableType::ArrayBuffer(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::DataView(__self_0) => {
                    DistinguishableType::DataView(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Int8Array(__self_0) => {
                    DistinguishableType::Int8Array(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Int16Array(__self_0) => {
                    DistinguishableType::Int16Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Int32Array(__self_0) => {
                    DistinguishableType::Int32Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Uint8Array(__self_0) => {
                    DistinguishableType::Uint8Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Uint16Array(__self_0) => {
                    DistinguishableType::Uint16Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Uint32Array(__self_0) => {
                    DistinguishableType::Uint32Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Uint8ClampedArray(__self_0) => {
                    DistinguishableType::Uint8ClampedArray(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::BigInt64Array(__self_0) => {
                    DistinguishableType::BigInt64Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::BigUint64Array(__self_0) => {
                    DistinguishableType::BigUint64Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Float32Array(__self_0) => {
                    DistinguishableType::Float32Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Float64Array(__self_0) => {
                    DistinguishableType::Float64Array(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::FrozenArrayType(__self_0) => {
                    DistinguishableType::FrozenArrayType(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::ObservableArrayType(__self_0) => {
                    DistinguishableType::ObservableArrayType(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::RecordType(__self_0) => {
                    DistinguishableType::RecordType(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DistinguishableType::Undefined(__self_0) => {
                    DistinguishableType::Undefined(::core::clone::Clone::clone(__self_0))
                }
                DistinguishableType::Identifier(__self_0) => {
                    DistinguishableType::Identifier(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DistinguishableType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DistinguishableType::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                DistinguishableType::FloatingPoint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FloatingPoint",
                        &__self_0,
                    )
                }
                DistinguishableType::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                DistinguishableType::Byte(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Byte",
                        &__self_0,
                    )
                }
                DistinguishableType::Octet(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Octet",
                        &__self_0,
                    )
                }
                DistinguishableType::Bigint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bigint",
                        &__self_0,
                    )
                }
                DistinguishableType::ByteString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ByteString",
                        &__self_0,
                    )
                }
                DistinguishableType::DOMString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DOMString",
                        &__self_0,
                    )
                }
                DistinguishableType::USVString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "USVString",
                        &__self_0,
                    )
                }
                DistinguishableType::Sequence(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sequence",
                        &__self_0,
                    )
                }
                DistinguishableType::Object(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Object",
                        &__self_0,
                    )
                }
                DistinguishableType::Symbol(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Symbol",
                        &__self_0,
                    )
                }
                DistinguishableType::ArrayBuffer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ArrayBuffer",
                        &__self_0,
                    )
                }
                DistinguishableType::DataView(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DataView",
                        &__self_0,
                    )
                }
                DistinguishableType::Int8Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int8Array",
                        &__self_0,
                    )
                }
                DistinguishableType::Int16Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int16Array",
                        &__self_0,
                    )
                }
                DistinguishableType::Int32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int32Array",
                        &__self_0,
                    )
                }
                DistinguishableType::Uint8Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint8Array",
                        &__self_0,
                    )
                }
                DistinguishableType::Uint16Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint16Array",
                        &__self_0,
                    )
                }
                DistinguishableType::Uint32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint32Array",
                        &__self_0,
                    )
                }
                DistinguishableType::Uint8ClampedArray(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint8ClampedArray",
                        &__self_0,
                    )
                }
                DistinguishableType::BigInt64Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BigInt64Array",
                        &__self_0,
                    )
                }
                DistinguishableType::BigUint64Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BigUint64Array",
                        &__self_0,
                    )
                }
                DistinguishableType::Float32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float32Array",
                        &__self_0,
                    )
                }
                DistinguishableType::Float64Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float64Array",
                        &__self_0,
                    )
                }
                DistinguishableType::FrozenArrayType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FrozenArrayType",
                        &__self_0,
                    )
                }
                DistinguishableType::ObservableArrayType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ObservableArrayType",
                        &__self_0,
                    )
                }
                DistinguishableType::RecordType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RecordType",
                        &__self_0,
                    )
                }
                DistinguishableType::Undefined(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Undefined",
                        &__self_0,
                    )
                }
                DistinguishableType::Identifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Identifier",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DistinguishableType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DistinguishableType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<IntegerType>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<FloatingPointType>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Boolean>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Byte>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Octet>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Bigint>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::ByteString>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::DOMString>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::USVString>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<SequenceType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Object>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Symbol>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::ArrayBuffer>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::DataView>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Int8Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Int16Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Int32Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Uint8Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Uint16Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Uint32Array>>;
            let _: ::core::cmp::AssertParamIsEq<
                MayBeNull<crate::term::Uint8ClampedArray>,
            >;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::BigInt64Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::BigUint64Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Float32Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Float64Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<FrozenArrayType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<ObservableArrayType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<RecordType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Undefined>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<Identifier<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DistinguishableType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DistinguishableType<'a> {
        #[inline]
        fn eq(&self, other: &DistinguishableType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        DistinguishableType::Integer(__self_0),
                        DistinguishableType::Integer(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::FloatingPoint(__self_0),
                        DistinguishableType::FloatingPoint(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Boolean(__self_0),
                        DistinguishableType::Boolean(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Byte(__self_0),
                        DistinguishableType::Byte(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Octet(__self_0),
                        DistinguishableType::Octet(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Bigint(__self_0),
                        DistinguishableType::Bigint(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::ByteString(__self_0),
                        DistinguishableType::ByteString(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::DOMString(__self_0),
                        DistinguishableType::DOMString(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::USVString(__self_0),
                        DistinguishableType::USVString(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Sequence(__self_0),
                        DistinguishableType::Sequence(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Object(__self_0),
                        DistinguishableType::Object(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Symbol(__self_0),
                        DistinguishableType::Symbol(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::ArrayBuffer(__self_0),
                        DistinguishableType::ArrayBuffer(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::DataView(__self_0),
                        DistinguishableType::DataView(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Int8Array(__self_0),
                        DistinguishableType::Int8Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Int16Array(__self_0),
                        DistinguishableType::Int16Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Int32Array(__self_0),
                        DistinguishableType::Int32Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Uint8Array(__self_0),
                        DistinguishableType::Uint8Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Uint16Array(__self_0),
                        DistinguishableType::Uint16Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Uint32Array(__self_0),
                        DistinguishableType::Uint32Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Uint8ClampedArray(__self_0),
                        DistinguishableType::Uint8ClampedArray(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::BigInt64Array(__self_0),
                        DistinguishableType::BigInt64Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::BigUint64Array(__self_0),
                        DistinguishableType::BigUint64Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Float32Array(__self_0),
                        DistinguishableType::Float32Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Float64Array(__self_0),
                        DistinguishableType::Float64Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::FrozenArrayType(__self_0),
                        DistinguishableType::FrozenArrayType(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::ObservableArrayType(__self_0),
                        DistinguishableType::ObservableArrayType(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::RecordType(__self_0),
                        DistinguishableType::RecordType(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Undefined(__self_0),
                        DistinguishableType::Undefined(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DistinguishableType::Identifier(__self_0),
                        DistinguishableType::Identifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DistinguishableType<'a> {
        #[inline]
        fn cmp(&self, other: &DistinguishableType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            DistinguishableType::Integer(__self_0),
                            DistinguishableType::Integer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::FloatingPoint(__self_0),
                            DistinguishableType::FloatingPoint(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Boolean(__self_0),
                            DistinguishableType::Boolean(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Byte(__self_0),
                            DistinguishableType::Byte(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Octet(__self_0),
                            DistinguishableType::Octet(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Bigint(__self_0),
                            DistinguishableType::Bigint(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::ByteString(__self_0),
                            DistinguishableType::ByteString(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::DOMString(__self_0),
                            DistinguishableType::DOMString(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::USVString(__self_0),
                            DistinguishableType::USVString(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Sequence(__self_0),
                            DistinguishableType::Sequence(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Object(__self_0),
                            DistinguishableType::Object(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Symbol(__self_0),
                            DistinguishableType::Symbol(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::ArrayBuffer(__self_0),
                            DistinguishableType::ArrayBuffer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::DataView(__self_0),
                            DistinguishableType::DataView(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Int8Array(__self_0),
                            DistinguishableType::Int8Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Int16Array(__self_0),
                            DistinguishableType::Int16Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Int32Array(__self_0),
                            DistinguishableType::Int32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Uint8Array(__self_0),
                            DistinguishableType::Uint8Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Uint16Array(__self_0),
                            DistinguishableType::Uint16Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Uint32Array(__self_0),
                            DistinguishableType::Uint32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Uint8ClampedArray(__self_0),
                            DistinguishableType::Uint8ClampedArray(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::BigInt64Array(__self_0),
                            DistinguishableType::BigInt64Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::BigUint64Array(__self_0),
                            DistinguishableType::BigUint64Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Float32Array(__self_0),
                            DistinguishableType::Float32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Float64Array(__self_0),
                            DistinguishableType::Float64Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::FrozenArrayType(__self_0),
                            DistinguishableType::FrozenArrayType(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::ObservableArrayType(__self_0),
                            DistinguishableType::ObservableArrayType(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::RecordType(__self_0),
                            DistinguishableType::RecordType(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Undefined(__self_0),
                            DistinguishableType::Undefined(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Identifier(__self_0),
                            DistinguishableType::Identifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DistinguishableType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DistinguishableType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            DistinguishableType::Integer(__self_0),
                            DistinguishableType::Integer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::FloatingPoint(__self_0),
                            DistinguishableType::FloatingPoint(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Boolean(__self_0),
                            DistinguishableType::Boolean(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Byte(__self_0),
                            DistinguishableType::Byte(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Octet(__self_0),
                            DistinguishableType::Octet(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Bigint(__self_0),
                            DistinguishableType::Bigint(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::ByteString(__self_0),
                            DistinguishableType::ByteString(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::DOMString(__self_0),
                            DistinguishableType::DOMString(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::USVString(__self_0),
                            DistinguishableType::USVString(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Sequence(__self_0),
                            DistinguishableType::Sequence(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Object(__self_0),
                            DistinguishableType::Object(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Symbol(__self_0),
                            DistinguishableType::Symbol(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::ArrayBuffer(__self_0),
                            DistinguishableType::ArrayBuffer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::DataView(__self_0),
                            DistinguishableType::DataView(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Int8Array(__self_0),
                            DistinguishableType::Int8Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Int16Array(__self_0),
                            DistinguishableType::Int16Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Int32Array(__self_0),
                            DistinguishableType::Int32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Uint8Array(__self_0),
                            DistinguishableType::Uint8Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Uint16Array(__self_0),
                            DistinguishableType::Uint16Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Uint32Array(__self_0),
                            DistinguishableType::Uint32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Uint8ClampedArray(__self_0),
                            DistinguishableType::Uint8ClampedArray(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::BigInt64Array(__self_0),
                            DistinguishableType::BigInt64Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::BigUint64Array(__self_0),
                            DistinguishableType::BigUint64Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Float32Array(__self_0),
                            DistinguishableType::Float32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Float64Array(__self_0),
                            DistinguishableType::Float64Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::FrozenArrayType(__self_0),
                            DistinguishableType::FrozenArrayType(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::ObservableArrayType(__self_0),
                            DistinguishableType::ObservableArrayType(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::RecordType(__self_0),
                            DistinguishableType::RecordType(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Undefined(__self_0),
                            DistinguishableType::Undefined(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DistinguishableType::Identifier(__self_0),
                            DistinguishableType::Identifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DistinguishableType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                DistinguishableType::Integer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::FloatingPoint(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Boolean(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Byte(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Octet(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Bigint(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::ByteString(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::DOMString(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::USVString(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Sequence(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Object(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Symbol(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::ArrayBuffer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::DataView(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Int8Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Int16Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Int32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Uint8Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Uint16Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Uint32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Uint8ClampedArray(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::BigInt64Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::BigUint64Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Float32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Float64Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::FrozenArrayType(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::ObservableArrayType(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::RecordType(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Undefined(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DistinguishableType::Identifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses `sequence<Type>`
    pub struct SequenceType<'a> {
        pub sequence: crate::term::Sequence,
        pub generics: Generics<Box<AttributedType<'a>>>,
    }
    impl<'a> crate::Parse<'a> for SequenceType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, sequence) = <crate::term::Sequence as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                Box<AttributedType<'a>>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { sequence, generics }))
        }
    }
    impl<'a> crate::ParsePost<'a> for SequenceType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SequenceType<'a> {
        #[inline]
        fn clone(&self) -> SequenceType<'a> {
            SequenceType {
                sequence: ::core::clone::Clone::clone(&self.sequence),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SequenceType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "SequenceType",
                "sequence",
                &&self.sequence,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SequenceType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SequenceType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Sequence>;
            let _: ::core::cmp::AssertParamIsEq<Generics<Box<AttributedType<'a>>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SequenceType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SequenceType<'a> {
        #[inline]
        fn eq(&self, other: &SequenceType<'a>) -> bool {
            self.sequence == other.sequence && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SequenceType<'a> {
        #[inline]
        fn cmp(&self, other: &SequenceType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.sequence, &other.sequence) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SequenceType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SequenceType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.sequence, &other.sequence) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SequenceType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.sequence, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    /// Parses `FrozenArray<Type>`
    pub struct FrozenArrayType<'a> {
        pub frozen_array: crate::term::FrozenArray,
        pub generics: Generics<Box<AttributedType<'a>>>,
    }
    impl<'a> crate::Parse<'a> for FrozenArrayType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, frozen_array) = <crate::term::FrozenArray as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                Box<AttributedType<'a>>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { frozen_array, generics }))
        }
    }
    impl<'a> crate::ParsePost<'a> for FrozenArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for FrozenArrayType<'a> {
        #[inline]
        fn clone(&self) -> FrozenArrayType<'a> {
            FrozenArrayType {
                frozen_array: ::core::clone::Clone::clone(&self.frozen_array),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for FrozenArrayType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FrozenArrayType",
                "frozen_array",
                &&self.frozen_array,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for FrozenArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for FrozenArrayType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::FrozenArray>;
            let _: ::core::cmp::AssertParamIsEq<Generics<Box<AttributedType<'a>>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for FrozenArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for FrozenArrayType<'a> {
        #[inline]
        fn eq(&self, other: &FrozenArrayType<'a>) -> bool {
            self.frozen_array == other.frozen_array && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for FrozenArrayType<'a> {
        #[inline]
        fn cmp(&self, other: &FrozenArrayType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.frozen_array, &other.frozen_array) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for FrozenArrayType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FrozenArrayType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.frozen_array,
                &other.frozen_array,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for FrozenArrayType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.frozen_array, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    /// Parses `ObservableArray<Type>`
    pub struct ObservableArrayType<'a> {
        pub observable_array: crate::term::ObservableArray,
        pub generics: Generics<Box<AttributedType<'a>>>,
    }
    impl<'a> crate::Parse<'a> for ObservableArrayType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, observable_array) = <crate::term::ObservableArray as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                Box<AttributedType<'a>>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { observable_array, generics }))
        }
    }
    impl<'a> crate::ParsePost<'a> for ObservableArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ObservableArrayType<'a> {
        #[inline]
        fn clone(&self) -> ObservableArrayType<'a> {
            ObservableArrayType {
                observable_array: ::core::clone::Clone::clone(&self.observable_array),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ObservableArrayType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ObservableArrayType",
                "observable_array",
                &&self.observable_array,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ObservableArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ObservableArrayType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::ObservableArray>;
            let _: ::core::cmp::AssertParamIsEq<Generics<Box<AttributedType<'a>>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ObservableArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ObservableArrayType<'a> {
        #[inline]
        fn eq(&self, other: &ObservableArrayType<'a>) -> bool {
            self.observable_array == other.observable_array
                && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ObservableArrayType<'a> {
        #[inline]
        fn cmp(&self, other: &ObservableArrayType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(
                &self.observable_array,
                &other.observable_array,
            ) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ObservableArrayType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ObservableArrayType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.observable_array,
                &other.observable_array,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ObservableArrayType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.observable_array, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    /// Parses a nullable type. Ex: `object | object??`
    ///
    /// `??` means an actual ? not an optional requirement
    #[weedle(impl_bound = "where T: Parse<'a>")]
    pub struct MayBeNull<T> {
        pub type_: T,
        pub q_mark: Option<term::QMark>,
    }
    impl<'a, T> crate::Parse<'a> for MayBeNull<T>
    where
        T: Parse<'a>,
    {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, type_) = <T as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, q_mark) = <Option<
                term::QMark,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { type_, q_mark }))
        }
    }
    impl<'a, T> crate::ParsePost<'a> for MayBeNull<T>
    where
        T: Parse<'a>,
    {}
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for MayBeNull<T> {}
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for MayBeNull<T> {
        #[inline]
        fn clone(&self) -> MayBeNull<T> {
            MayBeNull {
                type_: ::core::clone::Clone::clone(&self.type_),
                q_mark: ::core::clone::Clone::clone(&self.q_mark),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for MayBeNull<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "MayBeNull",
                "type_",
                &&self.type_,
                "q_mark",
                &&self.q_mark,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for MayBeNull<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for MayBeNull<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<Option<term::QMark>>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for MayBeNull<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for MayBeNull<T> {
        #[inline]
        fn eq(&self, other: &MayBeNull<T>) -> bool {
            self.type_ == other.type_ && self.q_mark == other.q_mark
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for MayBeNull<T> {
        #[inline]
        fn cmp(&self, other: &MayBeNull<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.q_mark, &other.q_mark)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for MayBeNull<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MayBeNull<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.type_, &other.type_) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.q_mark, &other.q_mark)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for MayBeNull<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.q_mark, state)
        }
    }
    /// Parses a `Promise<Type|undefined>` type
    pub struct PromiseType<'a> {
        pub promise: crate::term::Promise,
        pub generics: Generics<Box<Type<'a>>>,
    }
    impl<'a> crate::Parse<'a> for PromiseType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, promise) = <crate::term::Promise as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                Box<Type<'a>>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { promise, generics }))
        }
    }
    impl<'a> crate::ParsePost<'a> for PromiseType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for PromiseType<'a> {
        #[inline]
        fn clone(&self) -> PromiseType<'a> {
            PromiseType {
                promise: ::core::clone::Clone::clone(&self.promise),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for PromiseType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "PromiseType",
                "promise",
                &&self.promise,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for PromiseType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for PromiseType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Promise>;
            let _: ::core::cmp::AssertParamIsEq<Generics<Box<Type<'a>>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for PromiseType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for PromiseType<'a> {
        #[inline]
        fn eq(&self, other: &PromiseType<'a>) -> bool {
            self.promise == other.promise && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for PromiseType<'a> {
        #[inline]
        fn cmp(&self, other: &PromiseType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.promise, &other.promise) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for PromiseType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &PromiseType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.promise, &other.promise) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for PromiseType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.promise, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    /// Parses `unsigned? long long`
    pub struct LongLongType {
        pub unsigned: Option<crate::term::Unsigned>,
        pub long_long: (crate::term::Long, crate::term::Long),
    }
    impl<'a> crate::Parse<'a> for LongLongType {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, unsigned) = <Option<
                crate::term::Unsigned,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, long_long) = <(
                crate::term::Long,
                crate::term::Long,
            ) as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { unsigned, long_long }))
        }
    }
    impl<'a> crate::ParsePost<'a> for LongLongType {}
    #[automatically_derived]
    impl ::core::marker::Copy for LongLongType {}
    #[automatically_derived]
    impl ::core::clone::Clone for LongLongType {
        #[inline]
        fn clone(&self) -> LongLongType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unsigned>>;
            let _: ::core::clone::AssertParamIsClone<
                (crate::term::Long, crate::term::Long),
            >;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LongLongType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "LongLongType",
                "unsigned",
                &&self.unsigned,
                "long_long",
                &&self.long_long,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for LongLongType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for LongLongType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unsigned>>;
            let _: ::core::cmp::AssertParamIsEq<(crate::term::Long, crate::term::Long)>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LongLongType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LongLongType {
        #[inline]
        fn eq(&self, other: &LongLongType) -> bool {
            self.unsigned == other.unsigned && self.long_long == other.long_long
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for LongLongType {
        #[inline]
        fn cmp(&self, other: &LongLongType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unsigned, &other.unsigned) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.long_long, &other.long_long)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for LongLongType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &LongLongType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.unsigned, &other.unsigned) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.long_long,
                        &other.long_long,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for LongLongType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unsigned, state);
            ::core::hash::Hash::hash(&self.long_long, state)
        }
    }
    /// Parses `unsigned? long`
    pub struct LongType {
        pub unsigned: Option<crate::term::Unsigned>,
        pub long: crate::term::Long,
    }
    impl<'a> crate::Parse<'a> for LongType {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, unsigned) = <Option<
                crate::term::Unsigned,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, long) = <crate::term::Long as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((input, Self { unsigned, long }))
        }
    }
    impl<'a> crate::ParsePost<'a> for LongType {}
    #[automatically_derived]
    impl ::core::marker::Copy for LongType {}
    #[automatically_derived]
    impl ::core::clone::Clone for LongType {
        #[inline]
        fn clone(&self) -> LongType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unsigned>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Long>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LongType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "LongType",
                "unsigned",
                &&self.unsigned,
                "long",
                &&self.long,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for LongType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for LongType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unsigned>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Long>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LongType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LongType {
        #[inline]
        fn eq(&self, other: &LongType) -> bool {
            self.unsigned == other.unsigned && self.long == other.long
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for LongType {
        #[inline]
        fn cmp(&self, other: &LongType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unsigned, &other.unsigned) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.long, &other.long)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for LongType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &LongType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.unsigned, &other.unsigned) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.long, &other.long)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for LongType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unsigned, state);
            ::core::hash::Hash::hash(&self.long, state)
        }
    }
    /// Parses `unsigned? short`
    pub struct ShortType {
        pub unsigned: Option<crate::term::Unsigned>,
        pub short: crate::term::Short,
    }
    impl<'a> crate::Parse<'a> for ShortType {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, unsigned) = <Option<
                crate::term::Unsigned,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, short) = <crate::term::Short as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((input, Self { unsigned, short }))
        }
    }
    impl<'a> crate::ParsePost<'a> for ShortType {}
    #[automatically_derived]
    impl ::core::marker::Copy for ShortType {}
    #[automatically_derived]
    impl ::core::clone::Clone for ShortType {
        #[inline]
        fn clone(&self) -> ShortType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unsigned>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Short>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ShortType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ShortType",
                "unsigned",
                &&self.unsigned,
                "short",
                &&self.short,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ShortType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ShortType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unsigned>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Short>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ShortType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ShortType {
        #[inline]
        fn eq(&self, other: &ShortType) -> bool {
            self.unsigned == other.unsigned && self.short == other.short
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ShortType {
        #[inline]
        fn cmp(&self, other: &ShortType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unsigned, &other.unsigned) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.short, &other.short)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ShortType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ShortType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.unsigned, &other.unsigned) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.short, &other.short)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ShortType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unsigned, state);
            ::core::hash::Hash::hash(&self.short, state)
        }
    }
    /// Parses `unsigned? short|long|(long long)`
    pub enum IntegerType {
        LongLong(LongLongType),
        Long(LongType),
        Short(ShortType),
    }
    impl<'a> crate::Parse<'a> for IntegerType {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <LongLongType as crate::Parse<'a>>::parse_tokens.map(Self::LongLong),
                <LongType as crate::Parse<'a>>::parse_tokens.map(Self::Long),
                <ShortType as crate::Parse<'a>>::parse_tokens.map(Self::Short),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for IntegerType {}
    #[automatically_derived]
    impl ::core::marker::Copy for IntegerType {}
    #[automatically_derived]
    impl ::core::clone::Clone for IntegerType {
        #[inline]
        fn clone(&self) -> IntegerType {
            let _: ::core::clone::AssertParamIsClone<LongLongType>;
            let _: ::core::clone::AssertParamIsClone<LongType>;
            let _: ::core::clone::AssertParamIsClone<ShortType>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IntegerType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                IntegerType::LongLong(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LongLong",
                        &__self_0,
                    )
                }
                IntegerType::Long(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Long",
                        &__self_0,
                    )
                }
                IntegerType::Short(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Short",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for IntegerType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for IntegerType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<LongLongType>;
            let _: ::core::cmp::AssertParamIsEq<LongType>;
            let _: ::core::cmp::AssertParamIsEq<ShortType>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IntegerType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IntegerType {
        #[inline]
        fn eq(&self, other: &IntegerType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        IntegerType::LongLong(__self_0),
                        IntegerType::LongLong(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (IntegerType::Long(__self_0), IntegerType::Long(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (IntegerType::Short(__self_0), IntegerType::Short(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for IntegerType {
        #[inline]
        fn cmp(&self, other: &IntegerType) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            IntegerType::LongLong(__self_0),
                            IntegerType::LongLong(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (IntegerType::Long(__self_0), IntegerType::Long(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (IntegerType::Short(__self_0), IntegerType::Short(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for IntegerType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &IntegerType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            IntegerType::LongLong(__self_0),
                            IntegerType::LongLong(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (IntegerType::Long(__self_0), IntegerType::Long(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (IntegerType::Short(__self_0), IntegerType::Short(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for IntegerType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                IntegerType::LongLong(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                IntegerType::Long(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                IntegerType::Short(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    /// Parses `unrestricted? float`
    pub struct FloatType {
        pub unrestricted: Option<crate::term::Unrestricted>,
        pub float: crate::term::Float,
    }
    impl<'a> crate::Parse<'a> for FloatType {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, unrestricted) = <Option<
                crate::term::Unrestricted,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, float) = <crate::term::Float as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((input, Self { unrestricted, float }))
        }
    }
    impl<'a> crate::ParsePost<'a> for FloatType {}
    #[automatically_derived]
    impl ::core::marker::Copy for FloatType {}
    #[automatically_derived]
    impl ::core::clone::Clone for FloatType {
        #[inline]
        fn clone(&self) -> FloatType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unrestricted>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Float>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FloatType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FloatType",
                "unrestricted",
                &&self.unrestricted,
                "float",
                &&self.float,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FloatType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FloatType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unrestricted>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Float>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FloatType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FloatType {
        #[inline]
        fn eq(&self, other: &FloatType) -> bool {
            self.unrestricted == other.unrestricted && self.float == other.float
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FloatType {
        #[inline]
        fn cmp(&self, other: &FloatType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unrestricted, &other.unrestricted) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.float, &other.float)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FloatType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FloatType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.unrestricted,
                &other.unrestricted,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.float, &other.float)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FloatType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unrestricted, state);
            ::core::hash::Hash::hash(&self.float, state)
        }
    }
    /// Parses `unrestricted? double`
    pub struct DoubleType {
        pub unrestricted: Option<crate::term::Unrestricted>,
        pub double: crate::term::Double,
    }
    impl<'a> crate::Parse<'a> for DoubleType {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, unrestricted) = <Option<
                crate::term::Unrestricted,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, double) = <crate::term::Double as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            Ok((input, Self { unrestricted, double }))
        }
    }
    impl<'a> crate::ParsePost<'a> for DoubleType {}
    #[automatically_derived]
    impl ::core::marker::Copy for DoubleType {}
    #[automatically_derived]
    impl ::core::clone::Clone for DoubleType {
        #[inline]
        fn clone(&self) -> DoubleType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unrestricted>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Double>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DoubleType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "DoubleType",
                "unrestricted",
                &&self.unrestricted,
                "double",
                &&self.double,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DoubleType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DoubleType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unrestricted>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Double>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DoubleType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DoubleType {
        #[inline]
        fn eq(&self, other: &DoubleType) -> bool {
            self.unrestricted == other.unrestricted && self.double == other.double
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DoubleType {
        #[inline]
        fn cmp(&self, other: &DoubleType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unrestricted, &other.unrestricted) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.double, &other.double)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DoubleType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DoubleType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.unrestricted,
                &other.unrestricted,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.double, &other.double)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DoubleType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unrestricted, state);
            ::core::hash::Hash::hash(&self.double, state)
        }
    }
    /// Parses `unrestricted? float|double`
    pub enum FloatingPointType {
        Float(FloatType),
        Double(DoubleType),
    }
    impl<'a> crate::Parse<'a> for FloatingPointType {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <FloatType as crate::Parse<'a>>::parse_tokens.map(Self::Float),
                <DoubleType as crate::Parse<'a>>::parse_tokens.map(Self::Double),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for FloatingPointType {}
    #[automatically_derived]
    impl ::core::marker::Copy for FloatingPointType {}
    #[automatically_derived]
    impl ::core::clone::Clone for FloatingPointType {
        #[inline]
        fn clone(&self) -> FloatingPointType {
            let _: ::core::clone::AssertParamIsClone<FloatType>;
            let _: ::core::clone::AssertParamIsClone<DoubleType>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FloatingPointType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FloatingPointType::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                FloatingPointType::Double(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Double",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FloatingPointType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FloatingPointType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<FloatType>;
            let _: ::core::cmp::AssertParamIsEq<DoubleType>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FloatingPointType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FloatingPointType {
        #[inline]
        fn eq(&self, other: &FloatingPointType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        FloatingPointType::Float(__self_0),
                        FloatingPointType::Float(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        FloatingPointType::Double(__self_0),
                        FloatingPointType::Double(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FloatingPointType {
        #[inline]
        fn cmp(&self, other: &FloatingPointType) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            FloatingPointType::Float(__self_0),
                            FloatingPointType::Float(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            FloatingPointType::Double(__self_0),
                            FloatingPointType::Double(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FloatingPointType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FloatingPointType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            FloatingPointType::Float(__self_0),
                            FloatingPointType::Float(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            FloatingPointType::Double(__self_0),
                            FloatingPointType::Double(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FloatingPointType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                FloatingPointType::Float(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                FloatingPointType::Double(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses `record<StringType, Type>`
    pub struct RecordType<'a> {
        pub record: crate::term::Record,
        pub generics: Generics<
            (Box<RecordKeyType<'a>>, crate::term::Comma, Box<AttributedType<'a>>),
        >,
    }
    impl<'a> crate::Parse<'a> for RecordType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, record) = <crate::term::Record as crate::Parse<
                'a,
            >>::parse_tokens(input)?;
            let (input, generics) = <Generics<
                (Box<RecordKeyType<'a>>, crate::term::Comma, Box<AttributedType<'a>>),
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { record, generics }))
        }
    }
    impl<'a> crate::ParsePost<'a> for RecordType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for RecordType<'a> {
        #[inline]
        fn clone(&self) -> RecordType<'a> {
            RecordType {
                record: ::core::clone::Clone::clone(&self.record),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for RecordType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "RecordType",
                "record",
                &&self.record,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for RecordType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for RecordType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Record>;
            let _: ::core::cmp::AssertParamIsEq<
                Generics<
                    (Box<RecordKeyType<'a>>, crate::term::Comma, Box<AttributedType<'a>>),
                >,
            >;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for RecordType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for RecordType<'a> {
        #[inline]
        fn eq(&self, other: &RecordType<'a>) -> bool {
            self.record == other.record && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for RecordType<'a> {
        #[inline]
        fn cmp(&self, other: &RecordType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.record, &other.record) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for RecordType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RecordType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.record, &other.record) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for RecordType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.record, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    /// Parses one of the string types `ByteString|DOMString|USVString` or any other type.
    pub enum RecordKeyType<'a> {
        Byte(crate::term::ByteString),
        DOM(crate::term::DOMString),
        USV(crate::term::USVString),
        NonAny(DistinguishableType<'a>),
    }
    impl<'a> crate::Parse<'a> for RecordKeyType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <crate::term::ByteString as crate::Parse<'a>>::parse_tokens
                    .map(Self::Byte),
                <crate::term::DOMString as crate::Parse<'a>>::parse_tokens
                    .map(Self::DOM),
                nom::branch::alt((
                    <crate::term::USVString as crate::Parse<'a>>::parse_tokens
                        .map(Self::USV),
                    <DistinguishableType<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::NonAny),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for RecordKeyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for RecordKeyType<'a> {
        #[inline]
        fn clone(&self) -> RecordKeyType<'a> {
            match self {
                RecordKeyType::Byte(__self_0) => {
                    RecordKeyType::Byte(::core::clone::Clone::clone(__self_0))
                }
                RecordKeyType::DOM(__self_0) => {
                    RecordKeyType::DOM(::core::clone::Clone::clone(__self_0))
                }
                RecordKeyType::USV(__self_0) => {
                    RecordKeyType::USV(::core::clone::Clone::clone(__self_0))
                }
                RecordKeyType::NonAny(__self_0) => {
                    RecordKeyType::NonAny(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for RecordKeyType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                RecordKeyType::Byte(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Byte",
                        &__self_0,
                    )
                }
                RecordKeyType::DOM(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DOM",
                        &__self_0,
                    )
                }
                RecordKeyType::USV(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "USV",
                        &__self_0,
                    )
                }
                RecordKeyType::NonAny(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NonAny",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for RecordKeyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for RecordKeyType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::ByteString>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::DOMString>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::USVString>;
            let _: ::core::cmp::AssertParamIsEq<DistinguishableType<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for RecordKeyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for RecordKeyType<'a> {
        #[inline]
        fn eq(&self, other: &RecordKeyType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (RecordKeyType::Byte(__self_0), RecordKeyType::Byte(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (RecordKeyType::DOM(__self_0), RecordKeyType::DOM(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (RecordKeyType::USV(__self_0), RecordKeyType::USV(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        RecordKeyType::NonAny(__self_0),
                        RecordKeyType::NonAny(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for RecordKeyType<'a> {
        #[inline]
        fn cmp(&self, other: &RecordKeyType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            RecordKeyType::Byte(__self_0),
                            RecordKeyType::Byte(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (RecordKeyType::DOM(__self_0), RecordKeyType::DOM(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (RecordKeyType::USV(__self_0), RecordKeyType::USV(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            RecordKeyType::NonAny(__self_0),
                            RecordKeyType::NonAny(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for RecordKeyType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RecordKeyType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            RecordKeyType::Byte(__self_0),
                            RecordKeyType::Byte(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (RecordKeyType::DOM(__self_0), RecordKeyType::DOM(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (RecordKeyType::USV(__self_0), RecordKeyType::USV(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            RecordKeyType::NonAny(__self_0),
                            RecordKeyType::NonAny(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for RecordKeyType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                RecordKeyType::Byte(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                RecordKeyType::DOM(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                RecordKeyType::USV(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                RecordKeyType::NonAny(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses one of the member of a union type
    pub enum UnionMemberType<'a> {
        Single(AttributedNonAnyType<'a>),
        Union(MayBeNull<UnionType<'a>>),
    }
    impl<'a> crate::Parse<'a> for UnionMemberType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <AttributedNonAnyType<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Single),
                <MayBeNull<UnionType<'a>> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Union),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for UnionMemberType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for UnionMemberType<'a> {
        #[inline]
        fn clone(&self) -> UnionMemberType<'a> {
            match self {
                UnionMemberType::Single(__self_0) => {
                    UnionMemberType::Single(::core::clone::Clone::clone(__self_0))
                }
                UnionMemberType::Union(__self_0) => {
                    UnionMemberType::Union(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for UnionMemberType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UnionMemberType::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                UnionMemberType::Union(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Union",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for UnionMemberType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for UnionMemberType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<AttributedNonAnyType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<UnionType<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for UnionMemberType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for UnionMemberType<'a> {
        #[inline]
        fn eq(&self, other: &UnionMemberType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        UnionMemberType::Single(__self_0),
                        UnionMemberType::Single(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        UnionMemberType::Union(__self_0),
                        UnionMemberType::Union(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for UnionMemberType<'a> {
        #[inline]
        fn cmp(&self, other: &UnionMemberType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            UnionMemberType::Single(__self_0),
                            UnionMemberType::Single(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            UnionMemberType::Union(__self_0),
                            UnionMemberType::Union(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for UnionMemberType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UnionMemberType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            UnionMemberType::Single(__self_0),
                            UnionMemberType::Single(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            UnionMemberType::Union(__self_0),
                            UnionMemberType::Union(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for UnionMemberType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                UnionMemberType::Single(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                UnionMemberType::Union(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses a const type
    pub enum ConstType<'a> {
        Integer(IntegerType),
        FloatingPoint(FloatingPointType),
        Boolean(crate::term::Boolean),
        Byte(crate::term::Byte),
        Octet(crate::term::Octet),
        Bigint(crate::term::Bigint),
        Identifier(Identifier<'a>),
    }
    impl<'a> crate::Parse<'a> for ConstType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::Parser;
            nom::branch::alt((
                <IntegerType as crate::Parse<'a>>::parse_tokens.map(Self::Integer),
                <FloatingPointType as crate::Parse<'a>>::parse_tokens
                    .map(Self::FloatingPoint),
                nom::branch::alt((
                    <crate::term::Boolean as crate::Parse<'a>>::parse_tokens
                        .map(Self::Boolean),
                    <crate::term::Byte as crate::Parse<'a>>::parse_tokens
                        .map(Self::Byte),
                    nom::branch::alt((
                        <crate::term::Octet as crate::Parse<'a>>::parse_tokens
                            .map(Self::Octet),
                        <crate::term::Bigint as crate::Parse<'a>>::parse_tokens
                            .map(Self::Bigint),
                        <Identifier<'a> as crate::Parse<'a>>::parse_tokens
                            .map(Self::Identifier),
                    )),
                )),
            ))(input)
        }
    }
    impl<'a> crate::ParsePost<'a> for ConstType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstType<'a> {
        #[inline]
        fn clone(&self) -> ConstType<'a> {
            match self {
                ConstType::Integer(__self_0) => {
                    ConstType::Integer(::core::clone::Clone::clone(__self_0))
                }
                ConstType::FloatingPoint(__self_0) => {
                    ConstType::FloatingPoint(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Boolean(__self_0) => {
                    ConstType::Boolean(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Byte(__self_0) => {
                    ConstType::Byte(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Octet(__self_0) => {
                    ConstType::Octet(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Bigint(__self_0) => {
                    ConstType::Bigint(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Identifier(__self_0) => {
                    ConstType::Identifier(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ConstType::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                ConstType::FloatingPoint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FloatingPoint",
                        &__self_0,
                    )
                }
                ConstType::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                ConstType::Byte(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Byte",
                        &__self_0,
                    )
                }
                ConstType::Octet(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Octet",
                        &__self_0,
                    )
                }
                ConstType::Bigint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bigint",
                        &__self_0,
                    )
                }
                ConstType::Identifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Identifier",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<IntegerType>;
            let _: ::core::cmp::AssertParamIsEq<FloatingPointType>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Boolean>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Byte>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Octet>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Bigint>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstType<'a> {
        #[inline]
        fn eq(&self, other: &ConstType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (ConstType::Integer(__self_0), ConstType::Integer(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        ConstType::FloatingPoint(__self_0),
                        ConstType::FloatingPoint(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (ConstType::Boolean(__self_0), ConstType::Boolean(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstType::Byte(__self_0), ConstType::Byte(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstType::Octet(__self_0), ConstType::Octet(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstType::Bigint(__self_0), ConstType::Bigint(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        ConstType::Identifier(__self_0),
                        ConstType::Identifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstType<'a> {
        #[inline]
        fn cmp(&self, other: &ConstType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (ConstType::Integer(__self_0), ConstType::Integer(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstType::FloatingPoint(__self_0),
                            ConstType::FloatingPoint(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (ConstType::Boolean(__self_0), ConstType::Boolean(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Byte(__self_0), ConstType::Byte(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Octet(__self_0), ConstType::Octet(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Bigint(__self_0), ConstType::Bigint(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstType::Identifier(__self_0),
                            ConstType::Identifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (ConstType::Integer(__self_0), ConstType::Integer(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstType::FloatingPoint(__self_0),
                            ConstType::FloatingPoint(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (ConstType::Boolean(__self_0), ConstType::Boolean(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Byte(__self_0), ConstType::Byte(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Octet(__self_0), ConstType::Octet(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Bigint(__self_0), ConstType::Bigint(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstType::Identifier(__self_0),
                            ConstType::Identifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                ConstType::Integer(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::FloatingPoint(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ConstType::Boolean(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::Byte(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::Octet(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::Bigint(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::Identifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses `[attributes]? type`
    pub struct AttributedType<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub type_: Type<'a>,
    }
    impl<'a> crate::Parse<'a> for AttributedType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, type_) = <Type<'a> as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { attributes, type_ }))
        }
    }
    impl<'a> crate::ParsePost<'a> for AttributedType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributedType<'a> {
        #[inline]
        fn clone(&self) -> AttributedType<'a> {
            AttributedType {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                type_: ::core::clone::Clone::clone(&self.type_),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributedType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "AttributedType",
                "attributes",
                &&self.attributes,
                "type_",
                &&self.type_,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributedType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributedType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributedType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributedType<'a> {
        #[inline]
        fn eq(&self, other: &AttributedType<'a>) -> bool {
            self.attributes == other.attributes && self.type_ == other.type_
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributedType<'a> {
        #[inline]
        fn cmp(&self, other: &AttributedType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.type_, &other.type_)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributedType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributedType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.type_, &other.type_)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributedType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.type_, state)
        }
    }
    /// Parses `[attributes]? type` where the type is a single non-any type
    pub struct AttributedNonAnyType<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub type_: DistinguishableType<'a>,
    }
    impl<'a> crate::Parse<'a> for AttributedNonAnyType<'a> {
        fn parse_body<'slice>(
            input: crate::tokens::Tokens<'slice, 'a>,
        ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
            use nom::lib::std::result::Result::Ok;
            let (input, attributes) = <Option<
                ExtendedAttributeList<'a>,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            let (input, type_) = <DistinguishableType<
                'a,
            > as crate::Parse<'a>>::parse_tokens(input)?;
            Ok((input, Self { attributes, type_ }))
        }
    }
    impl<'a> crate::ParsePost<'a> for AttributedNonAnyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributedNonAnyType<'a> {
        #[inline]
        fn clone(&self) -> AttributedNonAnyType<'a> {
            AttributedNonAnyType {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                type_: ::core::clone::Clone::clone(&self.type_),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributedNonAnyType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "AttributedNonAnyType",
                "attributes",
                &&self.attributes,
                "type_",
                &&self.type_,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributedNonAnyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributedNonAnyType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<DistinguishableType<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributedNonAnyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributedNonAnyType<'a> {
        #[inline]
        fn eq(&self, other: &AttributedNonAnyType<'a>) -> bool {
            self.attributes == other.attributes && self.type_ == other.type_
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributedNonAnyType<'a> {
        #[inline]
        fn cmp(&self, other: &AttributedNonAnyType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.type_, &other.type_)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributedNonAnyType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributedNonAnyType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.type_, &other.type_)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributedNonAnyType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.type_, state)
        }
    }
}
mod lexer {
    use nom::{multi::many0, sequence::tuple, Parser};
    use crate::common::Identifier;
    use crate::literal::{FloatValueLit, IntegerLit, StringLit};
    use crate::term::Keyword;
    use crate::whitespace::sp;
    pub type NomResult<'a, O> = crate::VerboseResult<&'a str, O>;
    pub enum Terminal<'a> {
        Keyword(Keyword),
        Integer(IntegerLit<'a>),
        Decimal(FloatValueLit<'a>),
        Identifier(Identifier<'a>),
        String(StringLit<'a>),
        Other(char),
        Eof(()),
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Terminal<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Terminal<'a> {
        #[inline]
        fn clone(&self) -> Terminal<'a> {
            let _: ::core::clone::AssertParamIsClone<Keyword>;
            let _: ::core::clone::AssertParamIsClone<IntegerLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<FloatValueLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<StringLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<char>;
            let _: ::core::clone::AssertParamIsClone<()>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Terminal<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Terminal::Keyword(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Keyword",
                        &__self_0,
                    )
                }
                Terminal::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                Terminal::Decimal(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Decimal",
                        &__self_0,
                    )
                }
                Terminal::Identifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Identifier",
                        &__self_0,
                    )
                }
                Terminal::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                Terminal::Other(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Other",
                        &__self_0,
                    )
                }
                Terminal::Eof(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Eof",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Terminal<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Terminal<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Keyword>;
            let _: ::core::cmp::AssertParamIsEq<IntegerLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<FloatValueLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<StringLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<char>;
            let _: ::core::cmp::AssertParamIsEq<()>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Terminal<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Terminal<'a> {
        #[inline]
        fn eq(&self, other: &Terminal<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Terminal::Keyword(__self_0), Terminal::Keyword(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Terminal::Integer(__self_0), Terminal::Integer(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Terminal::Decimal(__self_0), Terminal::Decimal(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Terminal::Identifier(__self_0), Terminal::Identifier(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Terminal::String(__self_0), Terminal::String(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Terminal::Other(__self_0), Terminal::Other(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Terminal::Eof(__self_0), Terminal::Eof(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Terminal<'a> {
        #[inline]
        fn cmp(&self, other: &Terminal<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Terminal::Keyword(__self_0), Terminal::Keyword(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Terminal::Integer(__self_0), Terminal::Integer(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Terminal::Decimal(__self_0), Terminal::Decimal(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Terminal::Identifier(__self_0),
                            Terminal::Identifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Terminal::String(__self_0), Terminal::String(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Terminal::Other(__self_0), Terminal::Other(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Terminal::Eof(__self_0), Terminal::Eof(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Terminal<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Terminal<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Terminal::Keyword(__self_0), Terminal::Keyword(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Terminal::Integer(__self_0), Terminal::Integer(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Terminal::Decimal(__self_0), Terminal::Decimal(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Terminal::Identifier(__self_0),
                            Terminal::Identifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Terminal::String(__self_0), Terminal::String(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Terminal::Other(__self_0), Terminal::Other(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Terminal::Eof(__self_0), Terminal::Eof(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Terminal<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Terminal::Keyword(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Terminal::Integer(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Terminal::Decimal(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Terminal::Identifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Terminal::String(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Terminal::Other(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Terminal::Eof(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    pub struct Token<'a> {
        pub value: Terminal<'a>,
        pub trivia: &'a str,
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Token<'a> {
        #[inline]
        fn clone(&self) -> Token<'a> {
            let _: ::core::clone::AssertParamIsClone<Terminal<'a>>;
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Token<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Token",
                "value",
                &&self.value,
                "trivia",
                &&self.trivia,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Token<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Terminal<'a>>;
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Token<'a> {
        #[inline]
        fn eq(&self, other: &Token<'a>) -> bool {
            self.value == other.value && self.trivia == other.trivia
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Token<'a> {
        #[inline]
        fn cmp(&self, other: &Token<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.value, &other.value) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.trivia, &other.trivia)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Token<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Token<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.value, &other.value) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.trivia, &other.trivia)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Token<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.value, state);
            ::core::hash::Hash::hash(&self.trivia, state)
        }
    }
    impl Token<'_> {
        pub fn new<'a>((trivia, tag): (&'a str, Terminal<'a>)) -> Token<'a> {
            Token { value: tag, trivia }
        }
    }
    fn other(input: &str) -> NomResult<char> {
        nom::character::complete::satisfy(|c| {
            !"\t\n\r ".contains(c) && !c.is_alphanumeric()
        })(input)
    }
    fn id_or_keyword(input: &str) -> NomResult<Terminal> {
        let (input, id) = Identifier::lex(input)?;
        match Keyword::match_word(id.0) {
            Some(keyword) => Ok((input, Terminal::Keyword(keyword))),
            _ => Ok((input, Terminal::Identifier(id))),
        }
    }
    fn tag(input: &str) -> NomResult<Terminal> {
        nom::branch::alt((
            FloatValueLit::lex.map(Terminal::Decimal),
            IntegerLit::lex.map(Terminal::Integer),
            StringLit::lex.map(Terminal::String),
            id_or_keyword,
            Keyword::parse_punc.map(Terminal::Keyword),
            other.map(Terminal::Other),
        ))(input)
    }
    pub fn lex(
        input: &str,
    ) -> Result<Vec<Token>, nom::Err<nom::error::VerboseError<&str>>> {
        let (unread, (mut tokens, eof)) = tuple((
            many0(tuple((sp, tag)).map(Token::new)),
            tuple((sp, nom::combinator::eof))
                .map(|(trivia, _)| Token {
                    value: Terminal::Eof(()),
                    trivia,
                }),
        ))(input)?;
        if !unread.is_empty() {
            ::core::panicking::panic("assertion failed: unread.is_empty()")
        }
        tokens.push(eof);
        Ok(tokens)
    }
}
mod tokens {
    use std::{
        iter::{Copied, Enumerate},
        ops::{Range, RangeFrom, RangeFull, RangeTo},
    };
    use nom::{InputIter, InputLength, InputTake, Needed, Slice};
    use crate::lexer::Token;
    pub struct Tokens<'slice, 'token>(pub &'slice [Token<'token>]);
    #[automatically_derived]
    impl<'slice, 'token> ::core::marker::Copy for Tokens<'slice, 'token> {}
    #[automatically_derived]
    impl<'slice, 'token> ::core::clone::Clone for Tokens<'slice, 'token> {
        #[inline]
        fn clone(&self) -> Tokens<'slice, 'token> {
            let _: ::core::clone::AssertParamIsClone<&'slice [Token<'token>]>;
            *self
        }
    }
    #[automatically_derived]
    impl<'slice, 'token> ::core::fmt::Debug for Tokens<'slice, 'token> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Tokens", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'slice, 'token> ::core::marker::StructuralEq for Tokens<'slice, 'token> {}
    #[automatically_derived]
    impl<'slice, 'token> ::core::cmp::Eq for Tokens<'slice, 'token> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'slice [Token<'token>]>;
        }
    }
    #[automatically_derived]
    impl<'slice, 'token> ::core::marker::StructuralPartialEq for Tokens<'slice, 'token> {}
    #[automatically_derived]
    impl<'slice, 'token> ::core::cmp::PartialEq for Tokens<'slice, 'token> {
        #[inline]
        fn eq(&self, other: &Tokens<'slice, 'token>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'slice, 'token> ::core::cmp::Ord for Tokens<'slice, 'token> {
        #[inline]
        fn cmp(&self, other: &Tokens<'slice, 'token>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'slice, 'token> ::core::cmp::PartialOrd for Tokens<'slice, 'token> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Tokens<'slice, 'token>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'slice, 'token> ::core::hash::Hash for Tokens<'slice, 'token> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    impl<'slice, 'token> From<Tokens<'slice, 'token>> for &'token str {
        fn from(value: Tokens<'slice, 'token>) -> Self {
            if value.0.is_empty() {
                return "";
            }
            let start_ptr = value.0[0].trivia.as_ptr();
            let end = value.0.last().unwrap().trivia;
            unsafe {
                let end_ptr = end.as_ptr().add(end.len());
                std::str::from_utf8_unchecked(
                    std::slice::from_raw_parts(
                        start_ptr,
                        end_ptr.offset_from(start_ptr) as usize,
                    ),
                )
            }
        }
    }
    impl<'slice, 'token> InputLength for Tokens<'slice, 'token> {
        #[inline]
        fn input_len(&self) -> usize {
            self.0.input_len()
        }
    }
    impl<'slice, 'token> InputTake for Tokens<'slice, 'token> {
        #[inline]
        fn take(&self, count: usize) -> Self {
            Self(&self.0[..count])
        }
        #[inline]
        fn take_split(&self, count: usize) -> (Self, Self) {
            let (prefix, suffix) = self.0.split_at(count);
            (Self(suffix), Self(prefix))
        }
    }
    impl<'a> InputLength for Token<'a> {
        #[inline]
        fn input_len(&self) -> usize {
            1
        }
    }
    impl<'slice, 'token> Slice<Range<usize>> for Tokens<'slice, 'token> {
        #[inline]
        fn slice(&self, range: Range<usize>) -> Self {
            Self(self.0.slice(range))
        }
    }
    impl<'slice, 'token> Slice<RangeTo<usize>> for Tokens<'slice, 'token> {
        #[inline]
        fn slice(&self, range: RangeTo<usize>) -> Self {
            Self(self.0.slice(range))
        }
    }
    impl<'slice, 'token> Slice<RangeFrom<usize>> for Tokens<'slice, 'token> {
        #[inline]
        fn slice(&self, range: RangeFrom<usize>) -> Self {
            Self(self.0.slice(range))
        }
    }
    impl<'slice, 'token> Slice<RangeFull> for Tokens<'slice, 'token> {
        #[inline]
        fn slice(&self, range: RangeFull) -> Self {
            Self(self.0.slice(range))
        }
    }
    impl<'slice, 'token> InputIter for Tokens<'slice, 'token> {
        type Item = Token<'token>;
        type Iter = Enumerate<Self::IterElem>;
        type IterElem = Copied<::std::slice::Iter<'slice, Token<'token>>>;
        #[inline]
        fn iter_indices(&self) -> Self::Iter {
            self.iter_elements().enumerate()
        }
        #[inline]
        fn iter_elements(&self) -> Self::IterElem {
            self.0.iter().copied()
        }
        #[inline]
        fn position<P>(&self, predicate: P) -> Option<usize>
        where
            P: Fn(Self::Item) -> bool,
        {
            self.0.iter().position(|b| predicate(*b))
        }
        #[inline]
        fn slice_index(&self, count: usize) -> Result<usize, Needed> {
            if self.0.len() >= count {
                Ok(count)
            } else {
                Err(Needed::new(count - self.0.len()))
            }
        }
    }
    pub fn nom_error_into<T, U: From<T>>(
        err: nom::Err<nom::error::VerboseError<T>>,
    ) -> nom::Err<nom::error::VerboseError<U>> {
        match err {
            nom::Err::Incomplete(need) => nom::Err::Incomplete(need),
            nom::Err::Error(err) | nom::Err::Failure(err) => {
                nom::Err::Error(nom::error::VerboseError {
                    errors: err.errors.into_iter().map(|(i, e)| (i.into(), e)).collect(),
                })
            }
        }
    }
    pub fn contextful_cut<I, O, F>(
        ctx: &'static str,
        mut parser: F,
    ) -> impl FnMut(I) -> nom::IResult<I, O, nom::error::VerboseError<I>>
    where
        F: nom::Parser<I, O, nom::error::VerboseError<I>>,
    {
        move |input: I| match parser.parse(input) {
            Err(nom::Err::Error(mut e)) => {
                e
                    .errors
                    .last_mut()
                    .unwrap()
                    .1 = nom::error::VerboseErrorKind::Context(ctx);
                Err(nom::Err::Failure(e))
            }
            rest => rest,
        }
    }
}
use lexer::lex;
use tokens::Tokens;
type VerboseResult<I, O> = nom::IResult<I, O, nom::error::VerboseError<I>>;
/// A convenient parse function
///
/// ### Example
///
/// ```
/// extern crate weedle;
///
/// let parsed = weedle::parse("
///     interface Window {
///         readonly attribute Storage sessionStorage;
///     };
/// ").unwrap();
///
/// println!("{:?}", parsed);
/// ```
pub fn parse(
    input: &'_ str,
) -> Result<Definitions<'_>, nom::Err<nom::error::VerboseError<&'_ str>>> {
    let tokens = lex(input)?;
    let (unread, (defs, _eof)) = nom::sequence::tuple((
            Definitions::parse_tokens,
            contextful_cut(
                "Unrecognized tokens",
                crate::macros::annotate(|
                    input: crate::tokens::Tokens,
                | -> crate::VerboseResult<crate::tokens::Tokens, _> {
                    use nom::{InputIter, Slice};
                    match input.iter_elements().next() {
                        Some(
                            crate::lexer::Token {
                                value: crate::lexer::Terminal::Eof(variant),
                                trivia: _,
                            },
                        ) => Ok((input.slice(1..), variant)),
                        _ => nom::combinator::fail(input),
                    }
                }),
            ),
        ))(Tokens(&tokens[..]))
        .map_err(tokens::nom_error_into)?;
    if !unread.0.is_empty() {
        ::core::panicking::panic("assertion failed: unread.0.is_empty()")
    }
    Ok(defs)
}
pub trait Parse<'token>: Sized + ParsePost<'token> {
    fn parse_tokens<'slice>(
        input: Tokens<'slice, 'token>,
    ) -> VerboseResult<Tokens<'slice, 'token>, Self> {
        nom::combinator::map(
            nom::sequence::tuple((Self::parse_body, Self::parse_post)),
            |(body, _post)| body,
        )(input)
    }
    fn parse_body<'slice>(
        input: Tokens<'slice, 'token>,
    ) -> VerboseResult<Tokens<'slice, 'token>, Self>;
    fn parse(input: &'token str) -> VerboseResult<&'token str, Self> {
        let (input, _) = whitespace::sp(input)?;
        let tokens = lex(input)?;
        let (unread, def) = Self::parse_tokens(Tokens(&tokens[..]))
            .map_err(tokens::nom_error_into)?;
        let (unread, _) = whitespace::sp(unread.into())?;
        Ok((unread, def))
    }
}
pub trait ParsePost<'token>: Sized {
    fn parse_post<'slice>(
        input: Tokens<'slice, 'token>,
    ) -> VerboseResult<Tokens<'slice, 'token>, ()> {
        nom::combinator::success(())(input)
    }
}
/// Parses WebIDL definitions. It is the root struct for a complete WebIDL definition.
///
/// ### Example
/// ```
/// use weedle::{Definitions, Parse};
///
/// let (_, parsed) = Definitions::parse("
///     interface Window {
///         readonly attribute Storage sessionStorage;
///     };
/// ").unwrap();
///
/// println!("{:?}", parsed);
/// ```
///
/// It is recommended to use [`parse`](fn.parse.html) instead.
pub type Definitions<'a> = Vec<Definition<'a>>;
/// Parses `[attributes]? callback identifier = type ( (arg1, arg2, ..., argN)? );`
pub struct CallbackDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub callback: crate::term::Callback,
    pub identifier: Identifier<'a>,
    pub assign: crate::term::Assign,
    pub return_type: Type<'a>,
    pub arguments: Parenthesized<ArgumentList<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for CallbackDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, callback) = <crate::term::Callback as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, assign) = <crate::term::Assign as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, return_type) = <Type<'a> as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, arguments) = <Parenthesized<
            ArgumentList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                callback,
                identifier,
                assign,
                return_type,
                arguments,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for CallbackDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for CallbackDefinition<'a> {
    #[inline]
    fn clone(&self) -> CallbackDefinition<'a> {
        CallbackDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            callback: ::core::clone::Clone::clone(&self.callback),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            assign: ::core::clone::Clone::clone(&self.assign),
            return_type: ::core::clone::Clone::clone(&self.return_type),
            arguments: ::core::clone::Clone::clone(&self.arguments),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for CallbackDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "callback",
            "identifier",
            "assign",
            "return_type",
            "arguments",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.callback,
            &&self.identifier,
            &&self.assign,
            &&self.return_type,
            &&self.arguments,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "CallbackDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for CallbackDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for CallbackDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Callback>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
        let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for CallbackDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for CallbackDefinition<'a> {
    #[inline]
    fn eq(&self, other: &CallbackDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.callback == other.callback
            && self.identifier == other.identifier && self.assign == other.assign
            && self.return_type == other.return_type && self.arguments == other.arguments
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for CallbackDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &CallbackDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.callback, &other.callback) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.return_type,
                                            &other.return_type,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(
                                                    &self.arguments,
                                                    &other.arguments,
                                                ) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for CallbackDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &CallbackDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.callback,
                    &other.callback,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.assign,
                                    &other.assign,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.return_type,
                                            &other.return_type,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.arguments,
                                                    &other.arguments,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.semi_colon,
                                                            &other.semi_colon,
                                                        )
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for CallbackDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.callback, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.assign, state);
        ::core::hash::Hash::hash(&self.return_type, state);
        ::core::hash::Hash::hash(&self.arguments, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? callback interface identifier ( : inheritance )? { members };`
pub struct CallbackInterfaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub callback: crate::term::Callback,
    pub interface: crate::term::Interface,
    pub identifier: Identifier<'a>,
    pub members: Braced<CallbackInterfaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for CallbackInterfaceDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, callback) = <crate::term::Callback as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, interface) = <crate::term::Interface as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            CallbackInterfaceMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                callback,
                interface,
                identifier,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for CallbackInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for CallbackInterfaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> CallbackInterfaceDefinition<'a> {
        CallbackInterfaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            callback: ::core::clone::Clone::clone(&self.callback),
            interface: ::core::clone::Clone::clone(&self.interface),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for CallbackInterfaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "callback",
            "interface",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.callback,
            &&self.interface,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "CallbackInterfaceDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for CallbackInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for CallbackInterfaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Callback>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<CallbackInterfaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for CallbackInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for CallbackInterfaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &CallbackInterfaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.callback == other.callback
            && self.interface == other.interface && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for CallbackInterfaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &CallbackInterfaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.callback, &other.callback) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for CallbackInterfaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &CallbackInterfaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.callback,
                    &other.callback,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.interface,
                            &other.interface,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for CallbackInterfaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.callback, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? interface identifier ( : inheritance )? { members };`
pub struct InterfaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub interface: crate::term::Interface,
    pub identifier: Identifier<'a>,
    pub inheritance: Option<Inheritance<'a>>,
    pub members: Braced<InterfaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for InterfaceDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, interface) = <crate::term::Interface as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, inheritance) = <Option<
            Inheritance<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            InterfaceMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                interface,
                identifier,
                inheritance,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for InterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for InterfaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> InterfaceDefinition<'a> {
        InterfaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            interface: ::core::clone::Clone::clone(&self.interface),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            inheritance: ::core::clone::Clone::clone(&self.inheritance),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for InterfaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "interface",
            "identifier",
            "inheritance",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.interface,
            &&self.identifier,
            &&self.inheritance,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "InterfaceDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for InterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for InterfaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Option<Inheritance<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<InterfaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for InterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for InterfaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &InterfaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.interface == other.interface
            && self.identifier == other.identifier
            && self.inheritance == other.inheritance && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for InterfaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &InterfaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.inheritance,
                                    &other.inheritance,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for InterfaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &InterfaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.interface,
                    &other.interface,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.inheritance,
                                    &other.inheritance,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for InterfaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.inheritance, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? interface mixin identifier { members };`
pub struct InterfaceMixinDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub interface: crate::term::Interface,
    pub mixin: crate::term::Mixin,
    pub identifier: Identifier<'a>,
    pub members: Braced<MixinMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for InterfaceMixinDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, interface) = <crate::term::Interface as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, mixin) = <crate::term::Mixin as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            MixinMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                interface,
                mixin,
                identifier,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for InterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for InterfaceMixinDefinition<'a> {
    #[inline]
    fn clone(&self) -> InterfaceMixinDefinition<'a> {
        InterfaceMixinDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            interface: ::core::clone::Clone::clone(&self.interface),
            mixin: ::core::clone::Clone::clone(&self.mixin),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for InterfaceMixinDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "interface",
            "mixin",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.interface,
            &&self.mixin,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "InterfaceMixinDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for InterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for InterfaceMixinDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Mixin>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<MixinMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for InterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for InterfaceMixinDefinition<'a> {
    #[inline]
    fn eq(&self, other: &InterfaceMixinDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.interface == other.interface
            && self.mixin == other.mixin && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for InterfaceMixinDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &InterfaceMixinDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.mixin, &other.mixin) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for InterfaceMixinDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &InterfaceMixinDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.interface,
                    &other.interface,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.mixin,
                            &other.mixin,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for InterfaceMixinDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.mixin, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? namespace identifier { members };`
pub struct NamespaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub namespace: crate::term::Namespace,
    pub identifier: Identifier<'a>,
    pub members: Braced<NamespaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for NamespaceDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, namespace) = <crate::term::Namespace as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            NamespaceMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                namespace,
                identifier,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for NamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for NamespaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> NamespaceDefinition<'a> {
        NamespaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            namespace: ::core::clone::Clone::clone(&self.namespace),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for NamespaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "NamespaceDefinition",
            "attributes",
            &&self.attributes,
            "namespace",
            &&self.namespace,
            "identifier",
            &&self.identifier,
            "members",
            &&self.members,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for NamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for NamespaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Namespace>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<NamespaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for NamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for NamespaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &NamespaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.namespace == other.namespace
            && self.identifier == other.identifier && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for NamespaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &NamespaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.namespace, &other.namespace) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for NamespaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &NamespaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.namespace,
                    &other.namespace,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.members,
                                    &other.members,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for NamespaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.namespace, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? dictionary identifier ( : inheritance )? { members };`
pub struct DictionaryDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub dictionary: crate::term::Dictionary,
    pub identifier: Identifier<'a>,
    pub inheritance: Option<Inheritance<'a>>,
    pub members: Braced<DictionaryMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for DictionaryDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, dictionary) = <crate::term::Dictionary as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, inheritance) = <Option<
            Inheritance<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            DictionaryMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                dictionary,
                identifier,
                inheritance,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for DictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for DictionaryDefinition<'a> {
    #[inline]
    fn clone(&self) -> DictionaryDefinition<'a> {
        DictionaryDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            dictionary: ::core::clone::Clone::clone(&self.dictionary),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            inheritance: ::core::clone::Clone::clone(&self.inheritance),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for DictionaryDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "dictionary",
            "identifier",
            "inheritance",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.dictionary,
            &&self.identifier,
            &&self.inheritance,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "DictionaryDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for DictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for DictionaryDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Dictionary>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Option<Inheritance<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<DictionaryMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for DictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for DictionaryDefinition<'a> {
    #[inline]
    fn eq(&self, other: &DictionaryDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.dictionary == other.dictionary
            && self.identifier == other.identifier
            && self.inheritance == other.inheritance && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for DictionaryDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &DictionaryDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.dictionary, &other.dictionary) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.inheritance,
                                    &other.inheritance,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for DictionaryDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &DictionaryDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.dictionary,
                    &other.dictionary,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.inheritance,
                                    &other.inheritance,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for DictionaryDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.dictionary, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.inheritance, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? partial interface identifier { members };`
pub struct PartialInterfaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub partial: crate::term::Partial,
    pub interface: crate::term::Interface,
    pub identifier: Identifier<'a>,
    pub members: Braced<InterfaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for PartialInterfaceDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, partial) = <crate::term::Partial as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, interface) = <crate::term::Interface as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            InterfaceMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                partial,
                interface,
                identifier,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for PartialInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for PartialInterfaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> PartialInterfaceDefinition<'a> {
        PartialInterfaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            partial: ::core::clone::Clone::clone(&self.partial),
            interface: ::core::clone::Clone::clone(&self.interface),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for PartialInterfaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "partial",
            "interface",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.partial,
            &&self.interface,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "PartialInterfaceDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for PartialInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for PartialInterfaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Partial>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<InterfaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for PartialInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for PartialInterfaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &PartialInterfaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.partial == other.partial
            && self.interface == other.interface && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for PartialInterfaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &PartialInterfaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.partial, &other.partial) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for PartialInterfaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &PartialInterfaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.partial,
                    &other.partial,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.interface,
                            &other.interface,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for PartialInterfaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.partial, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? partial interface mixin identifier { members };`
pub struct PartialInterfaceMixinDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub partial: crate::term::Partial,
    pub interface: crate::term::Interface,
    pub mixin: crate::term::Mixin,
    pub identifier: Identifier<'a>,
    pub members: Braced<MixinMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for PartialInterfaceMixinDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, partial) = <crate::term::Partial as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, interface) = <crate::term::Interface as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, mixin) = <crate::term::Mixin as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            MixinMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                partial,
                interface,
                mixin,
                identifier,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for PartialInterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    fn clone(&self) -> PartialInterfaceMixinDefinition<'a> {
        PartialInterfaceMixinDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            partial: ::core::clone::Clone::clone(&self.partial),
            interface: ::core::clone::Clone::clone(&self.interface),
            mixin: ::core::clone::Clone::clone(&self.mixin),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for PartialInterfaceMixinDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "partial",
            "interface",
            "mixin",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.partial,
            &&self.interface,
            &&self.mixin,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "PartialInterfaceMixinDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for PartialInterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Partial>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Mixin>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<MixinMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for PartialInterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    fn eq(&self, other: &PartialInterfaceMixinDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.partial == other.partial
            && self.interface == other.interface && self.mixin == other.mixin
            && self.identifier == other.identifier && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &PartialInterfaceMixinDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.partial, &other.partial) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.mixin, &other.mixin) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.identifier,
                                            &other.identifier,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &PartialInterfaceMixinDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.partial,
                    &other.partial,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.interface,
                            &other.interface,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.mixin,
                                    &other.mixin,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.identifier,
                                            &other.identifier,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.members,
                                                    &other.members,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.semi_colon,
                                                            &other.semi_colon,
                                                        )
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for PartialInterfaceMixinDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.partial, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.mixin, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? partial dictionary identifier { members };`
pub struct PartialDictionaryDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub partial: crate::term::Partial,
    pub dictionary: crate::term::Dictionary,
    pub identifier: Identifier<'a>,
    pub members: Braced<DictionaryMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for PartialDictionaryDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, partial) = <crate::term::Partial as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, dictionary) = <crate::term::Dictionary as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            DictionaryMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                partial,
                dictionary,
                identifier,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for PartialDictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for PartialDictionaryDefinition<'a> {
    #[inline]
    fn clone(&self) -> PartialDictionaryDefinition<'a> {
        PartialDictionaryDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            partial: ::core::clone::Clone::clone(&self.partial),
            dictionary: ::core::clone::Clone::clone(&self.dictionary),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for PartialDictionaryDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "partial",
            "dictionary",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.partial,
            &&self.dictionary,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "PartialDictionaryDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for PartialDictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for PartialDictionaryDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Partial>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Dictionary>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<DictionaryMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for PartialDictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for PartialDictionaryDefinition<'a> {
    #[inline]
    fn eq(&self, other: &PartialDictionaryDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.partial == other.partial
            && self.dictionary == other.dictionary && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for PartialDictionaryDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &PartialDictionaryDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.partial, &other.partial) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.dictionary,
                            &other.dictionary,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for PartialDictionaryDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &PartialDictionaryDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.partial,
                    &other.partial,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.dictionary,
                            &other.dictionary,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for PartialDictionaryDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.partial, state);
        ::core::hash::Hash::hash(&self.dictionary, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? partial namespace identifier { members };`
pub struct PartialNamespaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub partial: crate::term::Partial,
    pub namespace: crate::term::Namespace,
    pub identifier: Identifier<'a>,
    pub members: Braced<NamespaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for PartialNamespaceDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, partial) = <crate::term::Partial as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, namespace) = <crate::term::Namespace as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, members) = <Braced<
            NamespaceMembers<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                partial,
                namespace,
                identifier,
                members,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for PartialNamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for PartialNamespaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> PartialNamespaceDefinition<'a> {
        PartialNamespaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            partial: ::core::clone::Clone::clone(&self.partial),
            namespace: ::core::clone::Clone::clone(&self.namespace),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for PartialNamespaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "partial",
            "namespace",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.partial,
            &&self.namespace,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "PartialNamespaceDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for PartialNamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for PartialNamespaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Partial>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Namespace>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<NamespaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for PartialNamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for PartialNamespaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &PartialNamespaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.partial == other.partial
            && self.namespace == other.namespace && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for PartialNamespaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &PartialNamespaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.partial, &other.partial) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.namespace, &other.namespace) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for PartialNamespaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &PartialNamespaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.partial,
                    &other.partial,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.namespace,
                            &other.namespace,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for PartialNamespaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.partial, state);
        ::core::hash::Hash::hash(&self.namespace, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? enum identifier { values };`
pub struct EnumDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub enum_: crate::term::Enum,
    pub identifier: Identifier<'a>,
    pub values: Braced<EnumValueList<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for EnumDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, enum_) = <crate::term::Enum as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, values) = <Braced<
            EnumValueList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                enum_,
                identifier,
                values,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for EnumDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for EnumDefinition<'a> {
    #[inline]
    fn clone(&self) -> EnumDefinition<'a> {
        EnumDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            enum_: ::core::clone::Clone::clone(&self.enum_),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            values: ::core::clone::Clone::clone(&self.values),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for EnumDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "EnumDefinition",
            "attributes",
            &&self.attributes,
            "enum_",
            &&self.enum_,
            "identifier",
            &&self.identifier,
            "values",
            &&self.values,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for EnumDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for EnumDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Enum>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<EnumValueList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for EnumDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for EnumDefinition<'a> {
    #[inline]
    fn eq(&self, other: &EnumDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.enum_ == other.enum_
            && self.identifier == other.identifier && self.values == other.values
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for EnumDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &EnumDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.enum_, &other.enum_) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.values, &other.values) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for EnumDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &EnumDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(&self.enum_, &other.enum_) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.values,
                                    &other.values,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for EnumDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.enum_, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.values, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? typedef attributedtype identifier;`
pub struct TypedefDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub typedef: crate::term::Typedef,
    pub type_: AttributedType<'a>,
    pub identifier: Identifier<'a>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for TypedefDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, typedef) = <crate::term::Typedef as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, type_) = <AttributedType<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                typedef,
                type_,
                identifier,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for TypedefDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for TypedefDefinition<'a> {
    #[inline]
    fn clone(&self) -> TypedefDefinition<'a> {
        TypedefDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            typedef: ::core::clone::Clone::clone(&self.typedef),
            type_: ::core::clone::Clone::clone(&self.type_),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for TypedefDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "TypedefDefinition",
            "attributes",
            &&self.attributes,
            "typedef",
            &&self.typedef,
            "type_",
            &&self.type_,
            "identifier",
            &&self.identifier,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for TypedefDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for TypedefDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Typedef>;
        let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for TypedefDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for TypedefDefinition<'a> {
    #[inline]
    fn eq(&self, other: &TypedefDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.typedef == other.typedef
            && self.type_ == other.type_ && self.identifier == other.identifier
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for TypedefDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &TypedefDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.typedef, &other.typedef) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for TypedefDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &TypedefDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.typedef,
                    &other.typedef,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.type_,
                            &other.type_,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for TypedefDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.typedef, state);
        ::core::hash::Hash::hash(&self.type_, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses `[attributes]? identifier includes identifier;`
pub struct IncludesStatementDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub lhs_identifier: Identifier<'a>,
    pub includes: crate::term::Includes,
    pub rhs_identifier: Identifier<'a>,
    pub semi_colon: crate::term::SemiColon,
}
impl<'a> crate::Parse<'a> for IncludesStatementDefinition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::lib::std::result::Result::Ok;
        let (input, attributes) = <Option<
            ExtendedAttributeList<'a>,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, lhs_identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, includes) = <crate::term::Includes as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        let (input, rhs_identifier) = <Identifier<
            'a,
        > as crate::Parse<'a>>::parse_tokens(input)?;
        let (input, semi_colon) = <crate::term::SemiColon as crate::Parse<
            'a,
        >>::parse_tokens(input)?;
        Ok((
            input,
            Self {
                attributes,
                lhs_identifier,
                includes,
                rhs_identifier,
                semi_colon,
            },
        ))
    }
}
impl<'a> crate::ParsePost<'a> for IncludesStatementDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for IncludesStatementDefinition<'a> {
    #[inline]
    fn clone(&self) -> IncludesStatementDefinition<'a> {
        IncludesStatementDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            lhs_identifier: ::core::clone::Clone::clone(&self.lhs_identifier),
            includes: ::core::clone::Clone::clone(&self.includes),
            rhs_identifier: ::core::clone::Clone::clone(&self.rhs_identifier),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for IncludesStatementDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "IncludesStatementDefinition",
            "attributes",
            &&self.attributes,
            "lhs_identifier",
            &&self.lhs_identifier,
            "includes",
            &&self.includes,
            "rhs_identifier",
            &&self.rhs_identifier,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for IncludesStatementDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for IncludesStatementDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Includes>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for IncludesStatementDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for IncludesStatementDefinition<'a> {
    #[inline]
    fn eq(&self, other: &IncludesStatementDefinition<'a>) -> bool {
        self.attributes == other.attributes
            && self.lhs_identifier == other.lhs_identifier
            && self.includes == other.includes
            && self.rhs_identifier == other.rhs_identifier
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for IncludesStatementDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &IncludesStatementDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(
                    &self.lhs_identifier,
                    &other.lhs_identifier,
                ) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.includes, &other.includes) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.rhs_identifier,
                                    &other.rhs_identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for IncludesStatementDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &IncludesStatementDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.lhs_identifier,
                    &other.lhs_identifier,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.includes,
                            &other.includes,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.rhs_identifier,
                                    &other.rhs_identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for IncludesStatementDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.lhs_identifier, state);
        ::core::hash::Hash::hash(&self.includes, state);
        ::core::hash::Hash::hash(&self.rhs_identifier, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
/// Parses a definition
pub enum Definition<'a> {
    Callback(CallbackDefinition<'a>),
    CallbackInterface(CallbackInterfaceDefinition<'a>),
    Interface(InterfaceDefinition<'a>),
    InterfaceMixin(InterfaceMixinDefinition<'a>),
    Namespace(NamespaceDefinition<'a>),
    Dictionary(DictionaryDefinition<'a>),
    PartialInterface(PartialInterfaceDefinition<'a>),
    PartialInterfaceMixin(PartialInterfaceMixinDefinition<'a>),
    PartialDictionary(PartialDictionaryDefinition<'a>),
    PartialNamespace(PartialNamespaceDefinition<'a>),
    Enum(EnumDefinition<'a>),
    Typedef(TypedefDefinition<'a>),
    IncludesStatement(IncludesStatementDefinition<'a>),
}
impl<'a> crate::Parse<'a> for Definition<'a> {
    fn parse_body<'slice>(
        input: crate::tokens::Tokens<'slice, 'a>,
    ) -> crate::VerboseResult<crate::tokens::Tokens<'slice, 'a>, Self> {
        use nom::Parser;
        nom::branch::alt((
            <CallbackDefinition<'a> as crate::Parse<'a>>::parse_tokens
                .map(Self::Callback),
            <CallbackInterfaceDefinition<'a> as crate::Parse<'a>>::parse_tokens
                .map(Self::CallbackInterface),
            nom::branch::alt((
                <InterfaceDefinition<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::Interface),
                <InterfaceMixinDefinition<'a> as crate::Parse<'a>>::parse_tokens
                    .map(Self::InterfaceMixin),
                nom::branch::alt((
                    <NamespaceDefinition<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Namespace),
                    <DictionaryDefinition<'a> as crate::Parse<'a>>::parse_tokens
                        .map(Self::Dictionary),
                    nom::branch::alt((
                        <PartialInterfaceDefinition<
                            'a,
                        > as crate::Parse<'a>>::parse_tokens
                            .map(Self::PartialInterface),
                        <PartialInterfaceMixinDefinition<
                            'a,
                        > as crate::Parse<'a>>::parse_tokens
                            .map(Self::PartialInterfaceMixin),
                        nom::branch::alt((
                            <PartialDictionaryDefinition<
                                'a,
                            > as crate::Parse<'a>>::parse_tokens
                                .map(Self::PartialDictionary),
                            <PartialNamespaceDefinition<
                                'a,
                            > as crate::Parse<'a>>::parse_tokens
                                .map(Self::PartialNamespace),
                            nom::branch::alt((
                                <EnumDefinition<'a> as crate::Parse<'a>>::parse_tokens
                                    .map(Self::Enum),
                                <TypedefDefinition<'a> as crate::Parse<'a>>::parse_tokens
                                    .map(Self::Typedef),
                                <IncludesStatementDefinition<
                                    'a,
                                > as crate::Parse<'a>>::parse_tokens
                                    .map(Self::IncludesStatement),
                            )),
                        )),
                    )),
                )),
            )),
        ))(input)
    }
}
impl<'a> crate::ParsePost<'a> for Definition<'a> {}
#[automatically_derived]
impl<'a> ::core::clone::Clone for Definition<'a> {
    #[inline]
    fn clone(&self) -> Definition<'a> {
        match self {
            Definition::Callback(__self_0) => {
                Definition::Callback(::core::clone::Clone::clone(__self_0))
            }
            Definition::CallbackInterface(__self_0) => {
                Definition::CallbackInterface(::core::clone::Clone::clone(__self_0))
            }
            Definition::Interface(__self_0) => {
                Definition::Interface(::core::clone::Clone::clone(__self_0))
            }
            Definition::InterfaceMixin(__self_0) => {
                Definition::InterfaceMixin(::core::clone::Clone::clone(__self_0))
            }
            Definition::Namespace(__self_0) => {
                Definition::Namespace(::core::clone::Clone::clone(__self_0))
            }
            Definition::Dictionary(__self_0) => {
                Definition::Dictionary(::core::clone::Clone::clone(__self_0))
            }
            Definition::PartialInterface(__self_0) => {
                Definition::PartialInterface(::core::clone::Clone::clone(__self_0))
            }
            Definition::PartialInterfaceMixin(__self_0) => {
                Definition::PartialInterfaceMixin(::core::clone::Clone::clone(__self_0))
            }
            Definition::PartialDictionary(__self_0) => {
                Definition::PartialDictionary(::core::clone::Clone::clone(__self_0))
            }
            Definition::PartialNamespace(__self_0) => {
                Definition::PartialNamespace(::core::clone::Clone::clone(__self_0))
            }
            Definition::Enum(__self_0) => {
                Definition::Enum(::core::clone::Clone::clone(__self_0))
            }
            Definition::Typedef(__self_0) => {
                Definition::Typedef(::core::clone::Clone::clone(__self_0))
            }
            Definition::IncludesStatement(__self_0) => {
                Definition::IncludesStatement(::core::clone::Clone::clone(__self_0))
            }
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for Definition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            Definition::Callback(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Callback",
                    &__self_0,
                )
            }
            Definition::CallbackInterface(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CallbackInterface",
                    &__self_0,
                )
            }
            Definition::Interface(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Interface",
                    &__self_0,
                )
            }
            Definition::InterfaceMixin(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InterfaceMixin",
                    &__self_0,
                )
            }
            Definition::Namespace(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Namespace",
                    &__self_0,
                )
            }
            Definition::Dictionary(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Dictionary",
                    &__self_0,
                )
            }
            Definition::PartialInterface(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PartialInterface",
                    &__self_0,
                )
            }
            Definition::PartialInterfaceMixin(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PartialInterfaceMixin",
                    &__self_0,
                )
            }
            Definition::PartialDictionary(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PartialDictionary",
                    &__self_0,
                )
            }
            Definition::PartialNamespace(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PartialNamespace",
                    &__self_0,
                )
            }
            Definition::Enum(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Enum", &__self_0)
            }
            Definition::Typedef(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Typedef",
                    &__self_0,
                )
            }
            Definition::IncludesStatement(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "IncludesStatement",
                    &__self_0,
                )
            }
        }
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for Definition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for Definition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<CallbackDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<CallbackInterfaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<InterfaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<InterfaceMixinDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<NamespaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<DictionaryDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<PartialInterfaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<PartialInterfaceMixinDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<PartialDictionaryDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<PartialNamespaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<EnumDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<TypedefDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<IncludesStatementDefinition<'a>>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for Definition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for Definition<'a> {
    #[inline]
    fn eq(&self, other: &Definition<'a>) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
            && match (self, other) {
                (Definition::Callback(__self_0), Definition::Callback(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    Definition::CallbackInterface(__self_0),
                    Definition::CallbackInterface(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (Definition::Interface(__self_0), Definition::Interface(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    Definition::InterfaceMixin(__self_0),
                    Definition::InterfaceMixin(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (Definition::Namespace(__self_0), Definition::Namespace(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (Definition::Dictionary(__self_0), Definition::Dictionary(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    Definition::PartialInterface(__self_0),
                    Definition::PartialInterface(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    Definition::PartialInterfaceMixin(__self_0),
                    Definition::PartialInterfaceMixin(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    Definition::PartialDictionary(__self_0),
                    Definition::PartialDictionary(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    Definition::PartialNamespace(__self_0),
                    Definition::PartialNamespace(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (Definition::Typedef(__self_0), Definition::Typedef(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    Definition::IncludesStatement(__self_0),
                    Definition::IncludesStatement(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                _ => unsafe { ::core::intrinsics::unreachable() }
            }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for Definition<'a> {
    #[inline]
    fn cmp(&self, other: &Definition<'a>) -> ::core::cmp::Ordering {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
            ::core::cmp::Ordering::Equal => {
                match (self, other) {
                    (Definition::Callback(__self_0), Definition::Callback(__arg1_0)) => {
                        ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                    }
                    (
                        Definition::CallbackInterface(__self_0),
                        Definition::CallbackInterface(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::Interface(__self_0),
                        Definition::Interface(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::InterfaceMixin(__self_0),
                        Definition::InterfaceMixin(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::Namespace(__self_0),
                        Definition::Namespace(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::Dictionary(__self_0),
                        Definition::Dictionary(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialInterface(__self_0),
                        Definition::PartialInterface(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialInterfaceMixin(__self_0),
                        Definition::PartialInterfaceMixin(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialDictionary(__self_0),
                        Definition::PartialDictionary(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialNamespace(__self_0),
                        Definition::PartialNamespace(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                        ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                    }
                    (Definition::Typedef(__self_0), Definition::Typedef(__arg1_0)) => {
                        ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                    }
                    (
                        Definition::IncludesStatement(__self_0),
                        Definition::IncludesStatement(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for Definition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &Definition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match (self, other) {
                    (Definition::Callback(__self_0), Definition::Callback(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (
                        Definition::CallbackInterface(__self_0),
                        Definition::CallbackInterface(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::Interface(__self_0),
                        Definition::Interface(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::InterfaceMixin(__self_0),
                        Definition::InterfaceMixin(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::Namespace(__self_0),
                        Definition::Namespace(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::Dictionary(__self_0),
                        Definition::Dictionary(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialInterface(__self_0),
                        Definition::PartialInterface(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialInterfaceMixin(__self_0),
                        Definition::PartialInterfaceMixin(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialDictionary(__self_0),
                        Definition::PartialDictionary(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialNamespace(__self_0),
                        Definition::PartialNamespace(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (Definition::Typedef(__self_0), Definition::Typedef(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (
                        Definition::IncludesStatement(__self_0),
                        Definition::IncludesStatement(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for Definition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        ::core::hash::Hash::hash(&__self_tag, state);
        match self {
            Definition::Callback(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::CallbackInterface(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::Interface(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::InterfaceMixin(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::Namespace(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::Dictionary(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::PartialInterface(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::PartialInterfaceMixin(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::PartialDictionary(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::PartialNamespace(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::Enum(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::Typedef(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::IncludesStatement(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
        }
    }
}
/// Parses a non-empty enum value list
pub type EnumValueList<'a> = PunctuatedNonEmpty<StringLit<'a>, crate::term::Comma>;

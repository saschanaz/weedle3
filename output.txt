#![feature(prelude_import)]
//! Weedle - A WebIDL Parser
//!
//! Parses valid WebIDL definitions & produces a data structure starting from
//! [`Definitions`](struct.Definitions.html).
//!
//! ### Example
//!
//! ```
//! extern crate weedle;
//!
//! let parsed = weedle::parse("
//!     interface Window {
//!         readonly attribute Storage sessionStorage;
//!     };
//! ").unwrap();
//! println!("{:?}", parsed);
//! ```
//!
//! Note:
//! This parser follows the grammar given at [WebIDL](https://heycam.github.io/webidl).
//!
//! If any flaws found when parsing string with a valid grammar, create an issue.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use self::argument::ArgumentList;
use self::attribute::ExtendedAttributeList;
use self::common::{Braced, Identifier, Parenthesized, PunctuatedNonEmpty};
use self::dictionary::DictionaryMembers;
use self::interface::{Inheritance, InterfaceMembers};
use self::literal::StringLit;
use self::mixin::MixinMembers;
use self::namespace::NamespaceMembers;
use self::types::{AttributedType, ReturnType};
pub use nom::{error::Error, Err, IResult};
#[macro_use]
mod macros {}
#[macro_use]
mod whitespace {
    use nom::{IResult, Parser};
    pub(crate) fn sp(input: &str) -> IResult<&str, &str> {
        nom::combinator::recognize(
            nom::multi::many0(
                nom::branch::alt((
                    nom::combinator::value(
                        (),
                        nom::sequence::tuple((
                            nom::bytes::complete::tag("//"),
                            nom::bytes::complete::take_until("\n"),
                            nom::bytes::complete::tag("\n"),
                        )),
                    ),
                    nom::combinator::value((), nom::character::complete::multispace1),
                    nom::combinator::value(
                        (),
                        nom::sequence::tuple((
                            nom::bytes::complete::tag("/*"),
                            nom::bytes::complete::take_until("*/"),
                            nom::bytes::complete::tag("*/"),
                        )),
                    ),
                )),
            ),
        )(input)
    }
    /// ws also ignores line & block comments
    pub(crate) fn ws<'a, F>(inner: F) -> impl FnMut(&'a str) -> IResult<&str, &str>
    where
        F: Parser<&'a str, &'a str, nom::error::Error<&'a str>>,
    {
        nom::sequence::delimited(sp, inner, sp)
    }
}
#[macro_use]
pub mod term {
    struct AlphaNumUnderscoreDash;
    impl nom::FindToken<char> for AlphaNumUnderscoreDash {
        fn find_token(&self, token: char) -> bool {
            crate::common::is_alphanum_underscore_dash(token)
        }
    }
    pub(crate) fn ident_tag(
        tag: &'static str,
    ) -> impl FnMut(&str) -> nom::IResult<&str, &str> {
        move |input| {
            nom::sequence::terminated(
                nom::bytes::complete::tag(tag),
                nom::combinator::not(
                    nom::combinator::map_parser(
                        nom::bytes::complete::take(1usize),
                        nom::bytes::complete::is_a(AlphaNumUnderscoreDash),
                    ),
                ),
            )(input)
        }
    }
    /// Represents the terminal symbol `(`
    pub struct OpenParen;
    #[automatically_derived]
    impl ::core::clone::Clone for OpenParen {
        #[inline]
        fn clone(&self) -> OpenParen {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for OpenParen {}
    #[automatically_derived]
    impl ::core::fmt::Debug for OpenParen {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "OpenParen")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for OpenParen {
        #[inline]
        fn default() -> OpenParen {
            OpenParen {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OpenParen {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OpenParen {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OpenParen {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for OpenParen {
        #[inline]
        fn cmp(&self, other: &OpenParen) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OpenParen {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OpenParen {
        #[inline]
        fn eq(&self, other: &OpenParen) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for OpenParen {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OpenParen,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for OpenParen {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                OpenParen,
                crate::whitespace::ws(nom::bytes::complete::tag("(")),
            )(input)
        }
    }
    /// Represents the terminal symbol `)`
    pub struct CloseParen;
    #[automatically_derived]
    impl ::core::clone::Clone for CloseParen {
        #[inline]
        fn clone(&self) -> CloseParen {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for CloseParen {}
    #[automatically_derived]
    impl ::core::fmt::Debug for CloseParen {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "CloseParen")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for CloseParen {
        #[inline]
        fn default() -> CloseParen {
            CloseParen {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for CloseParen {}
    #[automatically_derived]
    impl ::core::cmp::Eq for CloseParen {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for CloseParen {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for CloseParen {
        #[inline]
        fn cmp(&self, other: &CloseParen) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CloseParen {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CloseParen {
        #[inline]
        fn eq(&self, other: &CloseParen) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for CloseParen {
        #[inline]
        fn partial_cmp(
            &self,
            other: &CloseParen,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for CloseParen {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                CloseParen,
                crate::whitespace::ws(nom::bytes::complete::tag(")")),
            )(input)
        }
    }
    /// Represents the terminal symbol `[`
    pub struct OpenBracket;
    #[automatically_derived]
    impl ::core::clone::Clone for OpenBracket {
        #[inline]
        fn clone(&self) -> OpenBracket {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for OpenBracket {}
    #[automatically_derived]
    impl ::core::fmt::Debug for OpenBracket {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "OpenBracket")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for OpenBracket {
        #[inline]
        fn default() -> OpenBracket {
            OpenBracket {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OpenBracket {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OpenBracket {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OpenBracket {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for OpenBracket {
        #[inline]
        fn cmp(&self, other: &OpenBracket) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OpenBracket {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OpenBracket {
        #[inline]
        fn eq(&self, other: &OpenBracket) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for OpenBracket {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OpenBracket,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for OpenBracket {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                OpenBracket,
                crate::whitespace::ws(nom::bytes::complete::tag("[")),
            )(input)
        }
    }
    /// Represents the terminal symbol `]`
    pub struct CloseBracket;
    #[automatically_derived]
    impl ::core::clone::Clone for CloseBracket {
        #[inline]
        fn clone(&self) -> CloseBracket {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for CloseBracket {}
    #[automatically_derived]
    impl ::core::fmt::Debug for CloseBracket {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "CloseBracket")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for CloseBracket {
        #[inline]
        fn default() -> CloseBracket {
            CloseBracket {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for CloseBracket {}
    #[automatically_derived]
    impl ::core::cmp::Eq for CloseBracket {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for CloseBracket {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for CloseBracket {
        #[inline]
        fn cmp(&self, other: &CloseBracket) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CloseBracket {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CloseBracket {
        #[inline]
        fn eq(&self, other: &CloseBracket) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for CloseBracket {
        #[inline]
        fn partial_cmp(
            &self,
            other: &CloseBracket,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for CloseBracket {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                CloseBracket,
                crate::whitespace::ws(nom::bytes::complete::tag("]")),
            )(input)
        }
    }
    /// Represents the terminal symbol `{`
    pub struct OpenBrace;
    #[automatically_derived]
    impl ::core::clone::Clone for OpenBrace {
        #[inline]
        fn clone(&self) -> OpenBrace {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for OpenBrace {}
    #[automatically_derived]
    impl ::core::fmt::Debug for OpenBrace {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "OpenBrace")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for OpenBrace {
        #[inline]
        fn default() -> OpenBrace {
            OpenBrace {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OpenBrace {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OpenBrace {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OpenBrace {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for OpenBrace {
        #[inline]
        fn cmp(&self, other: &OpenBrace) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OpenBrace {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OpenBrace {
        #[inline]
        fn eq(&self, other: &OpenBrace) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for OpenBrace {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OpenBrace,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for OpenBrace {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                OpenBrace,
                crate::whitespace::ws(nom::bytes::complete::tag("{")),
            )(input)
        }
    }
    /// Represents the terminal symbol `}`
    pub struct CloseBrace;
    #[automatically_derived]
    impl ::core::clone::Clone for CloseBrace {
        #[inline]
        fn clone(&self) -> CloseBrace {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for CloseBrace {}
    #[automatically_derived]
    impl ::core::fmt::Debug for CloseBrace {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "CloseBrace")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for CloseBrace {
        #[inline]
        fn default() -> CloseBrace {
            CloseBrace {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for CloseBrace {}
    #[automatically_derived]
    impl ::core::cmp::Eq for CloseBrace {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for CloseBrace {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for CloseBrace {
        #[inline]
        fn cmp(&self, other: &CloseBrace) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CloseBrace {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CloseBrace {
        #[inline]
        fn eq(&self, other: &CloseBrace) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for CloseBrace {
        #[inline]
        fn partial_cmp(
            &self,
            other: &CloseBrace,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for CloseBrace {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                CloseBrace,
                crate::whitespace::ws(nom::bytes::complete::tag("}")),
            )(input)
        }
    }
    /// Represents the terminal symbol `,`
    pub struct Comma;
    #[automatically_derived]
    impl ::core::clone::Clone for Comma {
        #[inline]
        fn clone(&self) -> Comma {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Comma {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Comma {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Comma")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Comma {
        #[inline]
        fn default() -> Comma {
            Comma {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Comma {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Comma {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Comma {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Comma {
        #[inline]
        fn cmp(&self, other: &Comma) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Comma {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Comma {
        #[inline]
        fn eq(&self, other: &Comma) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Comma {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Comma,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Comma {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Comma,
                crate::whitespace::ws(nom::bytes::complete::tag(",")),
            )(input)
        }
    }
    /// Represents the terminal symbol `-`
    pub struct Minus;
    #[automatically_derived]
    impl ::core::clone::Clone for Minus {
        #[inline]
        fn clone(&self) -> Minus {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Minus {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Minus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Minus")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Minus {
        #[inline]
        fn default() -> Minus {
            Minus {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Minus {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Minus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Minus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Minus {
        #[inline]
        fn cmp(&self, other: &Minus) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Minus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Minus {
        #[inline]
        fn eq(&self, other: &Minus) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Minus {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Minus,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Minus {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Minus,
                crate::whitespace::ws(nom::bytes::complete::tag("-")),
            )(input)
        }
    }
    /// Represents the terminal symbol `.`
    pub struct Dot;
    #[automatically_derived]
    impl ::core::clone::Clone for Dot {
        #[inline]
        fn clone(&self) -> Dot {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Dot {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Dot {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Dot")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Dot {
        #[inline]
        fn default() -> Dot {
            Dot {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Dot {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Dot {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Dot {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Dot {
        #[inline]
        fn cmp(&self, other: &Dot) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Dot {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Dot {
        #[inline]
        fn eq(&self, other: &Dot) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Dot {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Dot,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Dot {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Dot,
                crate::whitespace::ws(nom::bytes::complete::tag(".")),
            )(input)
        }
    }
    /// Represents the terminal symbol `...`
    pub struct Ellipsis;
    #[automatically_derived]
    impl ::core::clone::Clone for Ellipsis {
        #[inline]
        fn clone(&self) -> Ellipsis {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Ellipsis {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Ellipsis {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Ellipsis")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Ellipsis {
        #[inline]
        fn default() -> Ellipsis {
            Ellipsis {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Ellipsis {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Ellipsis {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Ellipsis {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Ellipsis {
        #[inline]
        fn cmp(&self, other: &Ellipsis) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Ellipsis {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Ellipsis {
        #[inline]
        fn eq(&self, other: &Ellipsis) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Ellipsis {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Ellipsis,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Ellipsis {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Ellipsis,
                crate::whitespace::ws(nom::bytes::complete::tag("...")),
            )(input)
        }
    }
    /// Represents the terminal symbol `:`
    pub struct Colon;
    #[automatically_derived]
    impl ::core::clone::Clone for Colon {
        #[inline]
        fn clone(&self) -> Colon {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Colon {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Colon {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Colon")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Colon {
        #[inline]
        fn default() -> Colon {
            Colon {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Colon {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Colon {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Colon {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Colon {
        #[inline]
        fn cmp(&self, other: &Colon) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Colon {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Colon {
        #[inline]
        fn eq(&self, other: &Colon) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Colon {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Colon,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Colon {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Colon,
                crate::whitespace::ws(nom::bytes::complete::tag(":")),
            )(input)
        }
    }
    /// Represents the terminal symbol `;`
    pub struct SemiColon;
    #[automatically_derived]
    impl ::core::clone::Clone for SemiColon {
        #[inline]
        fn clone(&self) -> SemiColon {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for SemiColon {}
    #[automatically_derived]
    impl ::core::fmt::Debug for SemiColon {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "SemiColon")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for SemiColon {
        #[inline]
        fn default() -> SemiColon {
            SemiColon {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for SemiColon {}
    #[automatically_derived]
    impl ::core::cmp::Eq for SemiColon {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for SemiColon {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for SemiColon {
        #[inline]
        fn cmp(&self, other: &SemiColon) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SemiColon {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SemiColon {
        #[inline]
        fn eq(&self, other: &SemiColon) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for SemiColon {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SemiColon,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for SemiColon {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                SemiColon,
                crate::whitespace::ws(nom::bytes::complete::tag(";")),
            )(input)
        }
    }
    /// Represents the terminal symbol `<`
    pub struct LessThan;
    #[automatically_derived]
    impl ::core::clone::Clone for LessThan {
        #[inline]
        fn clone(&self) -> LessThan {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for LessThan {}
    #[automatically_derived]
    impl ::core::fmt::Debug for LessThan {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "LessThan")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LessThan {
        #[inline]
        fn default() -> LessThan {
            LessThan {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for LessThan {}
    #[automatically_derived]
    impl ::core::cmp::Eq for LessThan {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for LessThan {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for LessThan {
        #[inline]
        fn cmp(&self, other: &LessThan) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LessThan {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LessThan {
        #[inline]
        fn eq(&self, other: &LessThan) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for LessThan {
        #[inline]
        fn partial_cmp(
            &self,
            other: &LessThan,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for LessThan {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                LessThan,
                crate::whitespace::ws(nom::bytes::complete::tag("<")),
            )(input)
        }
    }
    /// Represents the terminal symbol `=`
    pub struct Assign;
    #[automatically_derived]
    impl ::core::clone::Clone for Assign {
        #[inline]
        fn clone(&self) -> Assign {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Assign {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Assign {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Assign")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Assign {
        #[inline]
        fn default() -> Assign {
            Assign {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Assign {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Assign {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Assign {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Assign {
        #[inline]
        fn cmp(&self, other: &Assign) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Assign {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Assign {
        #[inline]
        fn eq(&self, other: &Assign) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Assign {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Assign,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Assign {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Assign,
                crate::whitespace::ws(nom::bytes::complete::tag("=")),
            )(input)
        }
    }
    /// Represents the terminal symbol `>`
    pub struct GreaterThan;
    #[automatically_derived]
    impl ::core::clone::Clone for GreaterThan {
        #[inline]
        fn clone(&self) -> GreaterThan {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for GreaterThan {}
    #[automatically_derived]
    impl ::core::fmt::Debug for GreaterThan {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "GreaterThan")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for GreaterThan {
        #[inline]
        fn default() -> GreaterThan {
            GreaterThan {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for GreaterThan {}
    #[automatically_derived]
    impl ::core::cmp::Eq for GreaterThan {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for GreaterThan {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for GreaterThan {
        #[inline]
        fn cmp(&self, other: &GreaterThan) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for GreaterThan {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for GreaterThan {
        #[inline]
        fn eq(&self, other: &GreaterThan) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for GreaterThan {
        #[inline]
        fn partial_cmp(
            &self,
            other: &GreaterThan,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for GreaterThan {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                GreaterThan,
                crate::whitespace::ws(nom::bytes::complete::tag(">")),
            )(input)
        }
    }
    /// Represents the terminal symbol `?`
    pub struct QMark;
    #[automatically_derived]
    impl ::core::clone::Clone for QMark {
        #[inline]
        fn clone(&self) -> QMark {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for QMark {}
    #[automatically_derived]
    impl ::core::fmt::Debug for QMark {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "QMark")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for QMark {
        #[inline]
        fn default() -> QMark {
            QMark {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for QMark {}
    #[automatically_derived]
    impl ::core::cmp::Eq for QMark {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for QMark {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for QMark {
        #[inline]
        fn cmp(&self, other: &QMark) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for QMark {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for QMark {
        #[inline]
        fn eq(&self, other: &QMark) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for QMark {
        #[inline]
        fn partial_cmp(
            &self,
            other: &QMark,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for QMark {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                QMark,
                crate::whitespace::ws(nom::bytes::complete::tag("?")),
            )(input)
        }
    }
    /// Represents the terminal symbol `*`
    pub struct Wildcard;
    #[automatically_derived]
    impl ::core::clone::Clone for Wildcard {
        #[inline]
        fn clone(&self) -> Wildcard {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Wildcard {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Wildcard {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Wildcard")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Wildcard {
        #[inline]
        fn default() -> Wildcard {
            Wildcard {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Wildcard {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Wildcard {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Wildcard {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Wildcard {
        #[inline]
        fn cmp(&self, other: &Wildcard) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Wildcard {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Wildcard {
        #[inline]
        fn eq(&self, other: &Wildcard) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Wildcard {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Wildcard,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Wildcard {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Wildcard,
                crate::whitespace::ws(nom::bytes::complete::tag("*")),
            )(input)
        }
    }
    /// Represents the terminal symbol `or`
    pub struct Or;
    #[automatically_derived]
    impl ::core::clone::Clone for Or {
        #[inline]
        fn clone(&self) -> Or {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Or {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Or {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Or")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Or {
        #[inline]
        fn default() -> Or {
            Or {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Or {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Or {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Or {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Or {
        #[inline]
        fn cmp(&self, other: &Or) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Or {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Or {
        #[inline]
        fn eq(&self, other: &Or) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Or {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Or,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Or {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Or,
                crate::whitespace::ws(crate::term::ident_tag("or")),
            )(input)
        }
    }
    /// Represents the terminal symbol `optional`
    pub struct Optional;
    #[automatically_derived]
    impl ::core::clone::Clone for Optional {
        #[inline]
        fn clone(&self) -> Optional {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Optional {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Optional {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Optional")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Optional {
        #[inline]
        fn default() -> Optional {
            Optional {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Optional {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Optional {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Optional {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Optional {
        #[inline]
        fn cmp(&self, other: &Optional) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Optional {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Optional {
        #[inline]
        fn eq(&self, other: &Optional) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Optional {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Optional,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Optional {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Optional,
                crate::whitespace::ws(crate::term::ident_tag("optional")),
            )(input)
        }
    }
    /// Represents the terminal symbol `async`
    pub struct Async;
    #[automatically_derived]
    impl ::core::clone::Clone for Async {
        #[inline]
        fn clone(&self) -> Async {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Async {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Async {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Async")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Async {
        #[inline]
        fn default() -> Async {
            Async {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Async {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Async {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Async {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Async {
        #[inline]
        fn cmp(&self, other: &Async) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Async {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Async {
        #[inline]
        fn eq(&self, other: &Async) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Async {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Async,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Async {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Async,
                crate::whitespace::ws(crate::term::ident_tag("async")),
            )(input)
        }
    }
    /// Represents the terminal symbol `attribute`
    pub struct Attribute;
    #[automatically_derived]
    impl ::core::clone::Clone for Attribute {
        #[inline]
        fn clone(&self) -> Attribute {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Attribute {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Attribute {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Attribute")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Attribute {
        #[inline]
        fn default() -> Attribute {
            Attribute {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Attribute {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Attribute {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Attribute {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Attribute {
        #[inline]
        fn cmp(&self, other: &Attribute) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Attribute {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Attribute {
        #[inline]
        fn eq(&self, other: &Attribute) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Attribute {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Attribute,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Attribute {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Attribute,
                crate::whitespace::ws(crate::term::ident_tag("attribute")),
            )(input)
        }
    }
    /// Represents the terminal symbol `callback`
    pub struct Callback;
    #[automatically_derived]
    impl ::core::clone::Clone for Callback {
        #[inline]
        fn clone(&self) -> Callback {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Callback {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Callback {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Callback")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Callback {
        #[inline]
        fn default() -> Callback {
            Callback {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Callback {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Callback {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Callback {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Callback {
        #[inline]
        fn cmp(&self, other: &Callback) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Callback {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Callback {
        #[inline]
        fn eq(&self, other: &Callback) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Callback {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Callback,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Callback {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Callback,
                crate::whitespace::ws(crate::term::ident_tag("callback")),
            )(input)
        }
    }
    /// Represents the terminal symbol `const`
    pub struct Const;
    #[automatically_derived]
    impl ::core::clone::Clone for Const {
        #[inline]
        fn clone(&self) -> Const {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Const {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Const {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Const")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Const {
        #[inline]
        fn default() -> Const {
            Const {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Const {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Const {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Const {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Const {
        #[inline]
        fn cmp(&self, other: &Const) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Const {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Const {
        #[inline]
        fn eq(&self, other: &Const) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Const {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Const,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Const {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Const,
                crate::whitespace::ws(crate::term::ident_tag("const")),
            )(input)
        }
    }
    /// Represents the terminal symbol `deleter`
    pub struct Deleter;
    #[automatically_derived]
    impl ::core::clone::Clone for Deleter {
        #[inline]
        fn clone(&self) -> Deleter {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Deleter {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Deleter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Deleter")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Deleter {
        #[inline]
        fn default() -> Deleter {
            Deleter {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Deleter {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Deleter {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Deleter {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Deleter {
        #[inline]
        fn cmp(&self, other: &Deleter) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Deleter {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Deleter {
        #[inline]
        fn eq(&self, other: &Deleter) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Deleter {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Deleter,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Deleter {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Deleter,
                crate::whitespace::ws(crate::term::ident_tag("deleter")),
            )(input)
        }
    }
    /// Represents the terminal symbol `dictionary`
    pub struct Dictionary;
    #[automatically_derived]
    impl ::core::clone::Clone for Dictionary {
        #[inline]
        fn clone(&self) -> Dictionary {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Dictionary {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Dictionary {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Dictionary")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Dictionary {
        #[inline]
        fn default() -> Dictionary {
            Dictionary {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Dictionary {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Dictionary {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Dictionary {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Dictionary {
        #[inline]
        fn cmp(&self, other: &Dictionary) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Dictionary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Dictionary {
        #[inline]
        fn eq(&self, other: &Dictionary) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Dictionary {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Dictionary,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Dictionary {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Dictionary,
                crate::whitespace::ws(crate::term::ident_tag("dictionary")),
            )(input)
        }
    }
    /// Represents the terminal symbol `enum`
    pub struct Enum;
    #[automatically_derived]
    impl ::core::clone::Clone for Enum {
        #[inline]
        fn clone(&self) -> Enum {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Enum {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Enum {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Enum")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Enum {
        #[inline]
        fn default() -> Enum {
            Enum {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Enum {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Enum {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Enum {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Enum {
        #[inline]
        fn cmp(&self, other: &Enum) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Enum {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Enum {
        #[inline]
        fn eq(&self, other: &Enum) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Enum {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Enum,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Enum {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Enum,
                crate::whitespace::ws(crate::term::ident_tag("enum")),
            )(input)
        }
    }
    /// Represents the terminal symbol `getter`
    pub struct Getter;
    #[automatically_derived]
    impl ::core::clone::Clone for Getter {
        #[inline]
        fn clone(&self) -> Getter {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Getter {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Getter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Getter")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Getter {
        #[inline]
        fn default() -> Getter {
            Getter {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Getter {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Getter {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Getter {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Getter {
        #[inline]
        fn cmp(&self, other: &Getter) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Getter {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Getter {
        #[inline]
        fn eq(&self, other: &Getter) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Getter {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Getter,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Getter {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Getter,
                crate::whitespace::ws(crate::term::ident_tag("getter")),
            )(input)
        }
    }
    /// Represents the terminal symbol `includes`
    pub struct Includes;
    #[automatically_derived]
    impl ::core::clone::Clone for Includes {
        #[inline]
        fn clone(&self) -> Includes {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Includes {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Includes {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Includes")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Includes {
        #[inline]
        fn default() -> Includes {
            Includes {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Includes {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Includes {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Includes {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Includes {
        #[inline]
        fn cmp(&self, other: &Includes) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Includes {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Includes {
        #[inline]
        fn eq(&self, other: &Includes) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Includes {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Includes,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Includes {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Includes,
                crate::whitespace::ws(crate::term::ident_tag("includes")),
            )(input)
        }
    }
    /// Represents the terminal symbol `inherit`
    pub struct Inherit;
    #[automatically_derived]
    impl ::core::clone::Clone for Inherit {
        #[inline]
        fn clone(&self) -> Inherit {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Inherit {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Inherit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Inherit")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Inherit {
        #[inline]
        fn default() -> Inherit {
            Inherit {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Inherit {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Inherit {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Inherit {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Inherit {
        #[inline]
        fn cmp(&self, other: &Inherit) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Inherit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Inherit {
        #[inline]
        fn eq(&self, other: &Inherit) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Inherit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Inherit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Inherit {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Inherit,
                crate::whitespace::ws(crate::term::ident_tag("inherit")),
            )(input)
        }
    }
    /// Represents the terminal symbol `interface`
    pub struct Interface;
    #[automatically_derived]
    impl ::core::clone::Clone for Interface {
        #[inline]
        fn clone(&self) -> Interface {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Interface {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Interface {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Interface")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Interface {
        #[inline]
        fn default() -> Interface {
            Interface {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Interface {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Interface {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Interface {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Interface {
        #[inline]
        fn cmp(&self, other: &Interface) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Interface {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Interface {
        #[inline]
        fn eq(&self, other: &Interface) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Interface {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Interface,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Interface {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Interface,
                crate::whitespace::ws(crate::term::ident_tag("interface")),
            )(input)
        }
    }
    /// Represents the terminal symbol `iterable`
    pub struct Iterable;
    #[automatically_derived]
    impl ::core::clone::Clone for Iterable {
        #[inline]
        fn clone(&self) -> Iterable {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Iterable {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Iterable {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Iterable")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Iterable {
        #[inline]
        fn default() -> Iterable {
            Iterable {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Iterable {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Iterable {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Iterable {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Iterable {
        #[inline]
        fn cmp(&self, other: &Iterable) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Iterable {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Iterable {
        #[inline]
        fn eq(&self, other: &Iterable) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Iterable {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Iterable,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Iterable {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Iterable,
                crate::whitespace::ws(crate::term::ident_tag("iterable")),
            )(input)
        }
    }
    /// Represents the terminal symbol `maplike`
    pub struct Maplike;
    #[automatically_derived]
    impl ::core::clone::Clone for Maplike {
        #[inline]
        fn clone(&self) -> Maplike {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Maplike {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Maplike {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Maplike")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Maplike {
        #[inline]
        fn default() -> Maplike {
            Maplike {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Maplike {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Maplike {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Maplike {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Maplike {
        #[inline]
        fn cmp(&self, other: &Maplike) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Maplike {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Maplike {
        #[inline]
        fn eq(&self, other: &Maplike) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Maplike {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Maplike,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Maplike {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Maplike,
                crate::whitespace::ws(crate::term::ident_tag("maplike")),
            )(input)
        }
    }
    /// Represents the terminal symbol `namespace`
    pub struct Namespace;
    #[automatically_derived]
    impl ::core::clone::Clone for Namespace {
        #[inline]
        fn clone(&self) -> Namespace {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Namespace {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Namespace {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Namespace")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Namespace {
        #[inline]
        fn default() -> Namespace {
            Namespace {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Namespace {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Namespace {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Namespace {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Namespace {
        #[inline]
        fn cmp(&self, other: &Namespace) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Namespace {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Namespace {
        #[inline]
        fn eq(&self, other: &Namespace) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Namespace {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Namespace,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Namespace {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Namespace,
                crate::whitespace::ws(crate::term::ident_tag("namespace")),
            )(input)
        }
    }
    /// Represents the terminal symbol `partial`
    pub struct Partial;
    #[automatically_derived]
    impl ::core::clone::Clone for Partial {
        #[inline]
        fn clone(&self) -> Partial {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Partial {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Partial {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Partial")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Partial {
        #[inline]
        fn default() -> Partial {
            Partial {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Partial {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Partial {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Partial {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Partial {
        #[inline]
        fn cmp(&self, other: &Partial) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Partial {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Partial {
        #[inline]
        fn eq(&self, other: &Partial) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Partial {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Partial,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Partial {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Partial,
                crate::whitespace::ws(crate::term::ident_tag("partial")),
            )(input)
        }
    }
    /// Represents the terminal symbol `required`
    pub struct Required;
    #[automatically_derived]
    impl ::core::clone::Clone for Required {
        #[inline]
        fn clone(&self) -> Required {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Required {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Required {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Required")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Required {
        #[inline]
        fn default() -> Required {
            Required {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Required {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Required {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Required {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Required {
        #[inline]
        fn cmp(&self, other: &Required) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Required {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Required {
        #[inline]
        fn eq(&self, other: &Required) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Required {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Required,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Required {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Required,
                crate::whitespace::ws(crate::term::ident_tag("required")),
            )(input)
        }
    }
    /// Represents the terminal symbol `setlike`
    pub struct Setlike;
    #[automatically_derived]
    impl ::core::clone::Clone for Setlike {
        #[inline]
        fn clone(&self) -> Setlike {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Setlike {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Setlike {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Setlike")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Setlike {
        #[inline]
        fn default() -> Setlike {
            Setlike {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Setlike {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Setlike {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Setlike {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Setlike {
        #[inline]
        fn cmp(&self, other: &Setlike) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Setlike {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Setlike {
        #[inline]
        fn eq(&self, other: &Setlike) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Setlike {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Setlike,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Setlike {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Setlike,
                crate::whitespace::ws(crate::term::ident_tag("setlike")),
            )(input)
        }
    }
    /// Represents the terminal symbol `setter`
    pub struct Setter;
    #[automatically_derived]
    impl ::core::clone::Clone for Setter {
        #[inline]
        fn clone(&self) -> Setter {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Setter {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Setter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Setter")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Setter {
        #[inline]
        fn default() -> Setter {
            Setter {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Setter {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Setter {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Setter {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Setter {
        #[inline]
        fn cmp(&self, other: &Setter) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Setter {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Setter {
        #[inline]
        fn eq(&self, other: &Setter) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Setter {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Setter,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Setter {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Setter,
                crate::whitespace::ws(crate::term::ident_tag("setter")),
            )(input)
        }
    }
    /// Represents the terminal symbol `static`
    pub struct Static;
    #[automatically_derived]
    impl ::core::clone::Clone for Static {
        #[inline]
        fn clone(&self) -> Static {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Static {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Static {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Static")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Static {
        #[inline]
        fn default() -> Static {
            Static {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Static {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Static {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Static {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Static {
        #[inline]
        fn cmp(&self, other: &Static) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Static {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Static {
        #[inline]
        fn eq(&self, other: &Static) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Static {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Static,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Static {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Static,
                crate::whitespace::ws(crate::term::ident_tag("static")),
            )(input)
        }
    }
    /// Represents the terminal symbol `stringifier`
    pub struct Stringifier;
    #[automatically_derived]
    impl ::core::clone::Clone for Stringifier {
        #[inline]
        fn clone(&self) -> Stringifier {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Stringifier {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Stringifier {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Stringifier")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Stringifier {
        #[inline]
        fn default() -> Stringifier {
            Stringifier {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Stringifier {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Stringifier {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Stringifier {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Stringifier {
        #[inline]
        fn cmp(&self, other: &Stringifier) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Stringifier {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Stringifier {
        #[inline]
        fn eq(&self, other: &Stringifier) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Stringifier {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Stringifier,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Stringifier {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Stringifier,
                crate::whitespace::ws(crate::term::ident_tag("stringifier")),
            )(input)
        }
    }
    /// Represents the terminal symbol `typedef`
    pub struct Typedef;
    #[automatically_derived]
    impl ::core::clone::Clone for Typedef {
        #[inline]
        fn clone(&self) -> Typedef {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Typedef {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Typedef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Typedef")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Typedef {
        #[inline]
        fn default() -> Typedef {
            Typedef {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Typedef {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Typedef {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Typedef {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Typedef {
        #[inline]
        fn cmp(&self, other: &Typedef) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Typedef {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Typedef {
        #[inline]
        fn eq(&self, other: &Typedef) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Typedef {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Typedef,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Typedef {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Typedef,
                crate::whitespace::ws(crate::term::ident_tag("typedef")),
            )(input)
        }
    }
    /// Represents the terminal symbol `unrestricted`
    pub struct Unrestricted;
    #[automatically_derived]
    impl ::core::clone::Clone for Unrestricted {
        #[inline]
        fn clone(&self) -> Unrestricted {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Unrestricted {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Unrestricted {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Unrestricted")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Unrestricted {
        #[inline]
        fn default() -> Unrestricted {
            Unrestricted {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Unrestricted {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Unrestricted {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Unrestricted {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Unrestricted {
        #[inline]
        fn cmp(&self, other: &Unrestricted) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Unrestricted {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Unrestricted {
        #[inline]
        fn eq(&self, other: &Unrestricted) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Unrestricted {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Unrestricted,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Unrestricted {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Unrestricted,
                crate::whitespace::ws(crate::term::ident_tag("unrestricted")),
            )(input)
        }
    }
    /// Represents the terminal symbol `symbol`
    pub struct Symbol;
    #[automatically_derived]
    impl ::core::clone::Clone for Symbol {
        #[inline]
        fn clone(&self) -> Symbol {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Symbol {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Symbol {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Symbol")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Symbol {
        #[inline]
        fn default() -> Symbol {
            Symbol {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Symbol {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Symbol {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Symbol {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Symbol {
        #[inline]
        fn cmp(&self, other: &Symbol) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Symbol {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Symbol {
        #[inline]
        fn eq(&self, other: &Symbol) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Symbol {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Symbol,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Symbol {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Symbol,
                crate::whitespace::ws(crate::term::ident_tag("symbol")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Infinity`
    pub struct NegInfinity;
    #[automatically_derived]
    impl ::core::clone::Clone for NegInfinity {
        #[inline]
        fn clone(&self) -> NegInfinity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for NegInfinity {}
    #[automatically_derived]
    impl ::core::fmt::Debug for NegInfinity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "NegInfinity")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for NegInfinity {
        #[inline]
        fn default() -> NegInfinity {
            NegInfinity {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for NegInfinity {}
    #[automatically_derived]
    impl ::core::cmp::Eq for NegInfinity {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for NegInfinity {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for NegInfinity {
        #[inline]
        fn cmp(&self, other: &NegInfinity) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NegInfinity {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NegInfinity {
        #[inline]
        fn eq(&self, other: &NegInfinity) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for NegInfinity {
        #[inline]
        fn partial_cmp(
            &self,
            other: &NegInfinity,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for NegInfinity {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                NegInfinity,
                crate::whitespace::ws(crate::term::ident_tag("-Infinity")),
            )(input)
        }
    }
    /// Represents the terminal symbol `ByteString`
    pub struct ByteString;
    #[automatically_derived]
    impl ::core::clone::Clone for ByteString {
        #[inline]
        fn clone(&self) -> ByteString {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ByteString {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ByteString {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ByteString")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ByteString {
        #[inline]
        fn default() -> ByteString {
            ByteString {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ByteString {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ByteString {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ByteString {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ByteString {
        #[inline]
        fn cmp(&self, other: &ByteString) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ByteString {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ByteString {
        #[inline]
        fn eq(&self, other: &ByteString) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ByteString {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ByteString,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for ByteString {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                ByteString,
                crate::whitespace::ws(crate::term::ident_tag("ByteString")),
            )(input)
        }
    }
    /// Represents the terminal symbol `DOMString`
    pub struct DOMString;
    #[automatically_derived]
    impl ::core::clone::Clone for DOMString {
        #[inline]
        fn clone(&self) -> DOMString {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DOMString {}
    #[automatically_derived]
    impl ::core::fmt::Debug for DOMString {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "DOMString")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for DOMString {
        #[inline]
        fn default() -> DOMString {
            DOMString {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DOMString {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DOMString {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DOMString {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DOMString {
        #[inline]
        fn cmp(&self, other: &DOMString) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DOMString {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DOMString {
        #[inline]
        fn eq(&self, other: &DOMString) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DOMString {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DOMString,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for DOMString {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                DOMString,
                crate::whitespace::ws(crate::term::ident_tag("DOMString")),
            )(input)
        }
    }
    /// Represents the terminal symbol `FrozenArray`
    pub struct FrozenArray;
    #[automatically_derived]
    impl ::core::clone::Clone for FrozenArray {
        #[inline]
        fn clone(&self) -> FrozenArray {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FrozenArray {}
    #[automatically_derived]
    impl ::core::fmt::Debug for FrozenArray {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "FrozenArray")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FrozenArray {
        #[inline]
        fn default() -> FrozenArray {
            FrozenArray {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FrozenArray {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FrozenArray {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FrozenArray {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FrozenArray {
        #[inline]
        fn cmp(&self, other: &FrozenArray) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FrozenArray {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FrozenArray {
        #[inline]
        fn eq(&self, other: &FrozenArray) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FrozenArray {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FrozenArray,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for FrozenArray {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                FrozenArray,
                crate::whitespace::ws(crate::term::ident_tag("FrozenArray")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Infinity`
    pub struct Infinity;
    #[automatically_derived]
    impl ::core::clone::Clone for Infinity {
        #[inline]
        fn clone(&self) -> Infinity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Infinity {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Infinity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Infinity")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Infinity {
        #[inline]
        fn default() -> Infinity {
            Infinity {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Infinity {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Infinity {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Infinity {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Infinity {
        #[inline]
        fn cmp(&self, other: &Infinity) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Infinity {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Infinity {
        #[inline]
        fn eq(&self, other: &Infinity) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Infinity {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Infinity,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Infinity {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Infinity,
                crate::whitespace::ws(crate::term::ident_tag("Infinity")),
            )(input)
        }
    }
    /// Represents the terminal symbol `NaN`
    pub struct NaN;
    #[automatically_derived]
    impl ::core::clone::Clone for NaN {
        #[inline]
        fn clone(&self) -> NaN {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for NaN {}
    #[automatically_derived]
    impl ::core::fmt::Debug for NaN {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "NaN")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for NaN {
        #[inline]
        fn default() -> NaN {
            NaN {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for NaN {}
    #[automatically_derived]
    impl ::core::cmp::Eq for NaN {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for NaN {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for NaN {
        #[inline]
        fn cmp(&self, other: &NaN) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NaN {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NaN {
        #[inline]
        fn eq(&self, other: &NaN) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for NaN {
        #[inline]
        fn partial_cmp(
            &self,
            other: &NaN,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for NaN {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                NaN,
                crate::whitespace::ws(crate::term::ident_tag("NaN")),
            )(input)
        }
    }
    pub struct ObservableArray;
    #[automatically_derived]
    impl ::core::clone::Clone for ObservableArray {
        #[inline]
        fn clone(&self) -> ObservableArray {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ObservableArray {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ObservableArray {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ObservableArray")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ObservableArray {
        #[inline]
        fn default() -> ObservableArray {
            ObservableArray {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ObservableArray {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ObservableArray {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ObservableArray {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ObservableArray {
        #[inline]
        fn cmp(&self, other: &ObservableArray) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ObservableArray {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ObservableArray {
        #[inline]
        fn eq(&self, other: &ObservableArray) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ObservableArray {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ObservableArray,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for ObservableArray {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                ObservableArray,
                crate::whitespace::ws(crate::term::ident_tag("ObservableArray")),
            )(input)
        }
    }
    /// Represents the terminal symbol `USVString`
    pub struct USVString;
    #[automatically_derived]
    impl ::core::clone::Clone for USVString {
        #[inline]
        fn clone(&self) -> USVString {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for USVString {}
    #[automatically_derived]
    impl ::core::fmt::Debug for USVString {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "USVString")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for USVString {
        #[inline]
        fn default() -> USVString {
            USVString {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for USVString {}
    #[automatically_derived]
    impl ::core::cmp::Eq for USVString {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for USVString {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for USVString {
        #[inline]
        fn cmp(&self, other: &USVString) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for USVString {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for USVString {
        #[inline]
        fn eq(&self, other: &USVString) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for USVString {
        #[inline]
        fn partial_cmp(
            &self,
            other: &USVString,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for USVString {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                USVString,
                crate::whitespace::ws(crate::term::ident_tag("USVString")),
            )(input)
        }
    }
    /// Represents the terminal symbol `any`
    pub struct Any;
    #[automatically_derived]
    impl ::core::clone::Clone for Any {
        #[inline]
        fn clone(&self) -> Any {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Any {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Any {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Any")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Any {
        #[inline]
        fn default() -> Any {
            Any {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Any {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Any {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Any {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Any {
        #[inline]
        fn cmp(&self, other: &Any) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Any {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Any {
        #[inline]
        fn eq(&self, other: &Any) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Any {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Any,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Any {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Any,
                crate::whitespace::ws(crate::term::ident_tag("any")),
            )(input)
        }
    }
    /// Represents the terminal symbol `boolean`
    pub struct Boolean;
    #[automatically_derived]
    impl ::core::clone::Clone for Boolean {
        #[inline]
        fn clone(&self) -> Boolean {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Boolean {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Boolean {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Boolean")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Boolean {
        #[inline]
        fn default() -> Boolean {
            Boolean {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Boolean {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Boolean {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Boolean {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Boolean {
        #[inline]
        fn cmp(&self, other: &Boolean) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Boolean {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Boolean {
        #[inline]
        fn eq(&self, other: &Boolean) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Boolean {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Boolean,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Boolean {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Boolean,
                crate::whitespace::ws(crate::term::ident_tag("boolean")),
            )(input)
        }
    }
    /// Represents the terminal symbol `byte`
    pub struct Byte;
    #[automatically_derived]
    impl ::core::clone::Clone for Byte {
        #[inline]
        fn clone(&self) -> Byte {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Byte {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Byte {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Byte")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Byte {
        #[inline]
        fn default() -> Byte {
            Byte {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Byte {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Byte {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Byte {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Byte {
        #[inline]
        fn cmp(&self, other: &Byte) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Byte {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Byte {
        #[inline]
        fn eq(&self, other: &Byte) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Byte {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Byte,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Byte {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Byte,
                crate::whitespace::ws(crate::term::ident_tag("byte")),
            )(input)
        }
    }
    /// Represents the terminal symbol `double`
    pub struct Double;
    #[automatically_derived]
    impl ::core::clone::Clone for Double {
        #[inline]
        fn clone(&self) -> Double {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Double {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Double {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Double")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Double {
        #[inline]
        fn default() -> Double {
            Double {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Double {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Double {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Double {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Double {
        #[inline]
        fn cmp(&self, other: &Double) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Double {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Double {
        #[inline]
        fn eq(&self, other: &Double) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Double {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Double,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Double {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Double,
                crate::whitespace::ws(crate::term::ident_tag("double")),
            )(input)
        }
    }
    /// Represents the terminal symbol `false`
    pub struct False;
    #[automatically_derived]
    impl ::core::clone::Clone for False {
        #[inline]
        fn clone(&self) -> False {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for False {}
    #[automatically_derived]
    impl ::core::fmt::Debug for False {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "False")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for False {
        #[inline]
        fn default() -> False {
            False {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for False {}
    #[automatically_derived]
    impl ::core::cmp::Eq for False {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for False {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for False {
        #[inline]
        fn cmp(&self, other: &False) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for False {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for False {
        #[inline]
        fn eq(&self, other: &False) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for False {
        #[inline]
        fn partial_cmp(
            &self,
            other: &False,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for False {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                False,
                crate::whitespace::ws(crate::term::ident_tag("false")),
            )(input)
        }
    }
    /// Represents the terminal symbol `float`
    pub struct Float;
    #[automatically_derived]
    impl ::core::clone::Clone for Float {
        #[inline]
        fn clone(&self) -> Float {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Float {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Float {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Float")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Float {
        #[inline]
        fn default() -> Float {
            Float {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Float {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Float {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Float {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Float {
        #[inline]
        fn cmp(&self, other: &Float) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Float {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Float {
        #[inline]
        fn eq(&self, other: &Float) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Float {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Float,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Float {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Float,
                crate::whitespace::ws(crate::term::ident_tag("float")),
            )(input)
        }
    }
    /// Represents the terminal symbol `long`
    pub struct Long;
    #[automatically_derived]
    impl ::core::clone::Clone for Long {
        #[inline]
        fn clone(&self) -> Long {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Long {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Long {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Long")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Long {
        #[inline]
        fn default() -> Long {
            Long {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Long {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Long {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Long {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Long {
        #[inline]
        fn cmp(&self, other: &Long) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Long {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Long {
        #[inline]
        fn eq(&self, other: &Long) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Long {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Long,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Long {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Long,
                crate::whitespace::ws(crate::term::ident_tag("long")),
            )(input)
        }
    }
    /// Represents the terminal symbol `null`
    pub struct Null;
    #[automatically_derived]
    impl ::core::clone::Clone for Null {
        #[inline]
        fn clone(&self) -> Null {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Null {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Null {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Null")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Null {
        #[inline]
        fn default() -> Null {
            Null {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Null {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Null {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Null {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Null {
        #[inline]
        fn cmp(&self, other: &Null) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Null {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Null {
        #[inline]
        fn eq(&self, other: &Null) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Null {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Null,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Null {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Null,
                crate::whitespace::ws(crate::term::ident_tag("null")),
            )(input)
        }
    }
    /// Represents the terminal symbol `object`
    pub struct Object;
    #[automatically_derived]
    impl ::core::clone::Clone for Object {
        #[inline]
        fn clone(&self) -> Object {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Object {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Object {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Object")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Object {
        #[inline]
        fn default() -> Object {
            Object {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Object {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Object {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Object {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Object {
        #[inline]
        fn cmp(&self, other: &Object) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Object {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Object {
        #[inline]
        fn eq(&self, other: &Object) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Object {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Object,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Object {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Object,
                crate::whitespace::ws(crate::term::ident_tag("object")),
            )(input)
        }
    }
    /// Represents the terminal symbol `octet`
    pub struct Octet;
    #[automatically_derived]
    impl ::core::clone::Clone for Octet {
        #[inline]
        fn clone(&self) -> Octet {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Octet {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Octet {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Octet")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Octet {
        #[inline]
        fn default() -> Octet {
            Octet {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Octet {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Octet {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Octet {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Octet {
        #[inline]
        fn cmp(&self, other: &Octet) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Octet {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Octet {
        #[inline]
        fn eq(&self, other: &Octet) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Octet {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Octet,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Octet {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Octet,
                crate::whitespace::ws(crate::term::ident_tag("octet")),
            )(input)
        }
    }
    /// Represents the terminal symbol `sequence`
    pub struct Sequence;
    #[automatically_derived]
    impl ::core::clone::Clone for Sequence {
        #[inline]
        fn clone(&self) -> Sequence {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Sequence {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Sequence {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Sequence")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Sequence {
        #[inline]
        fn default() -> Sequence {
            Sequence {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Sequence {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Sequence {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Sequence {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Sequence {
        #[inline]
        fn cmp(&self, other: &Sequence) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Sequence {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Sequence {
        #[inline]
        fn eq(&self, other: &Sequence) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Sequence {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Sequence,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Sequence {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Sequence,
                crate::whitespace::ws(crate::term::ident_tag("sequence")),
            )(input)
        }
    }
    /// Represents the terminal symbol `short`
    pub struct Short;
    #[automatically_derived]
    impl ::core::clone::Clone for Short {
        #[inline]
        fn clone(&self) -> Short {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Short {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Short {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Short")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Short {
        #[inline]
        fn default() -> Short {
            Short {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Short {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Short {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Short {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Short {
        #[inline]
        fn cmp(&self, other: &Short) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Short {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Short {
        #[inline]
        fn eq(&self, other: &Short) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Short {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Short,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Short {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Short,
                crate::whitespace::ws(crate::term::ident_tag("short")),
            )(input)
        }
    }
    /// Represents the terminal symbol `true`
    pub struct True;
    #[automatically_derived]
    impl ::core::clone::Clone for True {
        #[inline]
        fn clone(&self) -> True {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for True {}
    #[automatically_derived]
    impl ::core::fmt::Debug for True {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "True")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for True {
        #[inline]
        fn default() -> True {
            True {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for True {}
    #[automatically_derived]
    impl ::core::cmp::Eq for True {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for True {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for True {
        #[inline]
        fn cmp(&self, other: &True) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for True {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for True {
        #[inline]
        fn eq(&self, other: &True) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for True {
        #[inline]
        fn partial_cmp(
            &self,
            other: &True,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for True {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                True,
                crate::whitespace::ws(crate::term::ident_tag("true")),
            )(input)
        }
    }
    /// Represents the terminal symbol `unsigned`
    pub struct Unsigned;
    #[automatically_derived]
    impl ::core::clone::Clone for Unsigned {
        #[inline]
        fn clone(&self) -> Unsigned {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Unsigned {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Unsigned {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Unsigned")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Unsigned {
        #[inline]
        fn default() -> Unsigned {
            Unsigned {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Unsigned {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Unsigned {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Unsigned {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Unsigned {
        #[inline]
        fn cmp(&self, other: &Unsigned) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Unsigned {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Unsigned {
        #[inline]
        fn eq(&self, other: &Unsigned) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Unsigned {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Unsigned,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Unsigned {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Unsigned,
                crate::whitespace::ws(crate::term::ident_tag("unsigned")),
            )(input)
        }
    }
    /// Represents the terminal symbol `undefined`
    pub struct Undefined;
    #[automatically_derived]
    impl ::core::clone::Clone for Undefined {
        #[inline]
        fn clone(&self) -> Undefined {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Undefined {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Undefined {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Undefined")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Undefined {
        #[inline]
        fn default() -> Undefined {
            Undefined {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Undefined {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Undefined {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Undefined {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Undefined {
        #[inline]
        fn cmp(&self, other: &Undefined) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Undefined {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Undefined {
        #[inline]
        fn eq(&self, other: &Undefined) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Undefined {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Undefined,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Undefined {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Undefined,
                crate::whitespace::ws(crate::term::ident_tag("undefined")),
            )(input)
        }
    }
    /// Represents the terminal symbol `record`
    pub struct Record;
    #[automatically_derived]
    impl ::core::clone::Clone for Record {
        #[inline]
        fn clone(&self) -> Record {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Record {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Record {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Record")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Record {
        #[inline]
        fn default() -> Record {
            Record {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Record {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Record {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Record {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Record {
        #[inline]
        fn cmp(&self, other: &Record) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Record {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Record {
        #[inline]
        fn eq(&self, other: &Record) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Record {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Record,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Record {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Record,
                crate::whitespace::ws(crate::term::ident_tag("record")),
            )(input)
        }
    }
    /// Represents the terminal symbol `ArrayBuffer`
    pub struct ArrayBuffer;
    #[automatically_derived]
    impl ::core::clone::Clone for ArrayBuffer {
        #[inline]
        fn clone(&self) -> ArrayBuffer {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ArrayBuffer {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ArrayBuffer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ArrayBuffer")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ArrayBuffer {
        #[inline]
        fn default() -> ArrayBuffer {
            ArrayBuffer {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ArrayBuffer {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ArrayBuffer {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ArrayBuffer {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ArrayBuffer {
        #[inline]
        fn cmp(&self, other: &ArrayBuffer) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ArrayBuffer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ArrayBuffer {
        #[inline]
        fn eq(&self, other: &ArrayBuffer) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ArrayBuffer {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ArrayBuffer,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for ArrayBuffer {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                ArrayBuffer,
                crate::whitespace::ws(crate::term::ident_tag("ArrayBuffer")),
            )(input)
        }
    }
    /// Represents the terminal symbol `DataView`
    pub struct DataView;
    #[automatically_derived]
    impl ::core::clone::Clone for DataView {
        #[inline]
        fn clone(&self) -> DataView {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DataView {}
    #[automatically_derived]
    impl ::core::fmt::Debug for DataView {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "DataView")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for DataView {
        #[inline]
        fn default() -> DataView {
            DataView {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DataView {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DataView {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DataView {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DataView {
        #[inline]
        fn cmp(&self, other: &DataView) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DataView {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DataView {
        #[inline]
        fn eq(&self, other: &DataView) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DataView {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DataView,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for DataView {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                DataView,
                crate::whitespace::ws(crate::term::ident_tag("DataView")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Int8Array`
    pub struct Int8Array;
    #[automatically_derived]
    impl ::core::clone::Clone for Int8Array {
        #[inline]
        fn clone(&self) -> Int8Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Int8Array {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Int8Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Int8Array")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Int8Array {
        #[inline]
        fn default() -> Int8Array {
            Int8Array {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Int8Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Int8Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Int8Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Int8Array {
        #[inline]
        fn cmp(&self, other: &Int8Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Int8Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Int8Array {
        #[inline]
        fn eq(&self, other: &Int8Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Int8Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Int8Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Int8Array {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Int8Array,
                crate::whitespace::ws(crate::term::ident_tag("Int8Array")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Int16Array`
    pub struct Int16Array;
    #[automatically_derived]
    impl ::core::clone::Clone for Int16Array {
        #[inline]
        fn clone(&self) -> Int16Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Int16Array {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Int16Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Int16Array")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Int16Array {
        #[inline]
        fn default() -> Int16Array {
            Int16Array {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Int16Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Int16Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Int16Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Int16Array {
        #[inline]
        fn cmp(&self, other: &Int16Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Int16Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Int16Array {
        #[inline]
        fn eq(&self, other: &Int16Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Int16Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Int16Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Int16Array {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Int16Array,
                crate::whitespace::ws(crate::term::ident_tag("Int16Array")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Int32Array`
    pub struct Int32Array;
    #[automatically_derived]
    impl ::core::clone::Clone for Int32Array {
        #[inline]
        fn clone(&self) -> Int32Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Int32Array {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Int32Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Int32Array")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Int32Array {
        #[inline]
        fn default() -> Int32Array {
            Int32Array {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Int32Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Int32Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Int32Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Int32Array {
        #[inline]
        fn cmp(&self, other: &Int32Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Int32Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Int32Array {
        #[inline]
        fn eq(&self, other: &Int32Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Int32Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Int32Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Int32Array {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Int32Array,
                crate::whitespace::ws(crate::term::ident_tag("Int32Array")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Uint8Array`
    pub struct Uint8Array;
    #[automatically_derived]
    impl ::core::clone::Clone for Uint8Array {
        #[inline]
        fn clone(&self) -> Uint8Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Uint8Array {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Uint8Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uint8Array")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Uint8Array {
        #[inline]
        fn default() -> Uint8Array {
            Uint8Array {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Uint8Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Uint8Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Uint8Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Uint8Array {
        #[inline]
        fn cmp(&self, other: &Uint8Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uint8Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uint8Array {
        #[inline]
        fn eq(&self, other: &Uint8Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Uint8Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint8Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Uint8Array {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Uint8Array,
                crate::whitespace::ws(crate::term::ident_tag("Uint8Array")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Uint16Array`
    pub struct Uint16Array;
    #[automatically_derived]
    impl ::core::clone::Clone for Uint16Array {
        #[inline]
        fn clone(&self) -> Uint16Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Uint16Array {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Uint16Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uint16Array")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Uint16Array {
        #[inline]
        fn default() -> Uint16Array {
            Uint16Array {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Uint16Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Uint16Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Uint16Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Uint16Array {
        #[inline]
        fn cmp(&self, other: &Uint16Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uint16Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uint16Array {
        #[inline]
        fn eq(&self, other: &Uint16Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Uint16Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint16Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Uint16Array {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Uint16Array,
                crate::whitespace::ws(crate::term::ident_tag("Uint16Array")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Uint32Array`
    pub struct Uint32Array;
    #[automatically_derived]
    impl ::core::clone::Clone for Uint32Array {
        #[inline]
        fn clone(&self) -> Uint32Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Uint32Array {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Uint32Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uint32Array")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Uint32Array {
        #[inline]
        fn default() -> Uint32Array {
            Uint32Array {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Uint32Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Uint32Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Uint32Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Uint32Array {
        #[inline]
        fn cmp(&self, other: &Uint32Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uint32Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uint32Array {
        #[inline]
        fn eq(&self, other: &Uint32Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Uint32Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint32Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Uint32Array {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Uint32Array,
                crate::whitespace::ws(crate::term::ident_tag("Uint32Array")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Uint8ClampedArray`
    pub struct Uint8ClampedArray;
    #[automatically_derived]
    impl ::core::clone::Clone for Uint8ClampedArray {
        #[inline]
        fn clone(&self) -> Uint8ClampedArray {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Uint8ClampedArray {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Uint8ClampedArray {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Uint8ClampedArray")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Uint8ClampedArray {
        #[inline]
        fn default() -> Uint8ClampedArray {
            Uint8ClampedArray {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Uint8ClampedArray {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Uint8ClampedArray {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Uint8ClampedArray {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Uint8ClampedArray {
        #[inline]
        fn cmp(&self, other: &Uint8ClampedArray) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Uint8ClampedArray {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Uint8ClampedArray {
        #[inline]
        fn eq(&self, other: &Uint8ClampedArray) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Uint8ClampedArray {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Uint8ClampedArray,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Uint8ClampedArray {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Uint8ClampedArray,
                crate::whitespace::ws(crate::term::ident_tag("Uint8ClampedArray")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Float32Array`
    pub struct Float32Array;
    #[automatically_derived]
    impl ::core::clone::Clone for Float32Array {
        #[inline]
        fn clone(&self) -> Float32Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Float32Array {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Float32Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Float32Array")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Float32Array {
        #[inline]
        fn default() -> Float32Array {
            Float32Array {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Float32Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Float32Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Float32Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Float32Array {
        #[inline]
        fn cmp(&self, other: &Float32Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Float32Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Float32Array {
        #[inline]
        fn eq(&self, other: &Float32Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Float32Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Float32Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Float32Array {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Float32Array,
                crate::whitespace::ws(crate::term::ident_tag("Float32Array")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Float64Array`
    pub struct Float64Array;
    #[automatically_derived]
    impl ::core::clone::Clone for Float64Array {
        #[inline]
        fn clone(&self) -> Float64Array {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Float64Array {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Float64Array {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Float64Array")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Float64Array {
        #[inline]
        fn default() -> Float64Array {
            Float64Array {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Float64Array {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Float64Array {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Float64Array {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Float64Array {
        #[inline]
        fn cmp(&self, other: &Float64Array) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Float64Array {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Float64Array {
        #[inline]
        fn eq(&self, other: &Float64Array) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Float64Array {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Float64Array,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Float64Array {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Float64Array,
                crate::whitespace::ws(crate::term::ident_tag("Float64Array")),
            )(input)
        }
    }
    /// Represents the terminal symbol `ArrayBufferView`
    pub struct ArrayBufferView;
    #[automatically_derived]
    impl ::core::clone::Clone for ArrayBufferView {
        #[inline]
        fn clone(&self) -> ArrayBufferView {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ArrayBufferView {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ArrayBufferView {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ArrayBufferView")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ArrayBufferView {
        #[inline]
        fn default() -> ArrayBufferView {
            ArrayBufferView {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ArrayBufferView {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ArrayBufferView {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ArrayBufferView {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ArrayBufferView {
        #[inline]
        fn cmp(&self, other: &ArrayBufferView) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ArrayBufferView {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ArrayBufferView {
        #[inline]
        fn eq(&self, other: &ArrayBufferView) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ArrayBufferView {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ArrayBufferView,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for ArrayBufferView {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                ArrayBufferView,
                crate::whitespace::ws(crate::term::ident_tag("ArrayBufferView")),
            )(input)
        }
    }
    /// Represents the terminal symbol `BufferSource
    pub struct BufferSource;
    #[automatically_derived]
    impl ::core::clone::Clone for BufferSource {
        #[inline]
        fn clone(&self) -> BufferSource {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BufferSource {}
    #[automatically_derived]
    impl ::core::fmt::Debug for BufferSource {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "BufferSource")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for BufferSource {
        #[inline]
        fn default() -> BufferSource {
            BufferSource {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BufferSource {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BufferSource {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for BufferSource {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for BufferSource {
        #[inline]
        fn cmp(&self, other: &BufferSource) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BufferSource {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BufferSource {
        #[inline]
        fn eq(&self, other: &BufferSource) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for BufferSource {
        #[inline]
        fn partial_cmp(
            &self,
            other: &BufferSource,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for BufferSource {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                BufferSource,
                crate::whitespace::ws(crate::term::ident_tag("BufferSource")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Promise`
    pub struct Promise;
    #[automatically_derived]
    impl ::core::clone::Clone for Promise {
        #[inline]
        fn clone(&self) -> Promise {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Promise {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Promise {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Promise")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Promise {
        #[inline]
        fn default() -> Promise {
            Promise {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Promise {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Promise {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Promise {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Promise {
        #[inline]
        fn cmp(&self, other: &Promise) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Promise {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Promise {
        #[inline]
        fn eq(&self, other: &Promise) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Promise {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Promise,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Promise {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Promise,
                crate::whitespace::ws(crate::term::ident_tag("Promise")),
            )(input)
        }
    }
    /// Represents the terminal symbol `Error`
    pub struct Error;
    #[automatically_derived]
    impl ::core::clone::Clone for Error {
        #[inline]
        fn clone(&self) -> Error {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Error {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Error")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Error {
        #[inline]
        fn default() -> Error {
            Error {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Error {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Error {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Error {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Error {
        #[inline]
        fn cmp(&self, other: &Error) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Error {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Error {
        #[inline]
        fn eq(&self, other: &Error) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Error {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Error,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Error {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Error,
                crate::whitespace::ws(crate::term::ident_tag("Error")),
            )(input)
        }
    }
    /// Represents the terminal symbol `readonly`
    pub struct ReadOnly;
    #[automatically_derived]
    impl ::core::clone::Clone for ReadOnly {
        #[inline]
        fn clone(&self) -> ReadOnly {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ReadOnly {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ReadOnly {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ReadOnly")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ReadOnly {
        #[inline]
        fn default() -> ReadOnly {
            ReadOnly {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ReadOnly {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ReadOnly {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ReadOnly {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ReadOnly {
        #[inline]
        fn cmp(&self, other: &ReadOnly) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ReadOnly {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ReadOnly {
        #[inline]
        fn eq(&self, other: &ReadOnly) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ReadOnly {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ReadOnly,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for ReadOnly {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                ReadOnly,
                crate::whitespace::ws(crate::term::ident_tag("readonly")),
            )(input)
        }
    }
    /// Represents the terminal symbol `mixin`
    pub struct Mixin;
    #[automatically_derived]
    impl ::core::clone::Clone for Mixin {
        #[inline]
        fn clone(&self) -> Mixin {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Mixin {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Mixin {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Mixin")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Mixin {
        #[inline]
        fn default() -> Mixin {
            Mixin {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Mixin {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Mixin {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Mixin {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Mixin {
        #[inline]
        fn cmp(&self, other: &Mixin) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Mixin {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Mixin {
        #[inline]
        fn eq(&self, other: &Mixin) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Mixin {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Mixin,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Mixin {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Mixin,
                crate::whitespace::ws(crate::term::ident_tag("mixin")),
            )(input)
        }
    }
    /// Represents the terminal symbol `implements`
    pub struct Implements;
    #[automatically_derived]
    impl ::core::clone::Clone for Implements {
        #[inline]
        fn clone(&self) -> Implements {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Implements {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Implements {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Implements")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Implements {
        #[inline]
        fn default() -> Implements {
            Implements {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Implements {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Implements {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Implements {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Implements {
        #[inline]
        fn cmp(&self, other: &Implements) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Implements {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Implements {
        #[inline]
        fn eq(&self, other: &Implements) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Implements {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Implements,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Implements {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Implements,
                crate::whitespace::ws(crate::term::ident_tag("implements")),
            )(input)
        }
    }
    /// Represents the terminal symbol `legacycaller`
    pub struct LegacyCaller;
    #[automatically_derived]
    impl ::core::clone::Clone for LegacyCaller {
        #[inline]
        fn clone(&self) -> LegacyCaller {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for LegacyCaller {}
    #[automatically_derived]
    impl ::core::fmt::Debug for LegacyCaller {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "LegacyCaller")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for LegacyCaller {
        #[inline]
        fn default() -> LegacyCaller {
            LegacyCaller {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for LegacyCaller {}
    #[automatically_derived]
    impl ::core::cmp::Eq for LegacyCaller {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for LegacyCaller {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for LegacyCaller {
        #[inline]
        fn cmp(&self, other: &LegacyCaller) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LegacyCaller {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LegacyCaller {
        #[inline]
        fn eq(&self, other: &LegacyCaller) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for LegacyCaller {
        #[inline]
        fn partial_cmp(
            &self,
            other: &LegacyCaller,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for LegacyCaller {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                LegacyCaller,
                crate::whitespace::ws(crate::term::ident_tag("legacycaller")),
            )(input)
        }
    }
    /// Represents the terminal symbol `constructor`
    pub struct Constructor;
    #[automatically_derived]
    impl ::core::clone::Clone for Constructor {
        #[inline]
        fn clone(&self) -> Constructor {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Constructor {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Constructor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Constructor")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Constructor {
        #[inline]
        fn default() -> Constructor {
            Constructor {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Constructor {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Constructor {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Constructor {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Constructor {
        #[inline]
        fn cmp(&self, other: &Constructor) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Constructor {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Constructor {
        #[inline]
        fn eq(&self, other: &Constructor) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Constructor {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Constructor,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    impl<'a> crate::Parse<'a> for Constructor {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::value(
                Constructor,
                crate::whitespace::ws(crate::term::ident_tag("constructor")),
            )(input)
        }
    }
}
pub mod argument {
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Default, Identifier, Punctuated};
    use crate::types::{AttributedType, Type};
    /// Parses a list of argument. Ex: `double v1, double v2, double v3, optional double alpha`
    pub type ArgumentList<'a> = Punctuated<Argument<'a>, crate::term::Comma>;
    /// Parses an argument. Ex: `double v1|double... v1s`
    pub enum Argument<'a> {
        Single(SingleArgument<'a>),
        Variadic(VariadicArgument<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Argument<'a> {
        #[inline]
        fn clone(&self) -> Argument<'a> {
            match self {
                Argument::Single(__self_0) => {
                    Argument::Single(::core::clone::Clone::clone(__self_0))
                }
                Argument::Variadic(__self_0) => {
                    Argument::Variadic(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Argument<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Argument::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                Argument::Variadic(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Variadic",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Argument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Argument<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<SingleArgument<'a>>;
            let _: ::core::cmp::AssertParamIsEq<VariadicArgument<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Argument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Argument<'a> {
        #[inline]
        fn eq(&self, other: &Argument<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Argument::Single(__self_0), Argument::Single(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Argument::Variadic(__self_0), Argument::Variadic(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Argument<'a> {
        #[inline]
        fn cmp(&self, other: &Argument<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Argument::Single(__self_0), Argument::Single(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Argument::Variadic(__self_0), Argument::Variadic(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Argument<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Argument<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Argument::Single(__self_0), Argument::Single(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Argument::Variadic(__self_0), Argument::Variadic(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Argument<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Argument::Single(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Argument::Variadic(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    /// Parses `[attributes]? optional? attributedtype identifier ( = default )?`
    ///
    /// Note: `= default` is only allowed if `optional` is present
    pub struct SingleArgument<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub optional: Option<crate::term::Optional>,
        pub type_: AttributedType<'a>,
        pub identifier: Identifier<'a>,
        pub default: Option<Default<'a>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SingleArgument<'a> {
        #[inline]
        fn clone(&self) -> SingleArgument<'a> {
            SingleArgument {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                optional: ::core::clone::Clone::clone(&self.optional),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                default: ::core::clone::Clone::clone(&self.default),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SingleArgument<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SingleArgument",
                "attributes",
                &&self.attributes,
                "optional",
                &&self.optional,
                "type_",
                &&self.type_,
                "identifier",
                &&self.identifier,
                "default",
                &&self.default,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SingleArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SingleArgument<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Optional>>;
            let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Default<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SingleArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SingleArgument<'a> {
        #[inline]
        fn eq(&self, other: &SingleArgument<'a>) -> bool {
            self.attributes == other.attributes && self.optional == other.optional
                && self.type_ == other.type_ && self.identifier == other.identifier
                && self.default == other.default
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SingleArgument<'a> {
        #[inline]
        fn cmp(&self, other: &SingleArgument<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.optional, &other.optional) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.default, &other.default)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SingleArgument<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SingleArgument<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.optional,
                        &other.optional,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.type_,
                                &other.type_,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.default,
                                                &other.default,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SingleArgument<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.optional, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.default, state)
        }
    }
    impl<'a> crate::Parse<'a> for SingleArgument<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Option<
                            crate::term::Optional,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, optional)) => {
                                use nom::lib::std::result::Result::*;
                                match <AttributedType<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, type_)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, identifier)) => {
                                                use nom::lib::std::result::Result::*;
                                                match nom::combinator::map(
                                                    nom::combinator::cond(
                                                        optional.is_some(),
                                                        <Option<Default<'a>> as crate::Parse<'a>>::parse,
                                                    ),
                                                    |default| default.unwrap_or(None),
                                                )(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, default)) => {
                                                        use nom::lib::std::result::Result::Ok;
                                                        Ok((
                                                            i,
                                                            Self {
                                                                attributes,
                                                                optional,
                                                                type_,
                                                                identifier,
                                                                default,
                                                            },
                                                        ))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[attributes]? type... identifier`
    pub struct VariadicArgument<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub type_: Type<'a>,
        pub ellipsis: crate::term::Ellipsis,
        pub identifier: Identifier<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for VariadicArgument<'a> {
        #[inline]
        fn clone(&self) -> VariadicArgument<'a> {
            VariadicArgument {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                type_: ::core::clone::Clone::clone(&self.type_),
                ellipsis: ::core::clone::Clone::clone(&self.ellipsis),
                identifier: ::core::clone::Clone::clone(&self.identifier),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for VariadicArgument<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "VariadicArgument",
                "attributes",
                &&self.attributes,
                "type_",
                &&self.type_,
                "ellipsis",
                &&self.ellipsis,
                "identifier",
                &&self.identifier,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for VariadicArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for VariadicArgument<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Ellipsis>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for VariadicArgument<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for VariadicArgument<'a> {
        #[inline]
        fn eq(&self, other: &VariadicArgument<'a>) -> bool {
            self.attributes == other.attributes && self.type_ == other.type_
                && self.ellipsis == other.ellipsis && self.identifier == other.identifier
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for VariadicArgument<'a> {
        #[inline]
        fn cmp(&self, other: &VariadicArgument<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.ellipsis,
                                &other.ellipsis,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.identifier, &other.identifier)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for VariadicArgument<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &VariadicArgument<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.type_,
                        &other.type_,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.ellipsis,
                                &other.ellipsis,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for VariadicArgument<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.ellipsis, state);
            ::core::hash::Hash::hash(&self.identifier, state)
        }
    }
    impl<'a> crate::Parse<'a> for VariadicArgument<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Type<'a> as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, type_)) => {
                                use nom::lib::std::result::Result::*;
                                match <crate::term::Ellipsis as crate::Parse<
                                    'a,
                                >>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, ellipsis)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, identifier)) => {
                                                use nom::lib::std::result::Result::Ok;
                                                Ok((
                                                    i,
                                                    Self {
                                                        attributes,
                                                        type_,
                                                        ellipsis,
                                                        identifier,
                                                    },
                                                ))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    impl<'a> From<SingleArgument<'a>> for Argument<'a> {
        fn from(x: SingleArgument<'a>) -> Self {
            Argument::Single(x)
        }
    }
    impl<'a> From<VariadicArgument<'a>> for Argument<'a> {
        fn from(x: VariadicArgument<'a>) -> Self {
            Argument::Variadic(x)
        }
    }
    impl<'a> crate::Parse<'a> for Argument<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <SingleArgument<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <VariadicArgument<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
}
pub mod attribute {
    use crate::argument::ArgumentList;
    use crate::common::{Bracketed, Identifier, Parenthesized, Punctuated};
    use crate::literal::{FloatLit, IntegerLit, StringLit};
    /// Parses a list of attributes. Ex: `[ attribute1, attribute2 ]`
    pub type ExtendedAttributeList<'a> = Bracketed<
        Punctuated<ExtendedAttribute<'a>, crate::term::Comma>,
    >;
    /// Matches comma separated identifier list
    pub type IdentifierList<'a> = Punctuated<Identifier<'a>, crate::term::Comma>;
    pub type StringList<'a> = Punctuated<StringLit<'a>, crate::term::Comma>;
    pub type FloatList<'a> = Punctuated<FloatLit<'a>, crate::term::Comma>;
    pub type IntegerList<'a> = Punctuated<IntegerLit<'a>, crate::term::Comma>;
    /// Parses on of the forms of attribute
    pub enum ExtendedAttribute<'a> {
        ArgList(ExtendedAttributeArgList<'a>),
        NamedArgList(ExtendedAttributeNamedArgList<'a>),
        IdentList(ExtendedAttributeIdentList<'a>),
        Ident(ExtendedAttributeIdent<'a>),
        Wildcard(ExtendedAttributeWildcard<'a>),
        String(ExtendedAttributeString<'a>),
        StringList(ExtendedAttributeStringList<'a>),
        Float(ExtendedAttributeFloat<'a>),
        FloatList(ExtendedAttributeFloatList<'a>),
        Integer(ExtendedAttributeInteger<'a>),
        IntegerList(ExtendedAttributeIntegerList<'a>),
        NoArgs(ExtendedAttributeNoArgs<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttribute<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttribute<'a> {
            match self {
                ExtendedAttribute::ArgList(__self_0) => {
                    ExtendedAttribute::ArgList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::NamedArgList(__self_0) => {
                    ExtendedAttribute::NamedArgList(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                ExtendedAttribute::IdentList(__self_0) => {
                    ExtendedAttribute::IdentList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::Ident(__self_0) => {
                    ExtendedAttribute::Ident(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::Wildcard(__self_0) => {
                    ExtendedAttribute::Wildcard(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::String(__self_0) => {
                    ExtendedAttribute::String(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::StringList(__self_0) => {
                    ExtendedAttribute::StringList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::Float(__self_0) => {
                    ExtendedAttribute::Float(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::FloatList(__self_0) => {
                    ExtendedAttribute::FloatList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::Integer(__self_0) => {
                    ExtendedAttribute::Integer(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::IntegerList(__self_0) => {
                    ExtendedAttribute::IntegerList(::core::clone::Clone::clone(__self_0))
                }
                ExtendedAttribute::NoArgs(__self_0) => {
                    ExtendedAttribute::NoArgs(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttribute<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ExtendedAttribute::ArgList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ArgList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::NamedArgList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NamedArgList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::IdentList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "IdentList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::Ident(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Ident",
                        &__self_0,
                    )
                }
                ExtendedAttribute::Wildcard(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Wildcard",
                        &__self_0,
                    )
                }
                ExtendedAttribute::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                ExtendedAttribute::StringList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StringList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                ExtendedAttribute::FloatList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FloatList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                ExtendedAttribute::IntegerList(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "IntegerList",
                        &__self_0,
                    )
                }
                ExtendedAttribute::NoArgs(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NoArgs",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttribute<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttribute<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeArgList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeNamedArgList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeIdentList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeIdent<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeWildcard<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeString<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeStringList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeFloat<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeFloatList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeInteger<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeIntegerList<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeNoArgs<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttribute<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttribute<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttribute<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        ExtendedAttribute::ArgList(__self_0),
                        ExtendedAttribute::ArgList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::NamedArgList(__self_0),
                        ExtendedAttribute::NamedArgList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::IdentList(__self_0),
                        ExtendedAttribute::IdentList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::Ident(__self_0),
                        ExtendedAttribute::Ident(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::Wildcard(__self_0),
                        ExtendedAttribute::Wildcard(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::String(__self_0),
                        ExtendedAttribute::String(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::StringList(__self_0),
                        ExtendedAttribute::StringList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::Float(__self_0),
                        ExtendedAttribute::Float(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::FloatList(__self_0),
                        ExtendedAttribute::FloatList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::Integer(__self_0),
                        ExtendedAttribute::Integer(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::IntegerList(__self_0),
                        ExtendedAttribute::IntegerList(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        ExtendedAttribute::NoArgs(__self_0),
                        ExtendedAttribute::NoArgs(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttribute<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttribute<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            ExtendedAttribute::ArgList(__self_0),
                            ExtendedAttribute::ArgList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::NamedArgList(__self_0),
                            ExtendedAttribute::NamedArgList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::IdentList(__self_0),
                            ExtendedAttribute::IdentList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Ident(__self_0),
                            ExtendedAttribute::Ident(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Wildcard(__self_0),
                            ExtendedAttribute::Wildcard(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::String(__self_0),
                            ExtendedAttribute::String(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::StringList(__self_0),
                            ExtendedAttribute::StringList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Float(__self_0),
                            ExtendedAttribute::Float(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::FloatList(__self_0),
                            ExtendedAttribute::FloatList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Integer(__self_0),
                            ExtendedAttribute::Integer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::IntegerList(__self_0),
                            ExtendedAttribute::IntegerList(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::NoArgs(__self_0),
                            ExtendedAttribute::NoArgs(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttribute<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttribute<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            ExtendedAttribute::ArgList(__self_0),
                            ExtendedAttribute::ArgList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::NamedArgList(__self_0),
                            ExtendedAttribute::NamedArgList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::IdentList(__self_0),
                            ExtendedAttribute::IdentList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Ident(__self_0),
                            ExtendedAttribute::Ident(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Wildcard(__self_0),
                            ExtendedAttribute::Wildcard(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::String(__self_0),
                            ExtendedAttribute::String(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::StringList(__self_0),
                            ExtendedAttribute::StringList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Float(__self_0),
                            ExtendedAttribute::Float(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::FloatList(__self_0),
                            ExtendedAttribute::FloatList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::Integer(__self_0),
                            ExtendedAttribute::Integer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::IntegerList(__self_0),
                            ExtendedAttribute::IntegerList(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            ExtendedAttribute::NoArgs(__self_0),
                            ExtendedAttribute::NoArgs(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttribute<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                ExtendedAttribute::ArgList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::NamedArgList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::IdentList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::Ident(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::Wildcard(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::String(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::StringList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::Float(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::FloatList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::Integer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::IntegerList(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ExtendedAttribute::NoArgs(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses an argument list. Ex: `Constructor((double x, double y))`
    ///
    /// (( )) means ( ) chars
    pub struct ExtendedAttributeArgList<'a> {
        pub identifier: Identifier<'a>,
        pub args: Parenthesized<ArgumentList<'a>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeArgList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeArgList<'a> {
            ExtendedAttributeArgList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                args: ::core::clone::Clone::clone(&self.args),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeArgList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ExtendedAttributeArgList",
                "identifier",
                &&self.identifier,
                "args",
                &&self.args,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeArgList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeArgList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeArgList<'a>) -> bool {
            self.identifier == other.identifier && self.args == other.args
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeArgList<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeArgList<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.args, &other.args)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeArgList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeArgList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.args, &other.args)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeArgList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.args, state)
        }
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeArgList<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <Parenthesized<
                            ArgumentList<'a>,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, args)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { identifier, args }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses a named argument list. Ex: `NamedConstructor=Image((DOMString src))`
    ///
    /// (( )) means ( ) chars
    pub struct ExtendedAttributeNamedArgList<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs_identifier: Identifier<'a>,
        pub args: Parenthesized<ArgumentList<'a>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeNamedArgList<'a> {
            ExtendedAttributeNamedArgList {
                lhs_identifier: ::core::clone::Clone::clone(&self.lhs_identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                rhs_identifier: ::core::clone::Clone::clone(&self.rhs_identifier),
                args: ::core::clone::Clone::clone(&self.args),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeNamedArgList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ExtendedAttributeNamedArgList",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs_identifier",
                &&self.rhs_identifier,
                "args",
                &&self.args,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeNamedArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeNamedArgList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeNamedArgList<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs_identifier == other.rhs_identifier && self.args == other.args
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        fn cmp(
            &self,
            other: &ExtendedAttributeNamedArgList<'a>,
        ) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.rhs_identifier,
                                &other.rhs_identifier,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.args, &other.args)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeNamedArgList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeNamedArgList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.rhs_identifier,
                                &other.rhs_identifier,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.args,
                                        &other.args,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeNamedArgList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs_identifier, state);
            ::core::hash::Hash::hash(&self.args, state)
        }
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeNamedArgList<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, lhs_identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, rhs_identifier)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Parenthesized<
                                            ArgumentList<'a>,
                                        > as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, args)) => {
                                                use nom::lib::std::result::Result::Ok;
                                                Ok((
                                                    i,
                                                    Self {
                                                        lhs_identifier,
                                                        assign,
                                                        rhs_identifier,
                                                        args,
                                                    },
                                                ))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses an identifier list. Ex: `Exposed=((Window,Worker))`
    ///
    /// (( )) means ( ) chars
    pub struct ExtendedAttributeIdentList<'a> {
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub list: Parenthesized<IdentifierList<'a>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeIdentList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeIdentList<'a> {
            ExtendedAttributeIdentList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                list: ::core::clone::Clone::clone(&self.list),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeIdentList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeIdentList",
                "identifier",
                &&self.identifier,
                "assign",
                &&self.assign,
                "list",
                &&self.list,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeIdentList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeIdentList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<IdentifierList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeIdentList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeIdentList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeIdentList<'a>) -> bool {
            self.identifier == other.identifier && self.assign == other.assign
                && self.list == other.list
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeIdentList<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeIdentList<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeIdentList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeIdentList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeIdentList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.list, state)
        }
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeIdentList<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <Parenthesized<
                                    IdentifierList<'a>,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, list)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((i, Self { identifier, assign, list }))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses an attribute with an identifier. Ex: `PutForwards=name`
    pub struct ExtendedAttributeIdent<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs: Identifier<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeIdent<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeIdent<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeIdent<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeIdent",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs",
                &&self.rhs,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeIdent<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeIdent<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeIdent<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeIdent<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeIdent<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs == other.rhs
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeIdent<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeIdent<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeIdent<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeIdent<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeIdent<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeIdent<'a> {}
    impl<'a> crate::Parse<'a> for ExtendedAttributeIdent<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, lhs_identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, rhs)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                lhs_identifier,
                                                assign,
                                                rhs,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses an attribute with a wildcard. Ex: `Exposed=*`
    pub struct ExtendedAttributeWildcard<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub wildcard: crate::term::Wildcard,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeWildcard<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeWildcard<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Wildcard>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeWildcard<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeWildcard",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "wildcard",
                &&self.wildcard,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeWildcard<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeWildcard<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Wildcard>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeWildcard<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeWildcard<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeWildcard<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.wildcard == other.wildcard
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeWildcard<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeWildcard<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.wildcard, &other.wildcard)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeWildcard<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeWildcard<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.wildcard,
                                &other.wildcard,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeWildcard<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.wildcard, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeWildcard<'a> {}
    impl<'a> crate::Parse<'a> for ExtendedAttributeWildcard<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, lhs_identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <crate::term::Wildcard as crate::Parse<
                                    'a,
                                >>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, wildcard)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                lhs_identifier,
                                                assign,
                                                wildcard,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Things that are not used by the standard Web IDL, but still allowed
    /// and used by others e.g. Blink and JSDOM
    /// https://github.com/w3c/webidl2.js/issues/256
    /// https://github.com/w3c/webidl2.js/issues/455
    /// Parses an attribute with a string. E: `ReflectOnly="on"`
    pub struct ExtendedAttributeString<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs: StringLit<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeString<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeString<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<StringLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeString<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeString",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs",
                &&self.rhs,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeString<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeString<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<StringLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeString<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeString<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeString<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs == other.rhs
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeString<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeString<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeString<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeString<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeString<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeString<'a> {}
    impl<'a> crate::Parse<'a> for ExtendedAttributeString<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, lhs_identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <StringLit<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, rhs)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                lhs_identifier,
                                                assign,
                                                rhs,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pub struct ExtendedAttributeStringList<'a> {
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub list: Parenthesized<StringList<'a>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeStringList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeStringList<'a> {
            ExtendedAttributeStringList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                list: ::core::clone::Clone::clone(&self.list),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeStringList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeStringList",
                "identifier",
                &&self.identifier,
                "assign",
                &&self.assign,
                "list",
                &&self.list,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeStringList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeStringList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<StringList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeStringList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeStringList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeStringList<'a>) -> bool {
            self.identifier == other.identifier && self.assign == other.assign
                && self.list == other.list
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeStringList<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeStringList<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeStringList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeStringList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeStringList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.list, state)
        }
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeStringList<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <Parenthesized<
                                    StringList<'a>,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, list)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((i, Self { identifier, assign, list }))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pub struct ExtendedAttributeFloat<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs: FloatLit<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeFloat<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeFloat<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<FloatLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeFloat<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeFloat",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs",
                &&self.rhs,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeFloat<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeFloat<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<FloatLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeFloat<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeFloat<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeFloat<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs == other.rhs
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeFloat<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeFloat<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeFloat<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeFloat<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeFloat<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeFloat<'a> {}
    impl<'a> crate::Parse<'a> for ExtendedAttributeFloat<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, lhs_identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <FloatLit<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, rhs)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                lhs_identifier,
                                                assign,
                                                rhs,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pub struct ExtendedAttributeFloatList<'a> {
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub list: Parenthesized<FloatList<'a>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeFloatList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeFloatList<'a> {
            ExtendedAttributeFloatList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                list: ::core::clone::Clone::clone(&self.list),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeFloatList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeFloatList",
                "identifier",
                &&self.identifier,
                "assign",
                &&self.assign,
                "list",
                &&self.list,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeFloatList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeFloatList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<FloatList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeFloatList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeFloatList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeFloatList<'a>) -> bool {
            self.identifier == other.identifier && self.assign == other.assign
                && self.list == other.list
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeFloatList<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeFloatList<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeFloatList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeFloatList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeFloatList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.list, state)
        }
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeFloatList<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <Parenthesized<
                                    FloatList<'a>,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, list)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((i, Self { identifier, assign, list }))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pub struct ExtendedAttributeInteger<'a> {
        pub lhs_identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub rhs: IntegerLit<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeInteger<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeInteger<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<IntegerLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeInteger<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeInteger",
                "lhs_identifier",
                &&self.lhs_identifier,
                "assign",
                &&self.assign,
                "rhs",
                &&self.rhs,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeInteger<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeInteger<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<IntegerLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeInteger<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeInteger<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeInteger<'a>) -> bool {
            self.lhs_identifier == other.lhs_identifier && self.assign == other.assign
                && self.rhs == other.rhs
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeInteger<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeInteger<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.lhs_identifier, &other.lhs_identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeInteger<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeInteger<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.lhs_identifier,
                &other.lhs_identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.rhs, &other.rhs)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeInteger<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.lhs_identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.rhs, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeInteger<'a> {}
    impl<'a> crate::Parse<'a> for ExtendedAttributeInteger<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, lhs_identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <IntegerLit<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, rhs)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                lhs_identifier,
                                                assign,
                                                rhs,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pub struct ExtendedAttributeIntegerList<'a> {
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub list: Parenthesized<IntegerList<'a>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeIntegerList<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeIntegerList<'a> {
            ExtendedAttributeIntegerList {
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                list: ::core::clone::Clone::clone(&self.list),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeIntegerList<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ExtendedAttributeIntegerList",
                "identifier",
                &&self.identifier,
                "assign",
                &&self.assign,
                "list",
                &&self.list,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeIntegerList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeIntegerList<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<IntegerList<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeIntegerList<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeIntegerList<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeIntegerList<'a>) -> bool {
            self.identifier == other.identifier && self.assign == other.assign
                && self.list == other.list
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeIntegerList<'a> {
        #[inline]
        fn cmp(
            &self,
            other: &ExtendedAttributeIntegerList<'a>,
        ) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.identifier, &other.identifier) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeIntegerList<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeIntegerList<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.identifier,
                &other.identifier,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.assign,
                        &other.assign,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeIntegerList<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.list, state)
        }
    }
    impl<'a> crate::Parse<'a> for ExtendedAttributeIntegerList<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, identifier)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, assign)) => {
                                use nom::lib::std::result::Result::*;
                                match <Parenthesized<
                                    IntegerList<'a>,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, list)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((i, Self { identifier, assign, list }))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses a plain attribute. Ex: `Replaceable`
    pub struct ExtendedAttributeNoArgs<'a>(pub Identifier<'a>);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ExtendedAttributeNoArgs<'a> {
        #[inline]
        fn clone(&self) -> ExtendedAttributeNoArgs<'a> {
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ExtendedAttributeNoArgs<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "ExtendedAttributeNoArgs",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ExtendedAttributeNoArgs<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ExtendedAttributeNoArgs<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeNoArgs<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ExtendedAttributeNoArgs<'a> {
        #[inline]
        fn eq(&self, other: &ExtendedAttributeNoArgs<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ExtendedAttributeNoArgs<'a> {
        #[inline]
        fn cmp(&self, other: &ExtendedAttributeNoArgs<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeNoArgs<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExtendedAttributeNoArgs<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ExtendedAttributeNoArgs<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ExtendedAttributeNoArgs<'a> {}
    impl<'a> crate::Parse<'a> for ExtendedAttributeNoArgs<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::*;
            match <Identifier<'a> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, inner)) => Ok((i, ExtendedAttributeNoArgs(inner))),
            }
        }
    }
    impl<'a> From<ExtendedAttributeArgList<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeArgList<'a>) -> Self {
            ExtendedAttribute::ArgList(x)
        }
    }
    impl<'a> From<ExtendedAttributeNamedArgList<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeNamedArgList<'a>) -> Self {
            ExtendedAttribute::NamedArgList(x)
        }
    }
    impl<'a> From<ExtendedAttributeIdentList<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeIdentList<'a>) -> Self {
            ExtendedAttribute::IdentList(x)
        }
    }
    impl<'a> From<ExtendedAttributeIdent<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeIdent<'a>) -> Self {
            ExtendedAttribute::Ident(x)
        }
    }
    impl<'a> From<ExtendedAttributeWildcard<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeWildcard<'a>) -> Self {
            ExtendedAttribute::Wildcard(x)
        }
    }
    impl<'a> From<ExtendedAttributeString<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeString<'a>) -> Self {
            ExtendedAttribute::String(x)
        }
    }
    impl<'a> From<ExtendedAttributeStringList<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeStringList<'a>) -> Self {
            ExtendedAttribute::StringList(x)
        }
    }
    impl<'a> From<ExtendedAttributeFloat<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeFloat<'a>) -> Self {
            ExtendedAttribute::Float(x)
        }
    }
    impl<'a> From<ExtendedAttributeFloatList<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeFloatList<'a>) -> Self {
            ExtendedAttribute::FloatList(x)
        }
    }
    impl<'a> From<ExtendedAttributeInteger<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeInteger<'a>) -> Self {
            ExtendedAttribute::Integer(x)
        }
    }
    impl<'a> From<ExtendedAttributeIntegerList<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeIntegerList<'a>) -> Self {
            ExtendedAttribute::IntegerList(x)
        }
    }
    impl<'a> From<ExtendedAttributeNoArgs<'a>> for ExtendedAttribute<'a> {
        fn from(x: ExtendedAttributeNoArgs<'a>) -> Self {
            ExtendedAttribute::NoArgs(x)
        }
    }
    impl<'a> crate::Parse<'a> for ExtendedAttribute<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <ExtendedAttributeArgList<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <ExtendedAttributeNamedArgList<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <ExtendedAttributeIdentList<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <ExtendedAttributeIdent<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::branch::alt((
                        nom::combinator::map(
                            <ExtendedAttributeWildcard<'a> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::combinator::map(
                            <ExtendedAttributeString<'a> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::branch::alt((
                            nom::combinator::map(
                                <ExtendedAttributeStringList<
                                    'a,
                                > as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                            nom::combinator::map(
                                <ExtendedAttributeFloat<'a> as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                            nom::branch::alt((
                                nom::combinator::map(
                                    <ExtendedAttributeFloatList<'a> as crate::Parse<'a>>::parse,
                                    From::from,
                                ),
                                nom::combinator::map(
                                    <ExtendedAttributeInteger<'a> as crate::Parse<'a>>::parse,
                                    From::from,
                                ),
                                nom::branch::alt((
                                    nom::combinator::map(
                                        <ExtendedAttributeIntegerList<
                                            'a,
                                        > as crate::Parse<'a>>::parse,
                                        From::from,
                                    ),
                                    nom::combinator::map(
                                        <ExtendedAttributeNoArgs<'a> as crate::Parse<'a>>::parse,
                                        From::from,
                                    ),
                                )),
                            )),
                        )),
                    )),
                )),
            ))(input)
        }
    }
}
pub mod common {
    use crate::literal::DefaultValue;
    use crate::{term, IResult, Parse};
    pub(crate) fn is_alphanum_underscore_dash(token: char) -> bool {
        nom::AsChar::is_alphanum(token)
            || match token {
                '_' | '-' => true,
                _ => false,
            }
    }
    fn marker<S>(i: &str) -> IResult<&str, S>
    where
        S: ::std::default::Default,
    {
        Ok((i, S::default()))
    }
    impl<'a, T: Parse<'a>> Parse<'a> for Option<T> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::opt(<T as crate::Parse<'a>>::parse)(input)
        }
    }
    impl<'a, T: Parse<'a>> Parse<'a> for Box<T> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::combinator::map(<T as crate::Parse<'a>>::parse, Box::new)(input)
        }
    }
    /// Parses `item1 item2 item3...`
    impl<'a, T: Parse<'a>> Parse<'a> for Vec<T> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::multi::many0(T::parse)(input)
        }
    }
    impl<'a, T: Parse<'a>, U: Parse<'a>> Parse<'a> for (T, U) {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::sequence::tuple((T::parse, U::parse))(input)
        }
    }
    impl<'a, T: Parse<'a>, U: Parse<'a>, V: Parse<'a>> Parse<'a> for (T, U, V) {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::sequence::tuple((T::parse, U::parse, V::parse))(input)
        }
    }
    /// Parses `( body )`
    pub struct Parenthesized<T> {
        pub open_paren: term::OpenParen,
        pub body: T,
        pub close_paren: term::CloseParen,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Parenthesized<T> {
        #[inline]
        fn clone(&self) -> Parenthesized<T> {
            Parenthesized {
                open_paren: ::core::clone::Clone::clone(&self.open_paren),
                body: ::core::clone::Clone::clone(&self.body),
                close_paren: ::core::clone::Clone::clone(&self.close_paren),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Parenthesized<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Parenthesized",
                "open_paren",
                &&self.open_paren,
                "body",
                &&self.body,
                "close_paren",
                &&self.close_paren,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for Parenthesized<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Parenthesized<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<term::OpenParen>;
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<term::CloseParen>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for Parenthesized<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Parenthesized<T> {
        #[inline]
        fn eq(&self, other: &Parenthesized<T>) -> bool {
            self.open_paren == other.open_paren && self.body == other.body
                && self.close_paren == other.close_paren
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Parenthesized<T> {
        #[inline]
        fn cmp(&self, other: &Parenthesized<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_paren, &other.open_paren) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.close_paren, &other.close_paren)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Parenthesized<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Parenthesized<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_paren,
                &other.open_paren,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.body, &other.body) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.close_paren,
                                &other.close_paren,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for Parenthesized<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_paren, state);
            ::core::hash::Hash::hash(&self.body, state);
            ::core::hash::Hash::hash(&self.close_paren, state)
        }
    }
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for Parenthesized<T> {}
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for Parenthesized<T> {
        #[inline]
        fn default() -> Parenthesized<T> {
            Parenthesized {
                open_paren: ::core::default::Default::default(),
                body: ::core::default::Default::default(),
                close_paren: ::core::default::Default::default(),
            }
        }
    }
    impl<'a, T> crate::Parse<'a> for Parenthesized<T>
    where
        T: Parse<'a>,
    {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <term::OpenParen as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, open_paren)) => {
                        use nom::lib::std::result::Result::*;
                        match <T as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, body)) => {
                                use nom::lib::std::result::Result::*;
                                match <term::CloseParen as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, close_paren)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                open_paren,
                                                body,
                                                close_paren,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[ body ]`
    pub struct Bracketed<T> {
        pub open_bracket: term::OpenBracket,
        pub body: T,
        pub close_bracket: term::CloseBracket,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Bracketed<T> {
        #[inline]
        fn clone(&self) -> Bracketed<T> {
            Bracketed {
                open_bracket: ::core::clone::Clone::clone(&self.open_bracket),
                body: ::core::clone::Clone::clone(&self.body),
                close_bracket: ::core::clone::Clone::clone(&self.close_bracket),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Bracketed<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Bracketed",
                "open_bracket",
                &&self.open_bracket,
                "body",
                &&self.body,
                "close_bracket",
                &&self.close_bracket,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for Bracketed<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Bracketed<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<term::OpenBracket>;
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<term::CloseBracket>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for Bracketed<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Bracketed<T> {
        #[inline]
        fn eq(&self, other: &Bracketed<T>) -> bool {
            self.open_bracket == other.open_bracket && self.body == other.body
                && self.close_bracket == other.close_bracket
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Bracketed<T> {
        #[inline]
        fn cmp(&self, other: &Bracketed<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_bracket, &other.open_bracket) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(
                                &self.close_bracket,
                                &other.close_bracket,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Bracketed<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bracketed<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_bracket,
                &other.open_bracket,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.body, &other.body) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.close_bracket,
                                &other.close_bracket,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for Bracketed<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_bracket, state);
            ::core::hash::Hash::hash(&self.body, state);
            ::core::hash::Hash::hash(&self.close_bracket, state)
        }
    }
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for Bracketed<T> {}
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for Bracketed<T> {
        #[inline]
        fn default() -> Bracketed<T> {
            Bracketed {
                open_bracket: ::core::default::Default::default(),
                body: ::core::default::Default::default(),
                close_bracket: ::core::default::Default::default(),
            }
        }
    }
    impl<'a, T> crate::Parse<'a> for Bracketed<T>
    where
        T: Parse<'a>,
    {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <term::OpenBracket as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, open_bracket)) => {
                        use nom::lib::std::result::Result::*;
                        match <T as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, body)) => {
                                use nom::lib::std::result::Result::*;
                                match <term::CloseBracket as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, close_bracket)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                open_bracket,
                                                body,
                                                close_bracket,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `{ body }`
    pub struct Braced<T> {
        pub open_brace: term::OpenBrace,
        pub body: T,
        pub close_brace: term::CloseBrace,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Braced<T> {
        #[inline]
        fn clone(&self) -> Braced<T> {
            Braced {
                open_brace: ::core::clone::Clone::clone(&self.open_brace),
                body: ::core::clone::Clone::clone(&self.body),
                close_brace: ::core::clone::Clone::clone(&self.close_brace),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Braced<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Braced",
                "open_brace",
                &&self.open_brace,
                "body",
                &&self.body,
                "close_brace",
                &&self.close_brace,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for Braced<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Braced<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<term::OpenBrace>;
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<term::CloseBrace>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for Braced<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Braced<T> {
        #[inline]
        fn eq(&self, other: &Braced<T>) -> bool {
            self.open_brace == other.open_brace && self.body == other.body
                && self.close_brace == other.close_brace
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Braced<T> {
        #[inline]
        fn cmp(&self, other: &Braced<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_brace, &other.open_brace) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.close_brace, &other.close_brace)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Braced<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Braced<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_brace,
                &other.open_brace,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.body, &other.body) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.close_brace,
                                &other.close_brace,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for Braced<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_brace, state);
            ::core::hash::Hash::hash(&self.body, state);
            ::core::hash::Hash::hash(&self.close_brace, state)
        }
    }
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for Braced<T> {}
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for Braced<T> {
        #[inline]
        fn default() -> Braced<T> {
            Braced {
                open_brace: ::core::default::Default::default(),
                body: ::core::default::Default::default(),
                close_brace: ::core::default::Default::default(),
            }
        }
    }
    impl<'a, T> crate::Parse<'a> for Braced<T>
    where
        T: Parse<'a>,
    {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <term::OpenBrace as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, open_brace)) => {
                        use nom::lib::std::result::Result::*;
                        match <T as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, body)) => {
                                use nom::lib::std::result::Result::*;
                                match <term::CloseBrace as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, close_brace)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                open_brace,
                                                body,
                                                close_brace,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `< body >`
    pub struct Generics<T> {
        pub open_angle: term::LessThan,
        pub body: T,
        pub close_angle: term::GreaterThan,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Generics<T> {
        #[inline]
        fn clone(&self) -> Generics<T> {
            Generics {
                open_angle: ::core::clone::Clone::clone(&self.open_angle),
                body: ::core::clone::Clone::clone(&self.body),
                close_angle: ::core::clone::Clone::clone(&self.close_angle),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Generics<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Generics",
                "open_angle",
                &&self.open_angle,
                "body",
                &&self.body,
                "close_angle",
                &&self.close_angle,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for Generics<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Generics<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<term::LessThan>;
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<term::GreaterThan>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for Generics<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Generics<T> {
        #[inline]
        fn eq(&self, other: &Generics<T>) -> bool {
            self.open_angle == other.open_angle && self.body == other.body
                && self.close_angle == other.close_angle
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Generics<T> {
        #[inline]
        fn cmp(&self, other: &Generics<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_angle, &other.open_angle) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.close_angle, &other.close_angle)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Generics<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Generics<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_angle,
                &other.open_angle,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.body, &other.body) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.close_angle,
                                &other.close_angle,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for Generics<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_angle, state);
            ::core::hash::Hash::hash(&self.body, state);
            ::core::hash::Hash::hash(&self.close_angle, state)
        }
    }
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for Generics<T> {}
    #[automatically_derived]
    impl<T: ::core::default::Default> ::core::default::Default for Generics<T> {
        #[inline]
        fn default() -> Generics<T> {
            Generics {
                open_angle: ::core::default::Default::default(),
                body: ::core::default::Default::default(),
                close_angle: ::core::default::Default::default(),
            }
        }
    }
    impl<'a, T> crate::Parse<'a> for Generics<T>
    where
        T: Parse<'a>,
    {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <term::LessThan as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, open_angle)) => {
                        use nom::lib::std::result::Result::*;
                        match <T as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, body)) => {
                                use nom::lib::std::result::Result::*;
                                match <term::GreaterThan as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, close_angle)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                open_angle,
                                                body,
                                                close_angle,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `(item1, item2, item3,...)?`
    pub struct Punctuated<T, S> {
        pub list: Vec<T>,
        pub separator: S,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone, S: ::core::clone::Clone> ::core::clone::Clone
    for Punctuated<T, S> {
        #[inline]
        fn clone(&self) -> Punctuated<T, S> {
            Punctuated {
                list: ::core::clone::Clone::clone(&self.list),
                separator: ::core::clone::Clone::clone(&self.separator),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug, S: ::core::fmt::Debug> ::core::fmt::Debug
    for Punctuated<T, S> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Punctuated",
                "list",
                &&self.list,
                "separator",
                &&self.separator,
            )
        }
    }
    #[automatically_derived]
    impl<T, S> ::core::marker::StructuralEq for Punctuated<T, S> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq, S: ::core::cmp::Eq> ::core::cmp::Eq for Punctuated<T, S> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Vec<T>>;
            let _: ::core::cmp::AssertParamIsEq<S>;
        }
    }
    #[automatically_derived]
    impl<T, S> ::core::marker::StructuralPartialEq for Punctuated<T, S> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq, S: ::core::cmp::PartialEq> ::core::cmp::PartialEq
    for Punctuated<T, S> {
        #[inline]
        fn eq(&self, other: &Punctuated<T, S>) -> bool {
            self.list == other.list && self.separator == other.separator
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord, S: ::core::cmp::Ord> ::core::cmp::Ord
    for Punctuated<T, S> {
        #[inline]
        fn cmp(&self, other: &Punctuated<T, S>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.list, &other.list) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.separator, &other.separator)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd, S: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd
    for Punctuated<T, S> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Punctuated<T, S>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.separator,
                        &other.separator,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash, S: ::core::hash::Hash> ::core::hash::Hash
    for Punctuated<T, S> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.list, state);
            ::core::hash::Hash::hash(&self.separator, state)
        }
    }
    impl<'a, T, S> crate::Parse<'a> for Punctuated<T, S>
    where
        T: Parse<'a>,
        S: Parse<'a> + ::std::default::Default,
    {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match nom::multi::separated_list0(
                    <S as crate::Parse<'a>>::parse,
                    <T as crate::Parse<'a>>::parse,
                )(input) {
                    Err(e) => Err(e),
                    Ok((i, list)) => {
                        use nom::lib::std::result::Result::*;
                        match marker(i) {
                            Err(e) => Err(e),
                            Ok((i, separator)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { list, separator }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `item1, item2, item3, ...`
    pub struct PunctuatedNonEmpty<T, S> {
        pub list: Vec<T>,
        pub separator: S,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone, S: ::core::clone::Clone> ::core::clone::Clone
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        fn clone(&self) -> PunctuatedNonEmpty<T, S> {
            PunctuatedNonEmpty {
                list: ::core::clone::Clone::clone(&self.list),
                separator: ::core::clone::Clone::clone(&self.separator),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug, S: ::core::fmt::Debug> ::core::fmt::Debug
    for PunctuatedNonEmpty<T, S> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "PunctuatedNonEmpty",
                "list",
                &&self.list,
                "separator",
                &&self.separator,
            )
        }
    }
    #[automatically_derived]
    impl<T, S> ::core::marker::StructuralEq for PunctuatedNonEmpty<T, S> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq, S: ::core::cmp::Eq> ::core::cmp::Eq
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Vec<T>>;
            let _: ::core::cmp::AssertParamIsEq<S>;
        }
    }
    #[automatically_derived]
    impl<T, S> ::core::marker::StructuralPartialEq for PunctuatedNonEmpty<T, S> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq, S: ::core::cmp::PartialEq> ::core::cmp::PartialEq
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        fn eq(&self, other: &PunctuatedNonEmpty<T, S>) -> bool {
            self.list == other.list && self.separator == other.separator
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord, S: ::core::cmp::Ord> ::core::cmp::Ord
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        fn cmp(&self, other: &PunctuatedNonEmpty<T, S>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.list, &other.list) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.separator, &other.separator)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd, S: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd
    for PunctuatedNonEmpty<T, S> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &PunctuatedNonEmpty<T, S>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.list, &other.list) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.separator,
                        &other.separator,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash, S: ::core::hash::Hash> ::core::hash::Hash
    for PunctuatedNonEmpty<T, S> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.list, state);
            ::core::hash::Hash::hash(&self.separator, state)
        }
    }
    impl<'a, T, S> crate::Parse<'a> for PunctuatedNonEmpty<T, S>
    where
        T: Parse<'a>,
        S: Parse<'a> + ::std::default::Default,
    {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match nom::sequence::terminated(
                    nom::multi::separated_list1(
                        <S as crate::Parse<'a>>::parse,
                        <T as crate::Parse<'a>>::parse,
                    ),
                    nom::combinator::opt(<S as crate::Parse<'a>>::parse),
                )(input) {
                    Err(e) => Err(e),
                    Ok((i, list)) => {
                        use nom::lib::std::result::Result::*;
                        match marker(i) {
                            Err(e) => Err(e),
                            Ok((i, separator)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { list, separator }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Represents an identifier
    ///
    /// Follows `/[_-]?[A-Za-z][0-9A-Z_a-z-]*/`
    pub struct Identifier<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Identifier<'a> {
        #[inline]
        fn clone(&self) -> Identifier<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Identifier<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Identifier", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Identifier<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Identifier<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Identifier<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Identifier<'a> {
        #[inline]
        fn eq(&self, other: &Identifier<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Identifier<'a> {
        #[inline]
        fn cmp(&self, other: &Identifier<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Identifier<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Identifier<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Identifier<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Identifier<'a> {}
    impl<'a> crate::Parse<'a> for Identifier<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::*;
            match crate::whitespace::ws(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(
                            nom::branch::alt((
                                nom::character::complete::char('_'),
                                nom::character::complete::char('-'),
                            )),
                        ),
                        nom::bytes::complete::take_while1(nom::AsChar::is_alpha),
                        nom::bytes::complete::take_while(is_alphanum_underscore_dash),
                    )),
                ),
            )(input) {
                Err(e) => Err(e),
                Ok((i, inner)) => Ok((i, Identifier(inner))),
            }
        }
    }
    /// Parses rhs of an assignment expression. Ex: `= 45`
    pub struct Default<'a> {
        pub assign: crate::term::Assign,
        pub value: DefaultValue<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Default<'a> {
        #[inline]
        fn clone(&self) -> Default<'a> {
            let _: ::core::clone::AssertParamIsClone<crate::term::Assign>;
            let _: ::core::clone::AssertParamIsClone<DefaultValue<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Default<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Default",
                "assign",
                &&self.assign,
                "value",
                &&self.value,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Default<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Default<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<DefaultValue<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Default<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Default<'a> {
        #[inline]
        fn eq(&self, other: &Default<'a>) -> bool {
            self.assign == other.assign && self.value == other.value
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Default<'a> {
        #[inline]
        fn cmp(&self, other: &Default<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.value, &other.value)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Default<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Default<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.assign, &other.assign) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.value, &other.value)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Default<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.value, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Default<'a> {}
    impl<'a> crate::Parse<'a> for Default<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::Assign as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, assign)) => {
                        use nom::lib::std::result::Result::*;
                        match <DefaultValue<'a> as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, value)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { assign, value }))
                            }
                        }
                    }
                }
            }
        }
    }
}
pub mod dictionary {
    use derive::Weedle;
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Default, Identifier};
    use crate::types::Type;
    /// Parses dictionary members
    pub type DictionaryMembers<'a> = Vec<DictionaryMember<'a>>;
    /// Parses dictionary member `[attributes]? required? type identifier ( = default )?;`
    struct DictionaryMember<'a> {
        attributes: Option<ExtendedAttributeList<'a>>,
        required: Option<crate::term::Required>,
        type_: Type<'a>,
        identifier: Identifier<'a>,
        default: Option<Default<'a>>,
        semi_colon: crate::term::SemiColon,
    }
    impl<'a> crate::Parse<'a> for DictionaryMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::Ok;
            let (
                input,
                (attributes, required, type_, identifier, default, semi_colon),
            ) = nom::sequence::tuple((
                <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse,
                <Option<crate::term::Required> as crate::Parse<'a>>::parse,
                <Type<'a> as crate::Parse<'a>>::parse,
                <Identifier<'a> as crate::Parse<'a>>::parse,
                <Option<Default<'a>> as crate::Parse<'a>>::parse,
                <crate::term::SemiColon as crate::Parse<'a>>::parse,
            ));
            Ok((
                input,
                Self {
                    attributes,
                    required,
                    type_,
                    identifier,
                    default,
                    semi_colon,
                },
            ))
        }
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DictionaryMember<'a> {
        #[inline]
        fn clone(&self) -> DictionaryMember<'a> {
            DictionaryMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                required: ::core::clone::Clone::clone(&self.required),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                default: ::core::clone::Clone::clone(&self.default),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DictionaryMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "required",
                "type_",
                "identifier",
                "default",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.required,
                &&self.type_,
                &&self.identifier,
                &&self.default,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "DictionaryMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DictionaryMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DictionaryMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Required>>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Default<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DictionaryMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DictionaryMember<'a> {
        #[inline]
        fn eq(&self, other: &DictionaryMember<'a>) -> bool {
            self.attributes == other.attributes && self.required == other.required
                && self.type_ == other.type_ && self.identifier == other.identifier
                && self.default == other.default && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DictionaryMember<'a> {
        #[inline]
        fn cmp(&self, other: &DictionaryMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.required, &other.required) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.default, &other.default) {
                                                ::core::cmp::Ordering::Equal => {
                                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DictionaryMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DictionaryMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.required,
                        &other.required,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.type_,
                                &other.type_,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.default,
                                                &other.default,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.semi_colon,
                                                        &other.semi_colon,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DictionaryMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.required, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.default, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
}
pub mod interface {
    use crate::argument::ArgumentList;
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Generics, Identifier, Parenthesized};
    use crate::literal::ConstValue;
    use crate::types::{AttributedType, ConstType, ReturnType};
    /// Parses interface members
    pub type InterfaceMembers<'a> = Vec<InterfaceMember<'a>>;
    /// Parses inheritance clause `: identifier`
    pub struct Inheritance<'a> {
        pub colon: crate::term::Colon,
        pub identifier: Identifier<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Inheritance<'a> {
        #[inline]
        fn clone(&self) -> Inheritance<'a> {
            let _: ::core::clone::AssertParamIsClone<crate::term::Colon>;
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Inheritance<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Inheritance",
                "colon",
                &&self.colon,
                "identifier",
                &&self.identifier,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Inheritance<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Inheritance<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Colon>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Inheritance<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Inheritance<'a> {
        #[inline]
        fn eq(&self, other: &Inheritance<'a>) -> bool {
            self.colon == other.colon && self.identifier == other.identifier
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Inheritance<'a> {
        #[inline]
        fn cmp(&self, other: &Inheritance<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.colon, &other.colon) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.identifier, &other.identifier)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Inheritance<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Inheritance<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.colon, &other.colon) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.identifier,
                        &other.identifier,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Inheritance<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.colon, state);
            ::core::hash::Hash::hash(&self.identifier, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Inheritance<'a> {}
    impl<'a> crate::Parse<'a> for Inheritance<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::Colon as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, colon)) => {
                        use nom::lib::std::result::Result::*;
                        match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, identifier)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { colon, identifier }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses one of the interface member variants
    pub enum InterfaceMember<'a> {
        Const(ConstMember<'a>),
        Attribute(AttributeInterfaceMember<'a>),
        Constructor(ConstructorInterfaceMember<'a>),
        Operation(OperationInterfaceMember<'a>),
        Iterable(IterableInterfaceMember<'a>),
        AsyncIterable(AsyncIterableInterfaceMember<'a>),
        Maplike(MaplikeInterfaceMember<'a>),
        Setlike(SetlikeInterfaceMember<'a>),
        Stringifier(StringifierMember<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for InterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> InterfaceMember<'a> {
            match self {
                InterfaceMember::Const(__self_0) => {
                    InterfaceMember::Const(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Attribute(__self_0) => {
                    InterfaceMember::Attribute(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Constructor(__self_0) => {
                    InterfaceMember::Constructor(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Operation(__self_0) => {
                    InterfaceMember::Operation(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Iterable(__self_0) => {
                    InterfaceMember::Iterable(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::AsyncIterable(__self_0) => {
                    InterfaceMember::AsyncIterable(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Maplike(__self_0) => {
                    InterfaceMember::Maplike(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Setlike(__self_0) => {
                    InterfaceMember::Setlike(::core::clone::Clone::clone(__self_0))
                }
                InterfaceMember::Stringifier(__self_0) => {
                    InterfaceMember::Stringifier(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for InterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                InterfaceMember::Const(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Const",
                        &__self_0,
                    )
                }
                InterfaceMember::Attribute(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Attribute",
                        &__self_0,
                    )
                }
                InterfaceMember::Constructor(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Constructor",
                        &__self_0,
                    )
                }
                InterfaceMember::Operation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Operation",
                        &__self_0,
                    )
                }
                InterfaceMember::Iterable(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Iterable",
                        &__self_0,
                    )
                }
                InterfaceMember::AsyncIterable(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AsyncIterable",
                        &__self_0,
                    )
                }
                InterfaceMember::Maplike(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Maplike",
                        &__self_0,
                    )
                }
                InterfaceMember::Setlike(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Setlike",
                        &__self_0,
                    )
                }
                InterfaceMember::Stringifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stringifier",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for InterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for InterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<AttributeInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ConstructorInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<OperationInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<IterableInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<AsyncIterableInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<MaplikeInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<SetlikeInterfaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<StringifierMember<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for InterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for InterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &InterfaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        InterfaceMember::Const(__self_0),
                        InterfaceMember::Const(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Attribute(__self_0),
                        InterfaceMember::Attribute(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Constructor(__self_0),
                        InterfaceMember::Constructor(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Operation(__self_0),
                        InterfaceMember::Operation(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Iterable(__self_0),
                        InterfaceMember::Iterable(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::AsyncIterable(__self_0),
                        InterfaceMember::AsyncIterable(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Maplike(__self_0),
                        InterfaceMember::Maplike(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Setlike(__self_0),
                        InterfaceMember::Setlike(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        InterfaceMember::Stringifier(__self_0),
                        InterfaceMember::Stringifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for InterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &InterfaceMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            InterfaceMember::Const(__self_0),
                            InterfaceMember::Const(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Attribute(__self_0),
                            InterfaceMember::Attribute(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Constructor(__self_0),
                            InterfaceMember::Constructor(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Operation(__self_0),
                            InterfaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Iterable(__self_0),
                            InterfaceMember::Iterable(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::AsyncIterable(__self_0),
                            InterfaceMember::AsyncIterable(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Maplike(__self_0),
                            InterfaceMember::Maplike(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Setlike(__self_0),
                            InterfaceMember::Setlike(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Stringifier(__self_0),
                            InterfaceMember::Stringifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for InterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &InterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            InterfaceMember::Const(__self_0),
                            InterfaceMember::Const(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Attribute(__self_0),
                            InterfaceMember::Attribute(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Constructor(__self_0),
                            InterfaceMember::Constructor(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Operation(__self_0),
                            InterfaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Iterable(__self_0),
                            InterfaceMember::Iterable(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::AsyncIterable(__self_0),
                            InterfaceMember::AsyncIterable(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Maplike(__self_0),
                            InterfaceMember::Maplike(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Setlike(__self_0),
                            InterfaceMember::Setlike(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            InterfaceMember::Stringifier(__self_0),
                            InterfaceMember::Stringifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for InterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                InterfaceMember::Const(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Attribute(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Constructor(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Operation(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Iterable(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::AsyncIterable(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Maplike(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Setlike(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                InterfaceMember::Stringifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses a const interface member `[attributes]? const type identifier = value;`
    pub struct ConstMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub const_: crate::term::Const,
        pub const_type: ConstType<'a>,
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub const_value: ConstValue<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstMember<'a> {
        #[inline]
        fn clone(&self) -> ConstMember<'a> {
            ConstMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                const_: ::core::clone::Clone::clone(&self.const_),
                const_type: ::core::clone::Clone::clone(&self.const_type),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                const_value: ::core::clone::Clone::clone(&self.const_value),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "const_",
                "const_type",
                "identifier",
                "assign",
                "const_value",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.const_,
                &&self.const_type,
                &&self.identifier,
                &&self.assign,
                &&self.const_value,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ConstMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Const>;
            let _: ::core::cmp::AssertParamIsEq<ConstType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<ConstValue<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstMember<'a> {
        #[inline]
        fn eq(&self, other: &ConstMember<'a>) -> bool {
            self.attributes == other.attributes && self.const_ == other.const_
                && self.const_type == other.const_type
                && self.identifier == other.identifier && self.assign == other.assign
                && self.const_value == other.const_value
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstMember<'a> {
        #[inline]
        fn cmp(&self, other: &ConstMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.const_, &other.const_) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.const_type,
                                &other.const_type,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.const_value,
                                                        &other.const_value,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.const_,
                        &other.const_,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.const_type,
                                &other.const_type,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.assign,
                                                &other.assign,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.const_value,
                                                        &other.const_value,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.const_, state);
            ::core::hash::Hash::hash(&self.const_type, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.const_value, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for ConstMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Const as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, const_)) => {
                                use nom::lib::std::result::Result::*;
                                match <ConstType<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, const_type)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, identifier)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, assign)) => {
                                                        use nom::lib::std::result::Result::*;
                                                        match <ConstValue<'a> as crate::Parse<'a>>::parse(i) {
                                                            Err(e) => Err(e),
                                                            Ok((i, const_value)) => {
                                                                use nom::lib::std::result::Result::*;
                                                                match <crate::term::SemiColon as crate::Parse<
                                                                    'a,
                                                                >>::parse(i) {
                                                                    Err(e) => Err(e),
                                                                    Ok((i, semi_colon)) => {
                                                                        use nom::lib::std::result::Result::Ok;
                                                                        Ok((
                                                                            i,
                                                                            Self {
                                                                                attributes,
                                                                                const_,
                                                                                const_type,
                                                                                identifier,
                                                                                assign,
                                                                                const_value,
                                                                                semi_colon,
                                                                            },
                                                                        ))
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[attributes]? (stringifier|inherit|static)? readonly? attribute attributedtype identifier;`
    pub struct AttributeInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub modifier: Option<StringifierOrInheritOrStatic>,
        pub readonly: Option<crate::term::ReadOnly>,
        pub attribute: crate::term::Attribute,
        pub type_: AttributedType<'a>,
        pub identifier: Identifier<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributeInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> AttributeInterfaceMember<'a> {
            AttributeInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                modifier: ::core::clone::Clone::clone(&self.modifier),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                attribute: ::core::clone::Clone::clone(&self.attribute),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributeInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "modifier",
                "readonly",
                "attribute",
                "type_",
                "identifier",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.modifier,
                &&self.readonly,
                &&self.attribute,
                &&self.type_,
                &&self.identifier,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AttributeInterfaceMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributeInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<StringifierOrInheritOrStatic>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::ReadOnly>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Attribute>;
            let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributeInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &AttributeInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.modifier == other.modifier
                && self.readonly == other.readonly && self.attribute == other.attribute
                && self.type_ == other.type_ && self.identifier == other.identifier
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributeInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &AttributeInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.modifier, &other.modifier) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.readonly,
                                &other.readonly,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.attribute,
                                        &other.attribute,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.identifier,
                                                        &other.identifier,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributeInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributeInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.modifier,
                        &other.modifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.readonly,
                                &other.readonly,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.attribute,
                                        &other.attribute,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.type_,
                                                &other.type_,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.identifier,
                                                        &other.identifier,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributeInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.modifier, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.attribute, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for AttributeInterfaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Option<
                            StringifierOrInheritOrStatic,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, modifier)) => {
                                use nom::lib::std::result::Result::*;
                                match <Option<
                                    crate::term::ReadOnly,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, readonly)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <crate::term::Attribute as crate::Parse<
                                            'a,
                                        >>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, attribute)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <AttributedType<'a> as crate::Parse<'a>>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, type_)) => {
                                                        use nom::lib::std::result::Result::*;
                                                        match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                                            Err(e) => Err(e),
                                                            Ok((i, identifier)) => {
                                                                use nom::lib::std::result::Result::*;
                                                                match <crate::term::SemiColon as crate::Parse<
                                                                    'a,
                                                                >>::parse(i) {
                                                                    Err(e) => Err(e),
                                                                    Ok((i, semi_colon)) => {
                                                                        use nom::lib::std::result::Result::Ok;
                                                                        Ok((
                                                                            i,
                                                                            Self {
                                                                                attributes,
                                                                                modifier,
                                                                                readonly,
                                                                                attribute,
                                                                                type_,
                                                                                identifier,
                                                                                semi_colon,
                                                                            },
                                                                        ))
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[attributes]? constructor(( args ));`
    ///
    /// (( )) means ( ) chars
    pub struct ConstructorInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub constructor: crate::term::Constructor,
        pub args: Parenthesized<ArgumentList<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstructorInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> ConstructorInterfaceMember<'a> {
            ConstructorInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                constructor: ::core::clone::Clone::clone(&self.constructor),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstructorInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ConstructorInterfaceMember",
                "attributes",
                &&self.attributes,
                "constructor",
                &&self.constructor,
                "args",
                &&self.args,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstructorInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstructorInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Constructor>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstructorInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstructorInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &ConstructorInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.constructor == other.constructor
                && self.args == other.args && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstructorInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &ConstructorInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.constructor, &other.constructor) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstructorInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstructorInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.constructor,
                        &other.constructor,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.args,
                                &other.args,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.semi_colon,
                                        &other.semi_colon,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstructorInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.constructor, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for ConstructorInterfaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Constructor as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, constructor)) => {
                                use nom::lib::std::result::Result::*;
                                match <Parenthesized<
                                    ArgumentList<'a>,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, args)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <crate::term::SemiColon as crate::Parse<
                                            'a,
                                        >>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, semi_colon)) => {
                                                use nom::lib::std::result::Result::Ok;
                                                Ok((
                                                    i,
                                                    Self {
                                                        attributes,
                                                        constructor,
                                                        args,
                                                        semi_colon,
                                                    },
                                                ))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[attributes]? (stringifier|static)? special? returntype identifier? (( args ));`
    ///
    /// (( )) means ( ) chars
    pub struct OperationInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub modifier: Option<StringifierOrStatic>,
        pub special: Option<Special>,
        pub return_type: ReturnType<'a>,
        pub identifier: Option<Identifier<'a>>,
        pub args: Parenthesized<ArgumentList<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for OperationInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> OperationInterfaceMember<'a> {
            OperationInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                modifier: ::core::clone::Clone::clone(&self.modifier),
                special: ::core::clone::Clone::clone(&self.special),
                return_type: ::core::clone::Clone::clone(&self.return_type),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for OperationInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "modifier",
                "special",
                "return_type",
                "identifier",
                "args",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.modifier,
                &&self.special,
                &&self.return_type,
                &&self.identifier,
                &&self.args,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "OperationInterfaceMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for OperationInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for OperationInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<StringifierOrStatic>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Special>>;
            let _: ::core::cmp::AssertParamIsEq<ReturnType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Identifier<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for OperationInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for OperationInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &OperationInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.modifier == other.modifier
                && self.special == other.special && self.return_type == other.return_type
                && self.identifier == other.identifier && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for OperationInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &OperationInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.modifier, &other.modifier) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.special, &other.special) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.return_type,
                                        &other.return_type,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.identifier,
                                                &other.identifier,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for OperationInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OperationInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.modifier,
                        &other.modifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.special,
                                &other.special,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.return_type,
                                        &other.return_type,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.identifier,
                                                &other.identifier,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.args,
                                                        &other.args,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for OperationInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.modifier, state);
            ::core::hash::Hash::hash(&self.special, state);
            ::core::hash::Hash::hash(&self.return_type, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for OperationInterfaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Option<
                            StringifierOrStatic,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, modifier)) => {
                                use nom::lib::std::result::Result::*;
                                match <Option<Special> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, special)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <ReturnType<'a> as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, return_type)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <Option<
                                                    Identifier<'a>,
                                                > as crate::Parse<'a>>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, identifier)) => {
                                                        use nom::lib::std::result::Result::*;
                                                        match <Parenthesized<
                                                            ArgumentList<'a>,
                                                        > as crate::Parse<'a>>::parse(i) {
                                                            Err(e) => Err(e),
                                                            Ok((i, args)) => {
                                                                use nom::lib::std::result::Result::*;
                                                                match <crate::term::SemiColon as crate::Parse<
                                                                    'a,
                                                                >>::parse(i) {
                                                                    Err(e) => Err(e),
                                                                    Ok((i, semi_colon)) => {
                                                                        use nom::lib::std::result::Result::Ok;
                                                                        Ok((
                                                                            i,
                                                                            Self {
                                                                                attributes,
                                                                                modifier,
                                                                                special,
                                                                                return_type,
                                                                                identifier,
                                                                                args,
                                                                                semi_colon,
                                                                            },
                                                                        ))
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses an iterable declaration `[attributes]? (iterable<attributedtype> | iterable<attributedtype, attributedtype>) ;`
    pub enum IterableInterfaceMember<'a> {
        Single(SingleTypedIterable<'a>),
        Double(DoubleTypedIterable<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for IterableInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> IterableInterfaceMember<'a> {
            match self {
                IterableInterfaceMember::Single(__self_0) => {
                    IterableInterfaceMember::Single(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                IterableInterfaceMember::Double(__self_0) => {
                    IterableInterfaceMember::Double(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for IterableInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                IterableInterfaceMember::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                IterableInterfaceMember::Double(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Double",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for IterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for IterableInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<SingleTypedIterable<'a>>;
            let _: ::core::cmp::AssertParamIsEq<DoubleTypedIterable<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for IterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for IterableInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &IterableInterfaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        IterableInterfaceMember::Single(__self_0),
                        IterableInterfaceMember::Single(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        IterableInterfaceMember::Double(__self_0),
                        IterableInterfaceMember::Double(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for IterableInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &IterableInterfaceMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            IterableInterfaceMember::Single(__self_0),
                            IterableInterfaceMember::Single(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            IterableInterfaceMember::Double(__self_0),
                            IterableInterfaceMember::Double(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for IterableInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &IterableInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            IterableInterfaceMember::Single(__self_0),
                            IterableInterfaceMember::Single(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            IterableInterfaceMember::Double(__self_0),
                            IterableInterfaceMember::Double(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for IterableInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                IterableInterfaceMember::Single(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                IterableInterfaceMember::Double(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses an iterable declaration `[attributes]? iterable<attributedtype>;`
    pub struct SingleTypedIterable<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub iterable: crate::term::Iterable,
        pub generics: Generics<AttributedType<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SingleTypedIterable<'a> {
        #[inline]
        fn clone(&self) -> SingleTypedIterable<'a> {
            SingleTypedIterable {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                iterable: ::core::clone::Clone::clone(&self.iterable),
                generics: ::core::clone::Clone::clone(&self.generics),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SingleTypedIterable<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "SingleTypedIterable",
                "attributes",
                &&self.attributes,
                "iterable",
                &&self.iterable,
                "generics",
                &&self.generics,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SingleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SingleTypedIterable<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Iterable>;
            let _: ::core::cmp::AssertParamIsEq<Generics<AttributedType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SingleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SingleTypedIterable<'a> {
        #[inline]
        fn eq(&self, other: &SingleTypedIterable<'a>) -> bool {
            self.attributes == other.attributes && self.iterable == other.iterable
                && self.generics == other.generics && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SingleTypedIterable<'a> {
        #[inline]
        fn cmp(&self, other: &SingleTypedIterable<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.iterable, &other.iterable) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SingleTypedIterable<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SingleTypedIterable<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.iterable,
                        &other.iterable,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.semi_colon,
                                        &other.semi_colon,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SingleTypedIterable<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.iterable, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for SingleTypedIterable<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Iterable as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, iterable)) => {
                                use nom::lib::std::result::Result::*;
                                match <Generics<
                                    AttributedType<'a>,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, generics)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <crate::term::SemiColon as crate::Parse<
                                            'a,
                                        >>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, semi_colon)) => {
                                                use nom::lib::std::result::Result::Ok;
                                                Ok((
                                                    i,
                                                    Self {
                                                        attributes,
                                                        iterable,
                                                        generics,
                                                        semi_colon,
                                                    },
                                                ))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses an iterable declaration `[attributes]? iterable<attributedtype, attributedtype>;`
    pub struct DoubleTypedIterable<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub iterable: crate::term::Iterable,
        pub generics: Generics<
            (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
        >,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DoubleTypedIterable<'a> {
        #[inline]
        fn clone(&self) -> DoubleTypedIterable<'a> {
            DoubleTypedIterable {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                iterable: ::core::clone::Clone::clone(&self.iterable),
                generics: ::core::clone::Clone::clone(&self.generics),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DoubleTypedIterable<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "DoubleTypedIterable",
                "attributes",
                &&self.attributes,
                "iterable",
                &&self.iterable,
                "generics",
                &&self.generics,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DoubleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DoubleTypedIterable<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Iterable>;
            let _: ::core::cmp::AssertParamIsEq<
                Generics<(AttributedType<'a>, crate::term::Comma, AttributedType<'a>)>,
            >;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DoubleTypedIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DoubleTypedIterable<'a> {
        #[inline]
        fn eq(&self, other: &DoubleTypedIterable<'a>) -> bool {
            self.attributes == other.attributes && self.iterable == other.iterable
                && self.generics == other.generics && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DoubleTypedIterable<'a> {
        #[inline]
        fn cmp(&self, other: &DoubleTypedIterable<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.iterable, &other.iterable) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DoubleTypedIterable<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DoubleTypedIterable<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.iterable,
                        &other.iterable,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.semi_colon,
                                        &other.semi_colon,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DoubleTypedIterable<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.iterable, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for DoubleTypedIterable<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Iterable as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, iterable)) => {
                                use nom::lib::std::result::Result::*;
                                match <Generics<
                                    (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, generics)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <crate::term::SemiColon as crate::Parse<
                                            'a,
                                        >>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, semi_colon)) => {
                                                use nom::lib::std::result::Result::Ok;
                                                Ok((
                                                    i,
                                                    Self {
                                                        attributes,
                                                        iterable,
                                                        generics,
                                                        semi_colon,
                                                    },
                                                ))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    impl<'a> From<SingleTypedIterable<'a>> for IterableInterfaceMember<'a> {
        fn from(x: SingleTypedIterable<'a>) -> Self {
            IterableInterfaceMember::Single(x)
        }
    }
    impl<'a> From<DoubleTypedIterable<'a>> for IterableInterfaceMember<'a> {
        fn from(x: DoubleTypedIterable<'a>) -> Self {
            IterableInterfaceMember::Double(x)
        }
    }
    impl<'a> crate::Parse<'a> for IterableInterfaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <SingleTypedIterable<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <DoubleTypedIterable<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
    /// Parses an async iterable declaration `[attributes]? async (iterable<attributedtype> | iterable<attributedtype, attributedtype>) (( args ))? ;`
    pub enum AsyncIterableInterfaceMember<'a> {
        Single(SingleTypedAsyncIterable<'a>),
        Double(DoubleTypedAsyncIterable<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AsyncIterableInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> AsyncIterableInterfaceMember<'a> {
            match self {
                AsyncIterableInterfaceMember::Single(__self_0) => {
                    AsyncIterableInterfaceMember::Single(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                AsyncIterableInterfaceMember::Double(__self_0) => {
                    AsyncIterableInterfaceMember::Double(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AsyncIterableInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                AsyncIterableInterfaceMember::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                AsyncIterableInterfaceMember::Double(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Double",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AsyncIterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AsyncIterableInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<SingleTypedAsyncIterable<'a>>;
            let _: ::core::cmp::AssertParamIsEq<DoubleTypedAsyncIterable<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AsyncIterableInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AsyncIterableInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &AsyncIterableInterfaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        AsyncIterableInterfaceMember::Single(__self_0),
                        AsyncIterableInterfaceMember::Single(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        AsyncIterableInterfaceMember::Double(__self_0),
                        AsyncIterableInterfaceMember::Double(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AsyncIterableInterfaceMember<'a> {
        #[inline]
        fn cmp(
            &self,
            other: &AsyncIterableInterfaceMember<'a>,
        ) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            AsyncIterableInterfaceMember::Single(__self_0),
                            AsyncIterableInterfaceMember::Single(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            AsyncIterableInterfaceMember::Double(__self_0),
                            AsyncIterableInterfaceMember::Double(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AsyncIterableInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AsyncIterableInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            AsyncIterableInterfaceMember::Single(__self_0),
                            AsyncIterableInterfaceMember::Single(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            AsyncIterableInterfaceMember::Double(__self_0),
                            AsyncIterableInterfaceMember::Double(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AsyncIterableInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                AsyncIterableInterfaceMember::Single(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                AsyncIterableInterfaceMember::Double(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses an async iterable declaration `[attributes]? async iterable<attributedtype> (( args ))? ;`
    pub struct SingleTypedAsyncIterable<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub async_iterable: (crate::term::Async, crate::term::Iterable),
        pub generics: Generics<AttributedType<'a>>,
        pub args: Option<Parenthesized<ArgumentList<'a>>>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SingleTypedAsyncIterable<'a> {
        #[inline]
        fn clone(&self) -> SingleTypedAsyncIterable<'a> {
            SingleTypedAsyncIterable {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                async_iterable: ::core::clone::Clone::clone(&self.async_iterable),
                generics: ::core::clone::Clone::clone(&self.generics),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SingleTypedAsyncIterable<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SingleTypedAsyncIterable",
                "attributes",
                &&self.attributes,
                "async_iterable",
                &&self.async_iterable,
                "generics",
                &&self.generics,
                "args",
                &&self.args,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SingleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SingleTypedAsyncIterable<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<
                (crate::term::Async, crate::term::Iterable),
            >;
            let _: ::core::cmp::AssertParamIsEq<Generics<AttributedType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Parenthesized<ArgumentList<'a>>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SingleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SingleTypedAsyncIterable<'a> {
        #[inline]
        fn eq(&self, other: &SingleTypedAsyncIterable<'a>) -> bool {
            self.attributes == other.attributes
                && self.async_iterable == other.async_iterable
                && self.generics == other.generics && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SingleTypedAsyncIterable<'a> {
        #[inline]
        fn cmp(&self, other: &SingleTypedAsyncIterable<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(
                        &self.async_iterable,
                        &other.async_iterable,
                    ) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SingleTypedAsyncIterable<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SingleTypedAsyncIterable<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.async_iterable,
                        &other.async_iterable,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.args,
                                        &other.args,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SingleTypedAsyncIterable<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.async_iterable, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for SingleTypedAsyncIterable<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <(
                            crate::term::Async,
                            crate::term::Iterable,
                        ) as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, async_iterable)) => {
                                use nom::lib::std::result::Result::*;
                                match <Generics<
                                    AttributedType<'a>,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, generics)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Option<
                                            Parenthesized<ArgumentList<'a>>,
                                        > as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, args)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <crate::term::SemiColon as crate::Parse<
                                                    'a,
                                                >>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, semi_colon)) => {
                                                        use nom::lib::std::result::Result::Ok;
                                                        Ok((
                                                            i,
                                                            Self {
                                                                attributes,
                                                                async_iterable,
                                                                generics,
                                                                args,
                                                                semi_colon,
                                                            },
                                                        ))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses an async iterable declaration `[attributes]? async iterable<attributedtype, attributedtype> (( args ))? ;`
    pub struct DoubleTypedAsyncIterable<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub async_iterable: (crate::term::Async, crate::term::Iterable),
        pub generics: Generics<
            (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
        >,
        pub args: Option<Parenthesized<ArgumentList<'a>>>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DoubleTypedAsyncIterable<'a> {
        #[inline]
        fn clone(&self) -> DoubleTypedAsyncIterable<'a> {
            DoubleTypedAsyncIterable {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                async_iterable: ::core::clone::Clone::clone(&self.async_iterable),
                generics: ::core::clone::Clone::clone(&self.generics),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DoubleTypedAsyncIterable<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "DoubleTypedAsyncIterable",
                "attributes",
                &&self.attributes,
                "async_iterable",
                &&self.async_iterable,
                "generics",
                &&self.generics,
                "args",
                &&self.args,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DoubleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DoubleTypedAsyncIterable<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<
                (crate::term::Async, crate::term::Iterable),
            >;
            let _: ::core::cmp::AssertParamIsEq<
                Generics<(AttributedType<'a>, crate::term::Comma, AttributedType<'a>)>,
            >;
            let _: ::core::cmp::AssertParamIsEq<Option<Parenthesized<ArgumentList<'a>>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DoubleTypedAsyncIterable<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DoubleTypedAsyncIterable<'a> {
        #[inline]
        fn eq(&self, other: &DoubleTypedAsyncIterable<'a>) -> bool {
            self.attributes == other.attributes
                && self.async_iterable == other.async_iterable
                && self.generics == other.generics && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DoubleTypedAsyncIterable<'a> {
        #[inline]
        fn cmp(&self, other: &DoubleTypedAsyncIterable<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(
                        &self.async_iterable,
                        &other.async_iterable,
                    ) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DoubleTypedAsyncIterable<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DoubleTypedAsyncIterable<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.async_iterable,
                        &other.async_iterable,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.generics,
                                &other.generics,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.args,
                                        &other.args,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DoubleTypedAsyncIterable<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.async_iterable, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for DoubleTypedAsyncIterable<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <(
                            crate::term::Async,
                            crate::term::Iterable,
                        ) as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, async_iterable)) => {
                                use nom::lib::std::result::Result::*;
                                match <Generics<
                                    (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, generics)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Option<
                                            Parenthesized<ArgumentList<'a>>,
                                        > as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, args)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <crate::term::SemiColon as crate::Parse<
                                                    'a,
                                                >>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, semi_colon)) => {
                                                        use nom::lib::std::result::Result::Ok;
                                                        Ok((
                                                            i,
                                                            Self {
                                                                attributes,
                                                                async_iterable,
                                                                generics,
                                                                args,
                                                                semi_colon,
                                                            },
                                                        ))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    impl<'a> From<SingleTypedAsyncIterable<'a>> for AsyncIterableInterfaceMember<'a> {
        fn from(x: SingleTypedAsyncIterable<'a>) -> Self {
            AsyncIterableInterfaceMember::Single(x)
        }
    }
    impl<'a> From<DoubleTypedAsyncIterable<'a>> for AsyncIterableInterfaceMember<'a> {
        fn from(x: DoubleTypedAsyncIterable<'a>) -> Self {
            AsyncIterableInterfaceMember::Double(x)
        }
    }
    impl<'a> crate::Parse<'a> for AsyncIterableInterfaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <SingleTypedAsyncIterable<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <DoubleTypedAsyncIterable<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
    /// Parses an maplike declaration `[attributes]? readonly? maplike<attributedtype, attributedtype>;`
    pub struct MaplikeInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub readonly: Option<crate::term::ReadOnly>,
        pub maplike: crate::term::Maplike,
        pub generics: Generics<
            (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
        >,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for MaplikeInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> MaplikeInterfaceMember<'a> {
            MaplikeInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                maplike: ::core::clone::Clone::clone(&self.maplike),
                generics: ::core::clone::Clone::clone(&self.generics),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for MaplikeInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "MaplikeInterfaceMember",
                "attributes",
                &&self.attributes,
                "readonly",
                &&self.readonly,
                "maplike",
                &&self.maplike,
                "generics",
                &&self.generics,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for MaplikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for MaplikeInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::ReadOnly>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Maplike>;
            let _: ::core::cmp::AssertParamIsEq<
                Generics<(AttributedType<'a>, crate::term::Comma, AttributedType<'a>)>,
            >;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for MaplikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for MaplikeInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &MaplikeInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.readonly == other.readonly
                && self.maplike == other.maplike && self.generics == other.generics
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for MaplikeInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &MaplikeInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.readonly, &other.readonly) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.maplike, &other.maplike) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.generics,
                                        &other.generics,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for MaplikeInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MaplikeInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.readonly,
                        &other.readonly,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.maplike,
                                &other.maplike,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.generics,
                                        &other.generics,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for MaplikeInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.maplike, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for MaplikeInterfaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Option<
                            crate::term::ReadOnly,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, readonly)) => {
                                use nom::lib::std::result::Result::*;
                                match <crate::term::Maplike as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, maplike)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Generics<
                                            (AttributedType<'a>, crate::term::Comma, AttributedType<'a>),
                                        > as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, generics)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <crate::term::SemiColon as crate::Parse<
                                                    'a,
                                                >>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, semi_colon)) => {
                                                        use nom::lib::std::result::Result::Ok;
                                                        Ok((
                                                            i,
                                                            Self {
                                                                attributes,
                                                                readonly,
                                                                maplike,
                                                                generics,
                                                                semi_colon,
                                                            },
                                                        ))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pub struct SetlikeInterfaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub readonly: Option<crate::term::ReadOnly>,
        pub setlike: crate::term::Setlike,
        pub generics: Generics<AttributedType<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SetlikeInterfaceMember<'a> {
        #[inline]
        fn clone(&self) -> SetlikeInterfaceMember<'a> {
            SetlikeInterfaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                setlike: ::core::clone::Clone::clone(&self.setlike),
                generics: ::core::clone::Clone::clone(&self.generics),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SetlikeInterfaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SetlikeInterfaceMember",
                "attributes",
                &&self.attributes,
                "readonly",
                &&self.readonly,
                "setlike",
                &&self.setlike,
                "generics",
                &&self.generics,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SetlikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SetlikeInterfaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::ReadOnly>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Setlike>;
            let _: ::core::cmp::AssertParamIsEq<Generics<AttributedType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SetlikeInterfaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SetlikeInterfaceMember<'a> {
        #[inline]
        fn eq(&self, other: &SetlikeInterfaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.readonly == other.readonly
                && self.setlike == other.setlike && self.generics == other.generics
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SetlikeInterfaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &SetlikeInterfaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.readonly, &other.readonly) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.setlike, &other.setlike) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.generics,
                                        &other.generics,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SetlikeInterfaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SetlikeInterfaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.readonly,
                        &other.readonly,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.setlike,
                                &other.setlike,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.generics,
                                        &other.generics,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SetlikeInterfaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.setlike, state);
            ::core::hash::Hash::hash(&self.generics, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for SetlikeInterfaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Option<
                            crate::term::ReadOnly,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, readonly)) => {
                                use nom::lib::std::result::Result::*;
                                match <crate::term::Setlike as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, setlike)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Generics<
                                            AttributedType<'a>,
                                        > as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, generics)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <crate::term::SemiColon as crate::Parse<
                                                    'a,
                                                >>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, semi_colon)) => {
                                                        use nom::lib::std::result::Result::Ok;
                                                        Ok((
                                                            i,
                                                            Self {
                                                                attributes,
                                                                readonly,
                                                                setlike,
                                                                generics,
                                                                semi_colon,
                                                            },
                                                        ))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `stringifier;`
    pub struct StringifierMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub stringifier: crate::term::Stringifier,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for StringifierMember<'a> {
        #[inline]
        fn clone(&self) -> StringifierMember<'a> {
            StringifierMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                stringifier: ::core::clone::Clone::clone(&self.stringifier),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for StringifierMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "StringifierMember",
                "attributes",
                &&self.attributes,
                "stringifier",
                &&self.stringifier,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for StringifierMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for StringifierMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Stringifier>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for StringifierMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for StringifierMember<'a> {
        #[inline]
        fn eq(&self, other: &StringifierMember<'a>) -> bool {
            self.attributes == other.attributes && self.stringifier == other.stringifier
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for StringifierMember<'a> {
        #[inline]
        fn cmp(&self, other: &StringifierMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.stringifier, &other.stringifier) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for StringifierMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StringifierMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.stringifier,
                        &other.stringifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.semi_colon,
                                &other.semi_colon,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for StringifierMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.stringifier, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::default::Default for StringifierMember<'a> {
        #[inline]
        fn default() -> StringifierMember<'a> {
            StringifierMember {
                attributes: ::core::default::Default::default(),
                stringifier: ::core::default::Default::default(),
                semi_colon: ::core::default::Default::default(),
            }
        }
    }
    impl<'a> crate::Parse<'a> for StringifierMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Stringifier as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, stringifier)) => {
                                use nom::lib::std::result::Result::*;
                                match <crate::term::SemiColon as crate::Parse<
                                    'a,
                                >>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, semi_colon)) => {
                                        use nom::lib::std::result::Result::Ok;
                                        Ok((
                                            i,
                                            Self {
                                                attributes,
                                                stringifier,
                                                semi_colon,
                                            },
                                        ))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    impl<'a> From<ConstMember<'a>> for InterfaceMember<'a> {
        fn from(x: ConstMember<'a>) -> Self {
            InterfaceMember::Const(x)
        }
    }
    impl<'a> From<AttributeInterfaceMember<'a>> for InterfaceMember<'a> {
        fn from(x: AttributeInterfaceMember<'a>) -> Self {
            InterfaceMember::Attribute(x)
        }
    }
    impl<'a> From<ConstructorInterfaceMember<'a>> for InterfaceMember<'a> {
        fn from(x: ConstructorInterfaceMember<'a>) -> Self {
            InterfaceMember::Constructor(x)
        }
    }
    impl<'a> From<OperationInterfaceMember<'a>> for InterfaceMember<'a> {
        fn from(x: OperationInterfaceMember<'a>) -> Self {
            InterfaceMember::Operation(x)
        }
    }
    impl<'a> From<IterableInterfaceMember<'a>> for InterfaceMember<'a> {
        fn from(x: IterableInterfaceMember<'a>) -> Self {
            InterfaceMember::Iterable(x)
        }
    }
    impl<'a> From<AsyncIterableInterfaceMember<'a>> for InterfaceMember<'a> {
        fn from(x: AsyncIterableInterfaceMember<'a>) -> Self {
            InterfaceMember::AsyncIterable(x)
        }
    }
    impl<'a> From<MaplikeInterfaceMember<'a>> for InterfaceMember<'a> {
        fn from(x: MaplikeInterfaceMember<'a>) -> Self {
            InterfaceMember::Maplike(x)
        }
    }
    impl<'a> From<SetlikeInterfaceMember<'a>> for InterfaceMember<'a> {
        fn from(x: SetlikeInterfaceMember<'a>) -> Self {
            InterfaceMember::Setlike(x)
        }
    }
    impl<'a> From<StringifierMember<'a>> for InterfaceMember<'a> {
        fn from(x: StringifierMember<'a>) -> Self {
            InterfaceMember::Stringifier(x)
        }
    }
    impl<'a> crate::Parse<'a> for InterfaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <ConstMember<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <AttributeInterfaceMember<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <ConstructorInterfaceMember<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <OperationInterfaceMember<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::branch::alt((
                        nom::combinator::map(
                            <IterableInterfaceMember<'a> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::combinator::map(
                            <AsyncIterableInterfaceMember<
                                'a,
                            > as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::branch::alt((
                            nom::combinator::map(
                                <MaplikeInterfaceMember<'a> as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                            nom::combinator::map(
                                <SetlikeInterfaceMember<'a> as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                            nom::combinator::map(
                                <StringifierMember<'a> as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                        )),
                    )),
                )),
            ))(input)
        }
    }
    /// Parses one of the special keyword `getter|setter|deleter`
    pub enum Special {
        Getter(crate::term::Getter),
        Setter(crate::term::Setter),
        Deleter(crate::term::Deleter),
        LegacyCaller(crate::term::LegacyCaller),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Special {
        #[inline]
        fn clone(&self) -> Special {
            let _: ::core::clone::AssertParamIsClone<crate::term::Getter>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Setter>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Deleter>;
            let _: ::core::clone::AssertParamIsClone<crate::term::LegacyCaller>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Special {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Special::Getter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Getter",
                        &__self_0,
                    )
                }
                Special::Setter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Setter",
                        &__self_0,
                    )
                }
                Special::Deleter(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Deleter",
                        &__self_0,
                    )
                }
                Special::LegacyCaller(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LegacyCaller",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Special {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Special {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Getter>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Setter>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Deleter>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::LegacyCaller>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Special {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Special {
        #[inline]
        fn eq(&self, other: &Special) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Special::Getter(__self_0), Special::Getter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Special::Setter(__self_0), Special::Setter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Special::Deleter(__self_0), Special::Deleter(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        Special::LegacyCaller(__self_0),
                        Special::LegacyCaller(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Special {
        #[inline]
        fn cmp(&self, other: &Special) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Special::Getter(__self_0), Special::Getter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Special::Setter(__self_0), Special::Setter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Special::Deleter(__self_0), Special::Deleter(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Special::LegacyCaller(__self_0),
                            Special::LegacyCaller(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Special {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Special,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Special::Getter(__self_0), Special::Getter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Special::Setter(__self_0), Special::Setter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Special::Deleter(__self_0), Special::Deleter(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Special::LegacyCaller(__self_0),
                            Special::LegacyCaller(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Special {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Special::Getter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Special::Setter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Special::Deleter(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Special::LegacyCaller(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Special {}
    impl From<crate::term::Getter> for Special {
        fn from(x: crate::term::Getter) -> Self {
            Special::Getter(x)
        }
    }
    impl From<crate::term::Setter> for Special {
        fn from(x: crate::term::Setter) -> Self {
            Special::Setter(x)
        }
    }
    impl From<crate::term::Deleter> for Special {
        fn from(x: crate::term::Deleter) -> Self {
            Special::Deleter(x)
        }
    }
    impl From<crate::term::LegacyCaller> for Special {
        fn from(x: crate::term::LegacyCaller) -> Self {
            Special::LegacyCaller(x)
        }
    }
    impl<'a> crate::Parse<'a> for Special {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <crate::term::Getter as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <crate::term::Setter as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <crate::term::Deleter as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <crate::term::LegacyCaller as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                )),
            ))(input)
        }
    }
    /// Parses `stringifier|inherit|static`
    pub enum StringifierOrInheritOrStatic {
        Stringifier(crate::term::Stringifier),
        Inherit(crate::term::Inherit),
        Static(crate::term::Static),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StringifierOrInheritOrStatic {
        #[inline]
        fn clone(&self) -> StringifierOrInheritOrStatic {
            let _: ::core::clone::AssertParamIsClone<crate::term::Stringifier>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Inherit>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Static>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StringifierOrInheritOrStatic {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                StringifierOrInheritOrStatic::Stringifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stringifier",
                        &__self_0,
                    )
                }
                StringifierOrInheritOrStatic::Inherit(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Inherit",
                        &__self_0,
                    )
                }
                StringifierOrInheritOrStatic::Static(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Static",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for StringifierOrInheritOrStatic {}
    #[automatically_derived]
    impl ::core::cmp::Eq for StringifierOrInheritOrStatic {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Stringifier>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Inherit>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Static>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StringifierOrInheritOrStatic {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StringifierOrInheritOrStatic {
        #[inline]
        fn eq(&self, other: &StringifierOrInheritOrStatic) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        StringifierOrInheritOrStatic::Stringifier(__self_0),
                        StringifierOrInheritOrStatic::Stringifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        StringifierOrInheritOrStatic::Inherit(__self_0),
                        StringifierOrInheritOrStatic::Inherit(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        StringifierOrInheritOrStatic::Static(__self_0),
                        StringifierOrInheritOrStatic::Static(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for StringifierOrInheritOrStatic {
        #[inline]
        fn cmp(&self, other: &StringifierOrInheritOrStatic) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            StringifierOrInheritOrStatic::Stringifier(__self_0),
                            StringifierOrInheritOrStatic::Stringifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            StringifierOrInheritOrStatic::Inherit(__self_0),
                            StringifierOrInheritOrStatic::Inherit(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            StringifierOrInheritOrStatic::Static(__self_0),
                            StringifierOrInheritOrStatic::Static(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for StringifierOrInheritOrStatic {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StringifierOrInheritOrStatic,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            StringifierOrInheritOrStatic::Stringifier(__self_0),
                            StringifierOrInheritOrStatic::Stringifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            StringifierOrInheritOrStatic::Inherit(__self_0),
                            StringifierOrInheritOrStatic::Inherit(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            StringifierOrInheritOrStatic::Static(__self_0),
                            StringifierOrInheritOrStatic::Static(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for StringifierOrInheritOrStatic {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                StringifierOrInheritOrStatic::Stringifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                StringifierOrInheritOrStatic::Inherit(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                StringifierOrInheritOrStatic::Static(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for StringifierOrInheritOrStatic {}
    impl From<crate::term::Stringifier> for StringifierOrInheritOrStatic {
        fn from(x: crate::term::Stringifier) -> Self {
            StringifierOrInheritOrStatic::Stringifier(x)
        }
    }
    impl From<crate::term::Inherit> for StringifierOrInheritOrStatic {
        fn from(x: crate::term::Inherit) -> Self {
            StringifierOrInheritOrStatic::Inherit(x)
        }
    }
    impl From<crate::term::Static> for StringifierOrInheritOrStatic {
        fn from(x: crate::term::Static) -> Self {
            StringifierOrInheritOrStatic::Static(x)
        }
    }
    impl<'a> crate::Parse<'a> for StringifierOrInheritOrStatic {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <crate::term::Stringifier as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <crate::term::Inherit as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <crate::term::Static as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
    /// Parses `stringifier|static`
    pub enum StringifierOrStatic {
        Stringifier(crate::term::Stringifier),
        Static(crate::term::Static),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StringifierOrStatic {
        #[inline]
        fn clone(&self) -> StringifierOrStatic {
            let _: ::core::clone::AssertParamIsClone<crate::term::Stringifier>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Static>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StringifierOrStatic {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                StringifierOrStatic::Stringifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stringifier",
                        &__self_0,
                    )
                }
                StringifierOrStatic::Static(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Static",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for StringifierOrStatic {}
    #[automatically_derived]
    impl ::core::cmp::Eq for StringifierOrStatic {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Stringifier>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Static>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StringifierOrStatic {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StringifierOrStatic {
        #[inline]
        fn eq(&self, other: &StringifierOrStatic) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        StringifierOrStatic::Stringifier(__self_0),
                        StringifierOrStatic::Stringifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        StringifierOrStatic::Static(__self_0),
                        StringifierOrStatic::Static(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for StringifierOrStatic {
        #[inline]
        fn cmp(&self, other: &StringifierOrStatic) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            StringifierOrStatic::Stringifier(__self_0),
                            StringifierOrStatic::Stringifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            StringifierOrStatic::Static(__self_0),
                            StringifierOrStatic::Static(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for StringifierOrStatic {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StringifierOrStatic,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            StringifierOrStatic::Stringifier(__self_0),
                            StringifierOrStatic::Stringifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            StringifierOrStatic::Static(__self_0),
                            StringifierOrStatic::Static(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for StringifierOrStatic {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                StringifierOrStatic::Stringifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                StringifierOrStatic::Static(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for StringifierOrStatic {}
    impl From<crate::term::Stringifier> for StringifierOrStatic {
        fn from(x: crate::term::Stringifier) -> Self {
            StringifierOrStatic::Stringifier(x)
        }
    }
    impl From<crate::term::Static> for StringifierOrStatic {
        fn from(x: crate::term::Static) -> Self {
            StringifierOrStatic::Static(x)
        }
    }
    impl<'a> crate::Parse<'a> for StringifierOrStatic {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <crate::term::Stringifier as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <crate::term::Static as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
}
pub mod literal {
    /// Represents an integer value
    pub enum IntegerLit<'a> {
        Dec(DecLit<'a>),
        Hex(HexLit<'a>),
        Oct(OctLit<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for IntegerLit<'a> {
        #[inline]
        fn clone(&self) -> IntegerLit<'a> {
            let _: ::core::clone::AssertParamIsClone<DecLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<HexLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<OctLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for IntegerLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                IntegerLit::Dec(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dec",
                        &__self_0,
                    )
                }
                IntegerLit::Hex(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Hex",
                        &__self_0,
                    )
                }
                IntegerLit::Oct(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Oct",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for IntegerLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for IntegerLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<DecLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<HexLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<OctLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for IntegerLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for IntegerLit<'a> {
        #[inline]
        fn eq(&self, other: &IntegerLit<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (IntegerLit::Dec(__self_0), IntegerLit::Dec(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (IntegerLit::Hex(__self_0), IntegerLit::Hex(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (IntegerLit::Oct(__self_0), IntegerLit::Oct(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for IntegerLit<'a> {
        #[inline]
        fn cmp(&self, other: &IntegerLit<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (IntegerLit::Dec(__self_0), IntegerLit::Dec(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (IntegerLit::Hex(__self_0), IntegerLit::Hex(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (IntegerLit::Oct(__self_0), IntegerLit::Oct(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for IntegerLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &IntegerLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (IntegerLit::Dec(__self_0), IntegerLit::Dec(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (IntegerLit::Hex(__self_0), IntegerLit::Hex(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (IntegerLit::Oct(__self_0), IntegerLit::Oct(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for IntegerLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                IntegerLit::Dec(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                IntegerLit::Hex(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                IntegerLit::Oct(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for IntegerLit<'a> {}
    /// Parses `-?[1-9][0-9]*`
    pub struct DecLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DecLit<'a> {
        #[inline]
        fn clone(&self) -> DecLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DecLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "DecLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DecLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DecLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DecLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DecLit<'a> {
        #[inline]
        fn eq(&self, other: &DecLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DecLit<'a> {
        #[inline]
        fn cmp(&self, other: &DecLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DecLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DecLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DecLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for DecLit<'a> {}
    impl<'a> crate::Parse<'a> for DecLit<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::*;
            match crate::whitespace::ws(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(nom::character::complete::char('-')),
                        nom::character::complete::one_of("123456789"),
                        nom::bytes::complete::take_while(nom::AsChar::is_dec_digit),
                    )),
                ),
            )(input) {
                Err(e) => Err(e),
                Ok((i, inner)) => Ok((i, DecLit(inner))),
            }
        }
    }
    /// Parses `-?0[Xx][0-9A-Fa-f]+)`
    pub struct HexLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for HexLit<'a> {
        #[inline]
        fn clone(&self) -> HexLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for HexLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "HexLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for HexLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for HexLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for HexLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for HexLit<'a> {
        #[inline]
        fn eq(&self, other: &HexLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for HexLit<'a> {
        #[inline]
        fn cmp(&self, other: &HexLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for HexLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &HexLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for HexLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for HexLit<'a> {}
    impl<'a> crate::Parse<'a> for HexLit<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::*;
            match crate::whitespace::ws(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(nom::character::complete::char('-')),
                        nom::character::complete::char('0'),
                        nom::character::complete::one_of("xX"),
                        nom::bytes::complete::take_while(nom::AsChar::is_hex_digit),
                    )),
                ),
            )(input) {
                Err(e) => Err(e),
                Ok((i, inner)) => Ok((i, HexLit(inner))),
            }
        }
    }
    /// Parses `-?0[0-7]*`
    pub struct OctLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for OctLit<'a> {
        #[inline]
        fn clone(&self) -> OctLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for OctLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "OctLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for OctLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for OctLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for OctLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for OctLit<'a> {
        #[inline]
        fn eq(&self, other: &OctLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for OctLit<'a> {
        #[inline]
        fn cmp(&self, other: &OctLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for OctLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OctLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for OctLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for OctLit<'a> {}
    impl<'a> crate::Parse<'a> for OctLit<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::*;
            match crate::whitespace::ws(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(nom::character::complete::char('-')),
                        nom::character::complete::char('0'),
                        nom::bytes::complete::take_while(nom::AsChar::is_oct_digit),
                    )),
                ),
            )(input) {
                Err(e) => Err(e),
                Ok((i, inner)) => Ok((i, OctLit(inner))),
            }
        }
    }
    impl<'a> From<DecLit<'a>> for IntegerLit<'a> {
        fn from(x: DecLit<'a>) -> Self {
            IntegerLit::Dec(x)
        }
    }
    impl<'a> From<HexLit<'a>> for IntegerLit<'a> {
        fn from(x: HexLit<'a>) -> Self {
            IntegerLit::Hex(x)
        }
    }
    impl<'a> From<OctLit<'a>> for IntegerLit<'a> {
        fn from(x: OctLit<'a>) -> Self {
            IntegerLit::Oct(x)
        }
    }
    impl<'a> crate::Parse<'a> for IntegerLit<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <DecLit<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <HexLit<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(<OctLit<'a> as crate::Parse<'a>>::parse, From::from),
            ))(input)
        }
    }
    /// Represents a string value
    ///
    /// Follow `/"[^"]*"/`
    pub struct StringLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for StringLit<'a> {
        #[inline]
        fn clone(&self) -> StringLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for StringLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "StringLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for StringLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for StringLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for StringLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for StringLit<'a> {
        #[inline]
        fn eq(&self, other: &StringLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for StringLit<'a> {
        #[inline]
        fn cmp(&self, other: &StringLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for StringLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &StringLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for StringLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for StringLit<'a> {}
    impl<'a> crate::Parse<'a> for StringLit<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::*;
            match crate::whitespace::ws(
                nom::sequence::delimited(
                    nom::character::complete::char('"'),
                    nom::bytes::complete::take_while(|c| c != '"'),
                    nom::character::complete::char('"'),
                ),
            )(input) {
                Err(e) => Err(e),
                Ok((i, inner)) => Ok((i, StringLit(inner))),
            }
        }
    }
    /// Represents a default literal value. Ex: `34|34.23|"value"|[ ]|true|false|null`
    pub enum DefaultValue<'a> {
        Boolean(BooleanLit),
        EmptyArray(EmptyArrayLit),
        EmptyDictionary(EmptyDictionaryLit),
        Float(FloatLit<'a>),
        Integer(IntegerLit<'a>),
        Null(crate::term::Null),
        String(StringLit<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for DefaultValue<'a> {
        #[inline]
        fn clone(&self) -> DefaultValue<'a> {
            let _: ::core::clone::AssertParamIsClone<BooleanLit>;
            let _: ::core::clone::AssertParamIsClone<EmptyArrayLit>;
            let _: ::core::clone::AssertParamIsClone<EmptyDictionaryLit>;
            let _: ::core::clone::AssertParamIsClone<FloatLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<IntegerLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Null>;
            let _: ::core::clone::AssertParamIsClone<StringLit<'a>>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for DefaultValue<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DefaultValue::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                DefaultValue::EmptyArray(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EmptyArray",
                        &__self_0,
                    )
                }
                DefaultValue::EmptyDictionary(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EmptyDictionary",
                        &__self_0,
                    )
                }
                DefaultValue::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                DefaultValue::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                DefaultValue::Null(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Null",
                        &__self_0,
                    )
                }
                DefaultValue::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for DefaultValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for DefaultValue<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<BooleanLit>;
            let _: ::core::cmp::AssertParamIsEq<EmptyArrayLit>;
            let _: ::core::cmp::AssertParamIsEq<EmptyDictionaryLit>;
            let _: ::core::cmp::AssertParamIsEq<FloatLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<IntegerLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Null>;
            let _: ::core::cmp::AssertParamIsEq<StringLit<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for DefaultValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for DefaultValue<'a> {
        #[inline]
        fn eq(&self, other: &DefaultValue<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        DefaultValue::Boolean(__self_0),
                        DefaultValue::Boolean(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DefaultValue::EmptyArray(__self_0),
                        DefaultValue::EmptyArray(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        DefaultValue::EmptyDictionary(__self_0),
                        DefaultValue::EmptyDictionary(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (DefaultValue::Float(__self_0), DefaultValue::Float(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        DefaultValue::Integer(__self_0),
                        DefaultValue::Integer(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (DefaultValue::Null(__self_0), DefaultValue::Null(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (DefaultValue::String(__self_0), DefaultValue::String(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for DefaultValue<'a> {
        #[inline]
        fn cmp(&self, other: &DefaultValue<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            DefaultValue::Boolean(__self_0),
                            DefaultValue::Boolean(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::EmptyArray(__self_0),
                            DefaultValue::EmptyArray(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::EmptyDictionary(__self_0),
                            DefaultValue::EmptyDictionary(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::Float(__self_0),
                            DefaultValue::Float(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::Integer(__self_0),
                            DefaultValue::Integer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (DefaultValue::Null(__self_0), DefaultValue::Null(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            DefaultValue::String(__self_0),
                            DefaultValue::String(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for DefaultValue<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DefaultValue<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            DefaultValue::Boolean(__self_0),
                            DefaultValue::Boolean(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::EmptyArray(__self_0),
                            DefaultValue::EmptyArray(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::EmptyDictionary(__self_0),
                            DefaultValue::EmptyDictionary(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::Float(__self_0),
                            DefaultValue::Float(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            DefaultValue::Integer(__self_0),
                            DefaultValue::Integer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (DefaultValue::Null(__self_0), DefaultValue::Null(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            DefaultValue::String(__self_0),
                            DefaultValue::String(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for DefaultValue<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                DefaultValue::Boolean(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::EmptyArray(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::EmptyDictionary(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::Float(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::Integer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                DefaultValue::Null(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                DefaultValue::String(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for DefaultValue<'a> {}
    /// Represents `[ ]`
    pub struct EmptyArrayLit {
        pub open_bracket: crate::term::OpenBracket,
        pub close_bracket: crate::term::CloseBracket,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EmptyArrayLit {
        #[inline]
        fn clone(&self) -> EmptyArrayLit {
            let _: ::core::clone::AssertParamIsClone<crate::term::OpenBracket>;
            let _: ::core::clone::AssertParamIsClone<crate::term::CloseBracket>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EmptyArrayLit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "EmptyArrayLit",
                "open_bracket",
                &&self.open_bracket,
                "close_bracket",
                &&self.close_bracket,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EmptyArrayLit {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EmptyArrayLit {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::OpenBracket>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::CloseBracket>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EmptyArrayLit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EmptyArrayLit {
        #[inline]
        fn eq(&self, other: &EmptyArrayLit) -> bool {
            self.open_bracket == other.open_bracket
                && self.close_bracket == other.close_bracket
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for EmptyArrayLit {
        #[inline]
        fn cmp(&self, other: &EmptyArrayLit) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_bracket, &other.open_bracket) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.close_bracket, &other.close_bracket)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for EmptyArrayLit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &EmptyArrayLit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_bracket,
                &other.open_bracket,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.close_bracket,
                        &other.close_bracket,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for EmptyArrayLit {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_bracket, state);
            ::core::hash::Hash::hash(&self.close_bracket, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for EmptyArrayLit {}
    #[automatically_derived]
    impl ::core::default::Default for EmptyArrayLit {
        #[inline]
        fn default() -> EmptyArrayLit {
            EmptyArrayLit {
                open_bracket: ::core::default::Default::default(),
                close_bracket: ::core::default::Default::default(),
            }
        }
    }
    impl<'a> crate::Parse<'a> for EmptyArrayLit {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::OpenBracket as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, open_bracket)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::CloseBracket as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, close_bracket)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((
                                    i,
                                    Self {
                                        open_bracket,
                                        close_bracket,
                                    },
                                ))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Represents `{ }`
    pub struct EmptyDictionaryLit {
        pub open_brace: crate::term::OpenBrace,
        pub close_brace: crate::term::CloseBrace,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EmptyDictionaryLit {
        #[inline]
        fn clone(&self) -> EmptyDictionaryLit {
            let _: ::core::clone::AssertParamIsClone<crate::term::OpenBrace>;
            let _: ::core::clone::AssertParamIsClone<crate::term::CloseBrace>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EmptyDictionaryLit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "EmptyDictionaryLit",
                "open_brace",
                &&self.open_brace,
                "close_brace",
                &&self.close_brace,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for EmptyDictionaryLit {}
    #[automatically_derived]
    impl ::core::cmp::Eq for EmptyDictionaryLit {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::OpenBrace>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::CloseBrace>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EmptyDictionaryLit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EmptyDictionaryLit {
        #[inline]
        fn eq(&self, other: &EmptyDictionaryLit) -> bool {
            self.open_brace == other.open_brace && self.close_brace == other.close_brace
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for EmptyDictionaryLit {
        #[inline]
        fn cmp(&self, other: &EmptyDictionaryLit) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.open_brace, &other.open_brace) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.close_brace, &other.close_brace)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for EmptyDictionaryLit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &EmptyDictionaryLit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.open_brace,
                &other.open_brace,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.close_brace,
                        &other.close_brace,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for EmptyDictionaryLit {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.open_brace, state);
            ::core::hash::Hash::hash(&self.close_brace, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for EmptyDictionaryLit {}
    #[automatically_derived]
    impl ::core::default::Default for EmptyDictionaryLit {
        #[inline]
        fn default() -> EmptyDictionaryLit {
            EmptyDictionaryLit {
                open_brace: ::core::default::Default::default(),
                close_brace: ::core::default::Default::default(),
            }
        }
    }
    impl<'a> crate::Parse<'a> for EmptyDictionaryLit {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::OpenBrace as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, open_brace)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::CloseBrace as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, close_brace)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { open_brace, close_brace }))
                            }
                        }
                    }
                }
            }
        }
    }
    impl<'a> From<BooleanLit> for DefaultValue<'a> {
        fn from(x: BooleanLit) -> Self {
            DefaultValue::Boolean(x)
        }
    }
    impl<'a> From<EmptyArrayLit> for DefaultValue<'a> {
        fn from(x: EmptyArrayLit) -> Self {
            DefaultValue::EmptyArray(x)
        }
    }
    impl<'a> From<EmptyDictionaryLit> for DefaultValue<'a> {
        fn from(x: EmptyDictionaryLit) -> Self {
            DefaultValue::EmptyDictionary(x)
        }
    }
    impl<'a> From<FloatLit<'a>> for DefaultValue<'a> {
        fn from(x: FloatLit<'a>) -> Self {
            DefaultValue::Float(x)
        }
    }
    impl<'a> From<IntegerLit<'a>> for DefaultValue<'a> {
        fn from(x: IntegerLit<'a>) -> Self {
            DefaultValue::Integer(x)
        }
    }
    impl<'a> From<crate::term::Null> for DefaultValue<'a> {
        fn from(x: crate::term::Null) -> Self {
            DefaultValue::Null(x)
        }
    }
    impl<'a> From<StringLit<'a>> for DefaultValue<'a> {
        fn from(x: StringLit<'a>) -> Self {
            DefaultValue::String(x)
        }
    }
    impl<'a> crate::Parse<'a> for DefaultValue<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <BooleanLit as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <EmptyArrayLit as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <EmptyDictionaryLit as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <FloatLit<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::branch::alt((
                        nom::combinator::map(
                            <IntegerLit<'a> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::combinator::map(
                            <crate::term::Null as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::combinator::map(
                            <StringLit<'a> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                    )),
                )),
            ))(input)
        }
    }
    /// Represents `true`, `false`, `34.23`, `null`, `56`, ...
    pub enum ConstValue<'a> {
        Boolean(BooleanLit),
        Float(FloatLit<'a>),
        Integer(IntegerLit<'a>),
        Null(crate::term::Null),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstValue<'a> {
        #[inline]
        fn clone(&self) -> ConstValue<'a> {
            let _: ::core::clone::AssertParamIsClone<BooleanLit>;
            let _: ::core::clone::AssertParamIsClone<FloatLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<IntegerLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Null>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstValue<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ConstValue::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                ConstValue::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                ConstValue::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                ConstValue::Null(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Null",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstValue<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<BooleanLit>;
            let _: ::core::cmp::AssertParamIsEq<FloatLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<IntegerLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Null>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstValue<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstValue<'a> {
        #[inline]
        fn eq(&self, other: &ConstValue<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (ConstValue::Boolean(__self_0), ConstValue::Boolean(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstValue::Float(__self_0), ConstValue::Float(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstValue::Integer(__self_0), ConstValue::Integer(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstValue::Null(__self_0), ConstValue::Null(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstValue<'a> {
        #[inline]
        fn cmp(&self, other: &ConstValue<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            ConstValue::Boolean(__self_0),
                            ConstValue::Boolean(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (ConstValue::Float(__self_0), ConstValue::Float(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstValue::Integer(__self_0),
                            ConstValue::Integer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (ConstValue::Null(__self_0), ConstValue::Null(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstValue<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstValue<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            ConstValue::Boolean(__self_0),
                            ConstValue::Boolean(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (ConstValue::Float(__self_0), ConstValue::Float(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstValue::Integer(__self_0),
                            ConstValue::Integer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (ConstValue::Null(__self_0), ConstValue::Null(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstValue<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                ConstValue::Boolean(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ConstValue::Float(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstValue::Integer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ConstValue::Null(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for ConstValue<'a> {}
    impl<'a> From<BooleanLit> for ConstValue<'a> {
        fn from(x: BooleanLit) -> Self {
            ConstValue::Boolean(x)
        }
    }
    impl<'a> From<FloatLit<'a>> for ConstValue<'a> {
        fn from(x: FloatLit<'a>) -> Self {
            ConstValue::Float(x)
        }
    }
    impl<'a> From<IntegerLit<'a>> for ConstValue<'a> {
        fn from(x: IntegerLit<'a>) -> Self {
            ConstValue::Integer(x)
        }
    }
    impl<'a> From<crate::term::Null> for ConstValue<'a> {
        fn from(x: crate::term::Null) -> Self {
            ConstValue::Null(x)
        }
    }
    impl<'a> crate::Parse<'a> for ConstValue<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <BooleanLit as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <FloatLit<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <IntegerLit<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <crate::term::Null as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                )),
            ))(input)
        }
    }
    /// Represents either `true` or `false`
    pub struct BooleanLit(pub bool);
    #[automatically_derived]
    impl ::core::clone::Clone for BooleanLit {
        #[inline]
        fn clone(&self) -> BooleanLit {
            let _: ::core::clone::AssertParamIsClone<bool>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BooleanLit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "BooleanLit", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BooleanLit {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BooleanLit {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<bool>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BooleanLit {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BooleanLit {
        #[inline]
        fn eq(&self, other: &BooleanLit) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for BooleanLit {
        #[inline]
        fn cmp(&self, other: &BooleanLit) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for BooleanLit {
        #[inline]
        fn partial_cmp(
            &self,
            other: &BooleanLit,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for BooleanLit {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BooleanLit {}
    impl<'a> crate::Parse<'a> for BooleanLit {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::*;
            match nom::branch::alt((
                nom::combinator::value(
                    true,
                    <crate::term::True as crate::Parse<'a>>::parse,
                ),
                nom::combinator::value(
                    false,
                    <crate::term::False as crate::Parse<'a>>::parse,
                ),
            ))(input) {
                Err(e) => Err(e),
                Ok((i, inner)) => Ok((i, BooleanLit(inner))),
            }
        }
    }
    /// Represents a floating point value, `NaN`, `Infinity`, '+Infinity`
    pub enum FloatLit<'a> {
        Value(FloatValueLit<'a>),
        NegInfinity(crate::term::NegInfinity),
        Infinity(crate::term::Infinity),
        NaN(crate::term::NaN),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for FloatLit<'a> {
        #[inline]
        fn clone(&self) -> FloatLit<'a> {
            let _: ::core::clone::AssertParamIsClone<FloatValueLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::NegInfinity>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Infinity>;
            let _: ::core::clone::AssertParamIsClone<crate::term::NaN>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for FloatLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FloatLit::Value(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Value",
                        &__self_0,
                    )
                }
                FloatLit::NegInfinity(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NegInfinity",
                        &__self_0,
                    )
                }
                FloatLit::Infinity(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Infinity",
                        &__self_0,
                    )
                }
                FloatLit::NaN(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NaN",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for FloatLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for FloatLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<FloatValueLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::NegInfinity>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Infinity>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::NaN>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for FloatLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for FloatLit<'a> {
        #[inline]
        fn eq(&self, other: &FloatLit<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        FloatLit::NegInfinity(__self_0),
                        FloatLit::NegInfinity(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (FloatLit::Infinity(__self_0), FloatLit::Infinity(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for FloatLit<'a> {
        #[inline]
        fn cmp(&self, other: &FloatLit<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            FloatLit::NegInfinity(__self_0),
                            FloatLit::NegInfinity(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (FloatLit::Infinity(__self_0), FloatLit::Infinity(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for FloatLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FloatLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            FloatLit::NegInfinity(__self_0),
                            FloatLit::NegInfinity(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (FloatLit::Infinity(__self_0), FloatLit::Infinity(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for FloatLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                FloatLit::Value(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                FloatLit::NegInfinity(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                FloatLit::Infinity(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                FloatLit::NaN(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for FloatLit<'a> {}
    /// Parses `/-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/`
    pub struct FloatValueLit<'a>(pub &'a str);
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for FloatValueLit<'a> {
        #[inline]
        fn clone(&self) -> FloatValueLit<'a> {
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for FloatValueLit<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "FloatValueLit",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for FloatValueLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for FloatValueLit<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for FloatValueLit<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for FloatValueLit<'a> {
        #[inline]
        fn eq(&self, other: &FloatValueLit<'a>) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for FloatValueLit<'a> {
        #[inline]
        fn cmp(&self, other: &FloatValueLit<'a>) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for FloatValueLit<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FloatValueLit<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for FloatValueLit<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for FloatValueLit<'a> {}
    impl<'a> crate::Parse<'a> for FloatValueLit<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            use nom::lib::std::result::Result::*;
            match crate::whitespace::ws(
                nom::combinator::recognize(
                    nom::sequence::tuple((
                        nom::combinator::opt(nom::character::complete::char('-')),
                        nom::branch::alt((
                            nom::combinator::value(
                                (),
                                nom::sequence::tuple((
                                    nom::branch::alt((
                                        nom::sequence::tuple((
                                            nom::bytes::complete::take_while1(
                                                nom::AsChar::is_dec_digit,
                                            ),
                                            nom::character::complete::char('.'),
                                            nom::bytes::complete::take_while(nom::AsChar::is_dec_digit),
                                        )),
                                        nom::sequence::tuple((
                                            nom::bytes::complete::take_while(nom::AsChar::is_dec_digit),
                                            nom::character::complete::char('.'),
                                            nom::bytes::complete::take_while1(nom::AsChar::is_dec_digit),
                                        )),
                                    )),
                                    nom::combinator::opt(
                                        nom::sequence::tuple((
                                            nom::character::complete::one_of("eE"),
                                            nom::combinator::opt(
                                                nom::character::complete::one_of("+-"),
                                            ),
                                            nom::bytes::complete::take_while1(nom::AsChar::is_dec_digit),
                                        )),
                                    ),
                                )),
                            ),
                            nom::combinator::value(
                                (),
                                nom::sequence::tuple((
                                    nom::bytes::complete::take_while1(
                                        nom::AsChar::is_dec_digit,
                                    ),
                                    nom::character::complete::one_of("eE"),
                                    nom::combinator::opt(
                                        nom::character::complete::one_of("+-"),
                                    ),
                                    nom::bytes::complete::take_while1(nom::AsChar::is_dec_digit),
                                )),
                            ),
                        )),
                    )),
                ),
            )(input) {
                Err(e) => Err(e),
                Ok((i, inner)) => Ok((i, FloatValueLit(inner))),
            }
        }
    }
    impl<'a> From<FloatValueLit<'a>> for FloatLit<'a> {
        fn from(x: FloatValueLit<'a>) -> Self {
            FloatLit::Value(x)
        }
    }
    impl<'a> From<crate::term::NegInfinity> for FloatLit<'a> {
        fn from(x: crate::term::NegInfinity) -> Self {
            FloatLit::NegInfinity(x)
        }
    }
    impl<'a> From<crate::term::Infinity> for FloatLit<'a> {
        fn from(x: crate::term::Infinity) -> Self {
            FloatLit::Infinity(x)
        }
    }
    impl<'a> From<crate::term::NaN> for FloatLit<'a> {
        fn from(x: crate::term::NaN) -> Self {
            FloatLit::NaN(x)
        }
    }
    impl<'a> crate::Parse<'a> for FloatLit<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <FloatValueLit<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <crate::term::NegInfinity as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <crate::term::Infinity as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <crate::term::NaN as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                )),
            ))(input)
        }
    }
}
pub mod mixin {
    use crate::argument::ArgumentList;
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Identifier, Parenthesized};
    use crate::interface::{ConstMember, StringifierMember};
    use crate::types::{AttributedType, ReturnType};
    /// Parses the members declarations of a mixin
    pub type MixinMembers<'a> = Vec<MixinMember<'a>>;
    /// Parses one of the variants of a mixin member
    pub enum MixinMember<'a> {
        Const(ConstMember<'a>),
        Operation(OperationMixinMember<'a>),
        Attribute(AttributeMixinMember<'a>),
        Stringifier(StringifierMember<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for MixinMember<'a> {
        #[inline]
        fn clone(&self) -> MixinMember<'a> {
            match self {
                MixinMember::Const(__self_0) => {
                    MixinMember::Const(::core::clone::Clone::clone(__self_0))
                }
                MixinMember::Operation(__self_0) => {
                    MixinMember::Operation(::core::clone::Clone::clone(__self_0))
                }
                MixinMember::Attribute(__self_0) => {
                    MixinMember::Attribute(::core::clone::Clone::clone(__self_0))
                }
                MixinMember::Stringifier(__self_0) => {
                    MixinMember::Stringifier(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for MixinMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                MixinMember::Const(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Const",
                        &__self_0,
                    )
                }
                MixinMember::Operation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Operation",
                        &__self_0,
                    )
                }
                MixinMember::Attribute(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Attribute",
                        &__self_0,
                    )
                }
                MixinMember::Stringifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Stringifier",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for MixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for MixinMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<OperationMixinMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<AttributeMixinMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<StringifierMember<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for MixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for MixinMember<'a> {
        #[inline]
        fn eq(&self, other: &MixinMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (MixinMember::Const(__self_0), MixinMember::Const(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        MixinMember::Operation(__self_0),
                        MixinMember::Operation(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MixinMember::Attribute(__self_0),
                        MixinMember::Attribute(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MixinMember::Stringifier(__self_0),
                        MixinMember::Stringifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for MixinMember<'a> {
        #[inline]
        fn cmp(&self, other: &MixinMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (MixinMember::Const(__self_0), MixinMember::Const(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            MixinMember::Operation(__self_0),
                            MixinMember::Operation(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            MixinMember::Attribute(__self_0),
                            MixinMember::Attribute(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            MixinMember::Stringifier(__self_0),
                            MixinMember::Stringifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for MixinMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MixinMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (MixinMember::Const(__self_0), MixinMember::Const(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            MixinMember::Operation(__self_0),
                            MixinMember::Operation(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            MixinMember::Attribute(__self_0),
                            MixinMember::Attribute(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            MixinMember::Stringifier(__self_0),
                            MixinMember::Stringifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for MixinMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                MixinMember::Const(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                MixinMember::Operation(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                MixinMember::Attribute(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                MixinMember::Stringifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses `[attributes]? stringifier? returntype identifier? (( args ));`
    ///
    /// (( )) means ( ) chars
    pub struct OperationMixinMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub stringifier: Option<crate::term::Stringifier>,
        pub return_type: ReturnType<'a>,
        pub identifier: Option<Identifier<'a>>,
        pub args: Parenthesized<ArgumentList<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for OperationMixinMember<'a> {
        #[inline]
        fn clone(&self) -> OperationMixinMember<'a> {
            OperationMixinMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                stringifier: ::core::clone::Clone::clone(&self.stringifier),
                return_type: ::core::clone::Clone::clone(&self.return_type),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for OperationMixinMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "stringifier",
                "return_type",
                "identifier",
                "args",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.stringifier,
                &&self.return_type,
                &&self.identifier,
                &&self.args,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "OperationMixinMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for OperationMixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for OperationMixinMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Stringifier>>;
            let _: ::core::cmp::AssertParamIsEq<ReturnType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Identifier<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for OperationMixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for OperationMixinMember<'a> {
        #[inline]
        fn eq(&self, other: &OperationMixinMember<'a>) -> bool {
            self.attributes == other.attributes && self.stringifier == other.stringifier
                && self.return_type == other.return_type
                && self.identifier == other.identifier && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for OperationMixinMember<'a> {
        #[inline]
        fn cmp(&self, other: &OperationMixinMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.stringifier, &other.stringifier) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.return_type,
                                &other.return_type,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                                ::core::cmp::Ordering::Equal => {
                                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for OperationMixinMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OperationMixinMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.stringifier,
                        &other.stringifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.return_type,
                                &other.return_type,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.args,
                                                &other.args,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.semi_colon,
                                                        &other.semi_colon,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for OperationMixinMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.stringifier, state);
            ::core::hash::Hash::hash(&self.return_type, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for OperationMixinMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Option<
                            crate::term::Stringifier,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, stringifier)) => {
                                use nom::lib::std::result::Result::*;
                                match <ReturnType<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, return_type)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Option<
                                            Identifier<'a>,
                                        > as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, identifier)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <Parenthesized<
                                                    ArgumentList<'a>,
                                                > as crate::Parse<'a>>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, args)) => {
                                                        use nom::lib::std::result::Result::*;
                                                        match <crate::term::SemiColon as crate::Parse<
                                                            'a,
                                                        >>::parse(i) {
                                                            Err(e) => Err(e),
                                                            Ok((i, semi_colon)) => {
                                                                use nom::lib::std::result::Result::Ok;
                                                                Ok((
                                                                    i,
                                                                    Self {
                                                                        attributes,
                                                                        stringifier,
                                                                        return_type,
                                                                        identifier,
                                                                        args,
                                                                        semi_colon,
                                                                    },
                                                                ))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[attributes]? stringifier? readonly? attribute attributedtype identifier;`
    pub struct AttributeMixinMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub stringifier: Option<crate::term::Stringifier>,
        pub readonly: Option<crate::term::ReadOnly>,
        pub attribute: crate::term::Attribute,
        pub type_: AttributedType<'a>,
        pub identifier: Identifier<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributeMixinMember<'a> {
        #[inline]
        fn clone(&self) -> AttributeMixinMember<'a> {
            AttributeMixinMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                stringifier: ::core::clone::Clone::clone(&self.stringifier),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                attribute: ::core::clone::Clone::clone(&self.attribute),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributeMixinMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "stringifier",
                "readonly",
                "attribute",
                "type_",
                "identifier",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.stringifier,
                &&self.readonly,
                &&self.attribute,
                &&self.type_,
                &&self.identifier,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AttributeMixinMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributeMixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributeMixinMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Stringifier>>;
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::ReadOnly>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Attribute>;
            let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributeMixinMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributeMixinMember<'a> {
        #[inline]
        fn eq(&self, other: &AttributeMixinMember<'a>) -> bool {
            self.attributes == other.attributes && self.stringifier == other.stringifier
                && self.readonly == other.readonly && self.attribute == other.attribute
                && self.type_ == other.type_ && self.identifier == other.identifier
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributeMixinMember<'a> {
        #[inline]
        fn cmp(&self, other: &AttributeMixinMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.stringifier, &other.stringifier) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.readonly,
                                &other.readonly,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.attribute,
                                        &other.attribute,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.identifier,
                                                        &other.identifier,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributeMixinMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributeMixinMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.stringifier,
                        &other.stringifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.readonly,
                                &other.readonly,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.attribute,
                                        &other.attribute,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.type_,
                                                &other.type_,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.identifier,
                                                        &other.identifier,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributeMixinMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.stringifier, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.attribute, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for AttributeMixinMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Option<
                            crate::term::Stringifier,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, stringifier)) => {
                                use nom::lib::std::result::Result::*;
                                match <Option<
                                    crate::term::ReadOnly,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, readonly)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <crate::term::Attribute as crate::Parse<
                                            'a,
                                        >>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, attribute)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <AttributedType<'a> as crate::Parse<'a>>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, type_)) => {
                                                        use nom::lib::std::result::Result::*;
                                                        match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                                            Err(e) => Err(e),
                                                            Ok((i, identifier)) => {
                                                                use nom::lib::std::result::Result::*;
                                                                match <crate::term::SemiColon as crate::Parse<
                                                                    'a,
                                                                >>::parse(i) {
                                                                    Err(e) => Err(e),
                                                                    Ok((i, semi_colon)) => {
                                                                        use nom::lib::std::result::Result::Ok;
                                                                        Ok((
                                                                            i,
                                                                            Self {
                                                                                attributes,
                                                                                stringifier,
                                                                                readonly,
                                                                                attribute,
                                                                                type_,
                                                                                identifier,
                                                                                semi_colon,
                                                                            },
                                                                        ))
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    impl<'a> From<ConstMember<'a>> for MixinMember<'a> {
        fn from(x: ConstMember<'a>) -> Self {
            MixinMember::Const(x)
        }
    }
    impl<'a> From<OperationMixinMember<'a>> for MixinMember<'a> {
        fn from(x: OperationMixinMember<'a>) -> Self {
            MixinMember::Operation(x)
        }
    }
    impl<'a> From<AttributeMixinMember<'a>> for MixinMember<'a> {
        fn from(x: AttributeMixinMember<'a>) -> Self {
            MixinMember::Attribute(x)
        }
    }
    impl<'a> From<StringifierMember<'a>> for MixinMember<'a> {
        fn from(x: StringifierMember<'a>) -> Self {
            MixinMember::Stringifier(x)
        }
    }
    impl<'a> crate::Parse<'a> for MixinMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <ConstMember<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <OperationMixinMember<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <AttributeMixinMember<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <StringifierMember<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                )),
            ))(input)
        }
    }
}
pub mod namespace {
    use crate::argument::ArgumentList;
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Identifier, Parenthesized};
    use crate::literal::ConstValue;
    use crate::types::{AttributedType, ConstType, ReturnType};
    /// Parses namespace members declaration
    pub type NamespaceMembers<'a> = Vec<NamespaceMember<'a>>;
    /// Parses namespace member declaration
    pub enum NamespaceMember<'a> {
        Operation(OperationNamespaceMember<'a>),
        Attribute(AttributeNamespaceMember<'a>),
        Const(ConstMember<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for NamespaceMember<'a> {
        #[inline]
        fn clone(&self) -> NamespaceMember<'a> {
            match self {
                NamespaceMember::Operation(__self_0) => {
                    NamespaceMember::Operation(::core::clone::Clone::clone(__self_0))
                }
                NamespaceMember::Attribute(__self_0) => {
                    NamespaceMember::Attribute(::core::clone::Clone::clone(__self_0))
                }
                NamespaceMember::Const(__self_0) => {
                    NamespaceMember::Const(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for NamespaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                NamespaceMember::Operation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Operation",
                        &__self_0,
                    )
                }
                NamespaceMember::Attribute(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Attribute",
                        &__self_0,
                    )
                }
                NamespaceMember::Const(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Const",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for NamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for NamespaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<OperationNamespaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<AttributeNamespaceMember<'a>>;
            let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for NamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for NamespaceMember<'a> {
        #[inline]
        fn eq(&self, other: &NamespaceMember<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        NamespaceMember::Operation(__self_0),
                        NamespaceMember::Operation(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NamespaceMember::Attribute(__self_0),
                        NamespaceMember::Attribute(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NamespaceMember::Const(__self_0),
                        NamespaceMember::Const(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for NamespaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &NamespaceMember<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            NamespaceMember::Operation(__self_0),
                            NamespaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NamespaceMember::Attribute(__self_0),
                            NamespaceMember::Attribute(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NamespaceMember::Const(__self_0),
                            NamespaceMember::Const(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for NamespaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &NamespaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            NamespaceMember::Operation(__self_0),
                            NamespaceMember::Operation(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NamespaceMember::Attribute(__self_0),
                            NamespaceMember::Attribute(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NamespaceMember::Const(__self_0),
                            NamespaceMember::Const(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for NamespaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                NamespaceMember::Operation(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NamespaceMember::Attribute(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NamespaceMember::Const(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    /// Parses `[attributes]? returntype identifier? (( args ));`
    ///
    /// (( )) means ( ) chars
    pub struct OperationNamespaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub return_type: ReturnType<'a>,
        pub identifier: Option<Identifier<'a>>,
        pub args: Parenthesized<ArgumentList<'a>>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for OperationNamespaceMember<'a> {
        #[inline]
        fn clone(&self) -> OperationNamespaceMember<'a> {
            OperationNamespaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                return_type: ::core::clone::Clone::clone(&self.return_type),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                args: ::core::clone::Clone::clone(&self.args),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for OperationNamespaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "OperationNamespaceMember",
                "attributes",
                &&self.attributes,
                "return_type",
                &&self.return_type,
                "identifier",
                &&self.identifier,
                "args",
                &&self.args,
                "semi_colon",
                &&self.semi_colon,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for OperationNamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for OperationNamespaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<ReturnType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Option<Identifier<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for OperationNamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for OperationNamespaceMember<'a> {
        #[inline]
        fn eq(&self, other: &OperationNamespaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.return_type == other.return_type
                && self.identifier == other.identifier && self.args == other.args
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for OperationNamespaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &OperationNamespaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.return_type, &other.return_type) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.identifier,
                                &other.identifier,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.args, &other.args) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for OperationNamespaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OperationNamespaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.return_type,
                        &other.return_type,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.identifier,
                                &other.identifier,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.args,
                                        &other.args,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.semi_colon,
                                                &other.semi_colon,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for OperationNamespaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.return_type, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for OperationNamespaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <ReturnType<'a> as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, return_type)) => {
                                use nom::lib::std::result::Result::*;
                                match <Option<
                                    Identifier<'a>,
                                > as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, identifier)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Parenthesized<
                                            ArgumentList<'a>,
                                        > as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, args)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <crate::term::SemiColon as crate::Parse<
                                                    'a,
                                                >>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, semi_colon)) => {
                                                        use nom::lib::std::result::Result::Ok;
                                                        Ok((
                                                            i,
                                                            Self {
                                                                attributes,
                                                                return_type,
                                                                identifier,
                                                                args,
                                                                semi_colon,
                                                            },
                                                        ))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[attribute]? readonly attributetype type identifier;`
    pub struct AttributeNamespaceMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub readonly: crate::term::ReadOnly,
        pub attribute: crate::term::Attribute,
        pub type_: AttributedType<'a>,
        pub identifier: Identifier<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributeNamespaceMember<'a> {
        #[inline]
        fn clone(&self) -> AttributeNamespaceMember<'a> {
            AttributeNamespaceMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                readonly: ::core::clone::Clone::clone(&self.readonly),
                attribute: ::core::clone::Clone::clone(&self.attribute),
                type_: ::core::clone::Clone::clone(&self.type_),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributeNamespaceMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "readonly",
                "attribute",
                "type_",
                "identifier",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.readonly,
                &&self.attribute,
                &&self.type_,
                &&self.identifier,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AttributeNamespaceMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributeNamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributeNamespaceMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::ReadOnly>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Attribute>;
            let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributeNamespaceMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributeNamespaceMember<'a> {
        #[inline]
        fn eq(&self, other: &AttributeNamespaceMember<'a>) -> bool {
            self.attributes == other.attributes && self.readonly == other.readonly
                && self.attribute == other.attribute && self.type_ == other.type_
                && self.identifier == other.identifier
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributeNamespaceMember<'a> {
        #[inline]
        fn cmp(&self, other: &AttributeNamespaceMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.readonly, &other.readonly) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.attribute,
                                &other.attribute,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.identifier,
                                                &other.identifier,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributeNamespaceMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributeNamespaceMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.readonly,
                        &other.readonly,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.attribute,
                                &other.attribute,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.type_,
                                        &other.type_,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.identifier,
                                                &other.identifier,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.semi_colon,
                                                        &other.semi_colon,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributeNamespaceMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.readonly, state);
            ::core::hash::Hash::hash(&self.attribute, state);
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for AttributeNamespaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::ReadOnly as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, readonly)) => {
                                use nom::lib::std::result::Result::*;
                                match <crate::term::Attribute as crate::Parse<
                                    'a,
                                >>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, attribute)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <AttributedType<'a> as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, type_)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, identifier)) => {
                                                        use nom::lib::std::result::Result::*;
                                                        match <crate::term::SemiColon as crate::Parse<
                                                            'a,
                                                        >>::parse(i) {
                                                            Err(e) => Err(e),
                                                            Ok((i, semi_colon)) => {
                                                                use nom::lib::std::result::Result::Ok;
                                                                Ok((
                                                                    i,
                                                                    Self {
                                                                        attributes,
                                                                        readonly,
                                                                        attribute,
                                                                        type_,
                                                                        identifier,
                                                                        semi_colon,
                                                                    },
                                                                ))
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[attributes]? const type identifier = value;`
    pub struct ConstMember<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub const_: crate::term::Const,
        pub const_type: ConstType<'a>,
        pub identifier: Identifier<'a>,
        pub assign: crate::term::Assign,
        pub const_value: ConstValue<'a>,
        pub semi_colon: crate::term::SemiColon,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstMember<'a> {
        #[inline]
        fn clone(&self) -> ConstMember<'a> {
            ConstMember {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                const_: ::core::clone::Clone::clone(&self.const_),
                const_type: ::core::clone::Clone::clone(&self.const_type),
                identifier: ::core::clone::Clone::clone(&self.identifier),
                assign: ::core::clone::Clone::clone(&self.assign),
                const_value: ::core::clone::Clone::clone(&self.const_value),
                semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstMember<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "attributes",
                "const_",
                "const_type",
                "identifier",
                "assign",
                "const_value",
                "semi_colon",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &&self.attributes,
                &&self.const_,
                &&self.const_type,
                &&self.identifier,
                &&self.assign,
                &&self.const_value,
                &&self.semi_colon,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ConstMember",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstMember<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Const>;
            let _: ::core::cmp::AssertParamIsEq<ConstType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
            let _: ::core::cmp::AssertParamIsEq<ConstValue<'a>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstMember<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstMember<'a> {
        #[inline]
        fn eq(&self, other: &ConstMember<'a>) -> bool {
            self.attributes == other.attributes && self.const_ == other.const_
                && self.const_type == other.const_type
                && self.identifier == other.identifier && self.assign == other.assign
                && self.const_value == other.const_value
                && self.semi_colon == other.semi_colon
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstMember<'a> {
        #[inline]
        fn cmp(&self, other: &ConstMember<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.const_, &other.const_) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.const_type,
                                &other.const_type,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.const_value,
                                                        &other.const_value,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstMember<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstMember<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.const_,
                        &other.const_,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.const_type,
                                &other.const_type,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.assign,
                                                &other.assign,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.const_value,
                                                        &other.const_value,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstMember<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.const_, state);
            ::core::hash::Hash::hash(&self.const_type, state);
            ::core::hash::Hash::hash(&self.identifier, state);
            ::core::hash::Hash::hash(&self.assign, state);
            ::core::hash::Hash::hash(&self.const_value, state);
            ::core::hash::Hash::hash(&self.semi_colon, state)
        }
    }
    impl<'a> crate::Parse<'a> for ConstMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Const as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, const_)) => {
                                use nom::lib::std::result::Result::*;
                                match <ConstType<'a> as crate::Parse<'a>>::parse(i) {
                                    Err(e) => Err(e),
                                    Ok((i, const_type)) => {
                                        use nom::lib::std::result::Result::*;
                                        match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                            Err(e) => Err(e),
                                            Ok((i, identifier)) => {
                                                use nom::lib::std::result::Result::*;
                                                match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                                                    Err(e) => Err(e),
                                                    Ok((i, assign)) => {
                                                        use nom::lib::std::result::Result::*;
                                                        match <ConstValue<'a> as crate::Parse<'a>>::parse(i) {
                                                            Err(e) => Err(e),
                                                            Ok((i, const_value)) => {
                                                                use nom::lib::std::result::Result::*;
                                                                match <crate::term::SemiColon as crate::Parse<
                                                                    'a,
                                                                >>::parse(i) {
                                                                    Err(e) => Err(e),
                                                                    Ok((i, semi_colon)) => {
                                                                        use nom::lib::std::result::Result::Ok;
                                                                        Ok((
                                                                            i,
                                                                            Self {
                                                                                attributes,
                                                                                const_,
                                                                                const_type,
                                                                                identifier,
                                                                                assign,
                                                                                const_value,
                                                                                semi_colon,
                                                                            },
                                                                        ))
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    impl<'a> From<OperationNamespaceMember<'a>> for NamespaceMember<'a> {
        fn from(x: OperationNamespaceMember<'a>) -> Self {
            NamespaceMember::Operation(x)
        }
    }
    impl<'a> From<AttributeNamespaceMember<'a>> for NamespaceMember<'a> {
        fn from(x: AttributeNamespaceMember<'a>) -> Self {
            NamespaceMember::Attribute(x)
        }
    }
    impl<'a> From<ConstMember<'a>> for NamespaceMember<'a> {
        fn from(x: ConstMember<'a>) -> Self {
            NamespaceMember::Const(x)
        }
    }
    impl<'a> crate::Parse<'a> for NamespaceMember<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <OperationNamespaceMember<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <AttributeNamespaceMember<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <ConstMember<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
}
pub mod types {
    use crate::attribute::ExtendedAttributeList;
    use crate::common::{Generics, Identifier, Parenthesized, Punctuated};
    use crate::term;
    use crate::Parse;
    /// Parses a union of types
    pub type UnionType<'a> = Parenthesized<
        Punctuated<UnionMemberType<'a>, crate::term::Or>,
    >;
    /// Parses either single type or a union type
    pub enum Type<'a> {
        Single(SingleType<'a>),
        Union(MayBeNull<UnionType<'a>>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Type<'a> {
        #[inline]
        fn clone(&self) -> Type<'a> {
            match self {
                Type::Single(__self_0) => {
                    Type::Single(::core::clone::Clone::clone(__self_0))
                }
                Type::Union(__self_0) => {
                    Type::Union(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Type<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Type::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                Type::Union(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Union",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Type<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Type<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<SingleType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<UnionType<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Type<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Type<'a> {
        #[inline]
        fn eq(&self, other: &Type<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Type::Single(__self_0), Type::Single(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Type::Union(__self_0), Type::Union(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Type<'a> {
        #[inline]
        fn cmp(&self, other: &Type<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Type::Single(__self_0), Type::Single(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Type::Union(__self_0), Type::Union(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Type<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Type<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Type::Single(__self_0), Type::Single(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Type::Union(__self_0), Type::Union(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Type<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Type::Single(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Type::Union(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    /// Parses one of the single types
    pub enum SingleType<'a> {
        Any(crate::term::Any),
        NonAny(NonAnyType<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SingleType<'a> {
        #[inline]
        fn clone(&self) -> SingleType<'a> {
            match self {
                SingleType::Any(__self_0) => {
                    SingleType::Any(::core::clone::Clone::clone(__self_0))
                }
                SingleType::NonAny(__self_0) => {
                    SingleType::NonAny(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SingleType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                SingleType::Any(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Any",
                        &__self_0,
                    )
                }
                SingleType::NonAny(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NonAny",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SingleType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SingleType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Any>;
            let _: ::core::cmp::AssertParamIsEq<NonAnyType<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SingleType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SingleType<'a> {
        #[inline]
        fn eq(&self, other: &SingleType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (SingleType::Any(__self_0), SingleType::Any(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (SingleType::NonAny(__self_0), SingleType::NonAny(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SingleType<'a> {
        #[inline]
        fn cmp(&self, other: &SingleType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (SingleType::Any(__self_0), SingleType::Any(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (SingleType::NonAny(__self_0), SingleType::NonAny(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SingleType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SingleType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (SingleType::Any(__self_0), SingleType::Any(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (SingleType::NonAny(__self_0), SingleType::NonAny(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SingleType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                SingleType::Any(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                SingleType::NonAny(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    impl<'a> From<crate::term::Any> for SingleType<'a> {
        fn from(x: crate::term::Any) -> Self {
            SingleType::Any(x)
        }
    }
    impl<'a> From<NonAnyType<'a>> for SingleType<'a> {
        fn from(x: NonAnyType<'a>) -> Self {
            SingleType::NonAny(x)
        }
    }
    impl<'a> crate::Parse<'a> for SingleType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <crate::term::Any as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <NonAnyType<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
    impl<'a> From<SingleType<'a>> for Type<'a> {
        fn from(x: SingleType<'a>) -> Self {
            Type::Single(x)
        }
    }
    impl<'a> From<MayBeNull<UnionType<'a>>> for Type<'a> {
        fn from(x: MayBeNull<UnionType<'a>>) -> Self {
            Type::Union(x)
        }
    }
    impl<'a> crate::Parse<'a> for Type<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <SingleType<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <MayBeNull<UnionType<'a>> as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
    pub enum NonAnyType<'a> {
        Promise(PromiseType<'a>),
        Integer(MayBeNull<IntegerType>),
        FloatingPoint(MayBeNull<FloatingPointType>),
        Boolean(MayBeNull<crate::term::Boolean>),
        Byte(MayBeNull<crate::term::Byte>),
        Octet(MayBeNull<crate::term::Octet>),
        ByteString(MayBeNull<crate::term::ByteString>),
        DOMString(MayBeNull<crate::term::DOMString>),
        USVString(MayBeNull<crate::term::USVString>),
        Sequence(MayBeNull<SequenceType<'a>>),
        Object(MayBeNull<crate::term::Object>),
        Symbol(MayBeNull<crate::term::Symbol>),
        Error(MayBeNull<crate::term::Error>),
        ArrayBuffer(MayBeNull<crate::term::ArrayBuffer>),
        DataView(MayBeNull<crate::term::DataView>),
        Int8Array(MayBeNull<crate::term::Int8Array>),
        Int16Array(MayBeNull<crate::term::Int16Array>),
        Int32Array(MayBeNull<crate::term::Int32Array>),
        Uint8Array(MayBeNull<crate::term::Uint8Array>),
        Uint16Array(MayBeNull<crate::term::Uint16Array>),
        Uint32Array(MayBeNull<crate::term::Uint32Array>),
        Uint8ClampedArray(MayBeNull<crate::term::Uint8ClampedArray>),
        Float32Array(MayBeNull<crate::term::Float32Array>),
        Float64Array(MayBeNull<crate::term::Float64Array>),
        ArrayBufferView(MayBeNull<crate::term::ArrayBufferView>),
        BufferSource(MayBeNull<crate::term::BufferSource>),
        FrozenArrayType(MayBeNull<FrozenArrayType<'a>>),
        ObservableArrayType(MayBeNull<ObservableArrayType<'a>>),
        RecordType(MayBeNull<RecordType<'a>>),
        Identifier(MayBeNull<Identifier<'a>>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for NonAnyType<'a> {
        #[inline]
        fn clone(&self) -> NonAnyType<'a> {
            match self {
                NonAnyType::Promise(__self_0) => {
                    NonAnyType::Promise(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Integer(__self_0) => {
                    NonAnyType::Integer(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::FloatingPoint(__self_0) => {
                    NonAnyType::FloatingPoint(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Boolean(__self_0) => {
                    NonAnyType::Boolean(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Byte(__self_0) => {
                    NonAnyType::Byte(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Octet(__self_0) => {
                    NonAnyType::Octet(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::ByteString(__self_0) => {
                    NonAnyType::ByteString(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::DOMString(__self_0) => {
                    NonAnyType::DOMString(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::USVString(__self_0) => {
                    NonAnyType::USVString(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Sequence(__self_0) => {
                    NonAnyType::Sequence(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Object(__self_0) => {
                    NonAnyType::Object(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Symbol(__self_0) => {
                    NonAnyType::Symbol(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Error(__self_0) => {
                    NonAnyType::Error(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::ArrayBuffer(__self_0) => {
                    NonAnyType::ArrayBuffer(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::DataView(__self_0) => {
                    NonAnyType::DataView(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Int8Array(__self_0) => {
                    NonAnyType::Int8Array(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Int16Array(__self_0) => {
                    NonAnyType::Int16Array(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Int32Array(__self_0) => {
                    NonAnyType::Int32Array(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Uint8Array(__self_0) => {
                    NonAnyType::Uint8Array(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Uint16Array(__self_0) => {
                    NonAnyType::Uint16Array(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Uint32Array(__self_0) => {
                    NonAnyType::Uint32Array(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Uint8ClampedArray(__self_0) => {
                    NonAnyType::Uint8ClampedArray(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Float32Array(__self_0) => {
                    NonAnyType::Float32Array(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Float64Array(__self_0) => {
                    NonAnyType::Float64Array(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::ArrayBufferView(__self_0) => {
                    NonAnyType::ArrayBufferView(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::BufferSource(__self_0) => {
                    NonAnyType::BufferSource(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::FrozenArrayType(__self_0) => {
                    NonAnyType::FrozenArrayType(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::ObservableArrayType(__self_0) => {
                    NonAnyType::ObservableArrayType(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                NonAnyType::RecordType(__self_0) => {
                    NonAnyType::RecordType(::core::clone::Clone::clone(__self_0))
                }
                NonAnyType::Identifier(__self_0) => {
                    NonAnyType::Identifier(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for NonAnyType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                NonAnyType::Promise(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Promise",
                        &__self_0,
                    )
                }
                NonAnyType::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                NonAnyType::FloatingPoint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FloatingPoint",
                        &__self_0,
                    )
                }
                NonAnyType::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                NonAnyType::Byte(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Byte",
                        &__self_0,
                    )
                }
                NonAnyType::Octet(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Octet",
                        &__self_0,
                    )
                }
                NonAnyType::ByteString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ByteString",
                        &__self_0,
                    )
                }
                NonAnyType::DOMString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DOMString",
                        &__self_0,
                    )
                }
                NonAnyType::USVString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "USVString",
                        &__self_0,
                    )
                }
                NonAnyType::Sequence(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Sequence",
                        &__self_0,
                    )
                }
                NonAnyType::Object(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Object",
                        &__self_0,
                    )
                }
                NonAnyType::Symbol(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Symbol",
                        &__self_0,
                    )
                }
                NonAnyType::Error(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Error",
                        &__self_0,
                    )
                }
                NonAnyType::ArrayBuffer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ArrayBuffer",
                        &__self_0,
                    )
                }
                NonAnyType::DataView(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DataView",
                        &__self_0,
                    )
                }
                NonAnyType::Int8Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int8Array",
                        &__self_0,
                    )
                }
                NonAnyType::Int16Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int16Array",
                        &__self_0,
                    )
                }
                NonAnyType::Int32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int32Array",
                        &__self_0,
                    )
                }
                NonAnyType::Uint8Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint8Array",
                        &__self_0,
                    )
                }
                NonAnyType::Uint16Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint16Array",
                        &__self_0,
                    )
                }
                NonAnyType::Uint32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint32Array",
                        &__self_0,
                    )
                }
                NonAnyType::Uint8ClampedArray(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Uint8ClampedArray",
                        &__self_0,
                    )
                }
                NonAnyType::Float32Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float32Array",
                        &__self_0,
                    )
                }
                NonAnyType::Float64Array(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float64Array",
                        &__self_0,
                    )
                }
                NonAnyType::ArrayBufferView(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ArrayBufferView",
                        &__self_0,
                    )
                }
                NonAnyType::BufferSource(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "BufferSource",
                        &__self_0,
                    )
                }
                NonAnyType::FrozenArrayType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FrozenArrayType",
                        &__self_0,
                    )
                }
                NonAnyType::ObservableArrayType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ObservableArrayType",
                        &__self_0,
                    )
                }
                NonAnyType::RecordType(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RecordType",
                        &__self_0,
                    )
                }
                NonAnyType::Identifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Identifier",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for NonAnyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for NonAnyType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<PromiseType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<IntegerType>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<FloatingPointType>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Boolean>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Byte>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Octet>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::ByteString>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::DOMString>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::USVString>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<SequenceType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Object>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Symbol>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Error>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::ArrayBuffer>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::DataView>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Int8Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Int16Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Int32Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Uint8Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Uint16Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Uint32Array>>;
            let _: ::core::cmp::AssertParamIsEq<
                MayBeNull<crate::term::Uint8ClampedArray>,
            >;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Float32Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Float64Array>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::ArrayBufferView>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::BufferSource>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<FrozenArrayType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<ObservableArrayType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<RecordType<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<Identifier<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for NonAnyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for NonAnyType<'a> {
        #[inline]
        fn eq(&self, other: &NonAnyType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (NonAnyType::Promise(__self_0), NonAnyType::Promise(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (NonAnyType::Integer(__self_0), NonAnyType::Integer(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        NonAnyType::FloatingPoint(__self_0),
                        NonAnyType::FloatingPoint(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (NonAnyType::Boolean(__self_0), NonAnyType::Boolean(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (NonAnyType::Byte(__self_0), NonAnyType::Byte(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (NonAnyType::Octet(__self_0), NonAnyType::Octet(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        NonAnyType::ByteString(__self_0),
                        NonAnyType::ByteString(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::DOMString(__self_0),
                        NonAnyType::DOMString(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::USVString(__self_0),
                        NonAnyType::USVString(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (NonAnyType::Sequence(__self_0), NonAnyType::Sequence(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (NonAnyType::Object(__self_0), NonAnyType::Object(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (NonAnyType::Symbol(__self_0), NonAnyType::Symbol(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (NonAnyType::Error(__self_0), NonAnyType::Error(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        NonAnyType::ArrayBuffer(__self_0),
                        NonAnyType::ArrayBuffer(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (NonAnyType::DataView(__self_0), NonAnyType::DataView(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        NonAnyType::Int8Array(__self_0),
                        NonAnyType::Int8Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Int16Array(__self_0),
                        NonAnyType::Int16Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Int32Array(__self_0),
                        NonAnyType::Int32Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Uint8Array(__self_0),
                        NonAnyType::Uint8Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Uint16Array(__self_0),
                        NonAnyType::Uint16Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Uint32Array(__self_0),
                        NonAnyType::Uint32Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Uint8ClampedArray(__self_0),
                        NonAnyType::Uint8ClampedArray(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Float32Array(__self_0),
                        NonAnyType::Float32Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Float64Array(__self_0),
                        NonAnyType::Float64Array(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::ArrayBufferView(__self_0),
                        NonAnyType::ArrayBufferView(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::BufferSource(__self_0),
                        NonAnyType::BufferSource(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::FrozenArrayType(__self_0),
                        NonAnyType::FrozenArrayType(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::ObservableArrayType(__self_0),
                        NonAnyType::ObservableArrayType(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::RecordType(__self_0),
                        NonAnyType::RecordType(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        NonAnyType::Identifier(__self_0),
                        NonAnyType::Identifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for NonAnyType<'a> {
        #[inline]
        fn cmp(&self, other: &NonAnyType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            NonAnyType::Promise(__self_0),
                            NonAnyType::Promise(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Integer(__self_0),
                            NonAnyType::Integer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::FloatingPoint(__self_0),
                            NonAnyType::FloatingPoint(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Boolean(__self_0),
                            NonAnyType::Boolean(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (NonAnyType::Byte(__self_0), NonAnyType::Byte(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (NonAnyType::Octet(__self_0), NonAnyType::Octet(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            NonAnyType::ByteString(__self_0),
                            NonAnyType::ByteString(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::DOMString(__self_0),
                            NonAnyType::DOMString(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::USVString(__self_0),
                            NonAnyType::USVString(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Sequence(__self_0),
                            NonAnyType::Sequence(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (NonAnyType::Object(__self_0), NonAnyType::Object(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (NonAnyType::Symbol(__self_0), NonAnyType::Symbol(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (NonAnyType::Error(__self_0), NonAnyType::Error(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            NonAnyType::ArrayBuffer(__self_0),
                            NonAnyType::ArrayBuffer(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::DataView(__self_0),
                            NonAnyType::DataView(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Int8Array(__self_0),
                            NonAnyType::Int8Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Int16Array(__self_0),
                            NonAnyType::Int16Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Int32Array(__self_0),
                            NonAnyType::Int32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Uint8Array(__self_0),
                            NonAnyType::Uint8Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Uint16Array(__self_0),
                            NonAnyType::Uint16Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Uint32Array(__self_0),
                            NonAnyType::Uint32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Uint8ClampedArray(__self_0),
                            NonAnyType::Uint8ClampedArray(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Float32Array(__self_0),
                            NonAnyType::Float32Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Float64Array(__self_0),
                            NonAnyType::Float64Array(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::ArrayBufferView(__self_0),
                            NonAnyType::ArrayBufferView(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::BufferSource(__self_0),
                            NonAnyType::BufferSource(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::FrozenArrayType(__self_0),
                            NonAnyType::FrozenArrayType(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::ObservableArrayType(__self_0),
                            NonAnyType::ObservableArrayType(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::RecordType(__self_0),
                            NonAnyType::RecordType(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Identifier(__self_0),
                            NonAnyType::Identifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for NonAnyType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &NonAnyType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            NonAnyType::Promise(__self_0),
                            NonAnyType::Promise(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Integer(__self_0),
                            NonAnyType::Integer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::FloatingPoint(__self_0),
                            NonAnyType::FloatingPoint(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Boolean(__self_0),
                            NonAnyType::Boolean(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (NonAnyType::Byte(__self_0), NonAnyType::Byte(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (NonAnyType::Octet(__self_0), NonAnyType::Octet(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            NonAnyType::ByteString(__self_0),
                            NonAnyType::ByteString(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::DOMString(__self_0),
                            NonAnyType::DOMString(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::USVString(__self_0),
                            NonAnyType::USVString(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Sequence(__self_0),
                            NonAnyType::Sequence(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (NonAnyType::Object(__self_0), NonAnyType::Object(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (NonAnyType::Symbol(__self_0), NonAnyType::Symbol(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (NonAnyType::Error(__self_0), NonAnyType::Error(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            NonAnyType::ArrayBuffer(__self_0),
                            NonAnyType::ArrayBuffer(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::DataView(__self_0),
                            NonAnyType::DataView(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Int8Array(__self_0),
                            NonAnyType::Int8Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Int16Array(__self_0),
                            NonAnyType::Int16Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Int32Array(__self_0),
                            NonAnyType::Int32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Uint8Array(__self_0),
                            NonAnyType::Uint8Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Uint16Array(__self_0),
                            NonAnyType::Uint16Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Uint32Array(__self_0),
                            NonAnyType::Uint32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Uint8ClampedArray(__self_0),
                            NonAnyType::Uint8ClampedArray(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Float32Array(__self_0),
                            NonAnyType::Float32Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Float64Array(__self_0),
                            NonAnyType::Float64Array(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::ArrayBufferView(__self_0),
                            NonAnyType::ArrayBufferView(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::BufferSource(__self_0),
                            NonAnyType::BufferSource(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::FrozenArrayType(__self_0),
                            NonAnyType::FrozenArrayType(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::ObservableArrayType(__self_0),
                            NonAnyType::ObservableArrayType(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::RecordType(__self_0),
                            NonAnyType::RecordType(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            NonAnyType::Identifier(__self_0),
                            NonAnyType::Identifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for NonAnyType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                NonAnyType::Promise(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Integer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::FloatingPoint(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Boolean(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Byte(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                NonAnyType::Octet(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                NonAnyType::ByteString(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::DOMString(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::USVString(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Sequence(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Object(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                NonAnyType::Symbol(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                NonAnyType::Error(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                NonAnyType::ArrayBuffer(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::DataView(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Int8Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Int16Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Int32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Uint8Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Uint16Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Uint32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Uint8ClampedArray(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Float32Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Float64Array(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::ArrayBufferView(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::BufferSource(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::FrozenArrayType(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::ObservableArrayType(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::RecordType(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                NonAnyType::Identifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    impl<'a> From<PromiseType<'a>> for NonAnyType<'a> {
        fn from(x: PromiseType<'a>) -> Self {
            NonAnyType::Promise(x)
        }
    }
    impl<'a> From<MayBeNull<IntegerType>> for NonAnyType<'a> {
        fn from(x: MayBeNull<IntegerType>) -> Self {
            NonAnyType::Integer(x)
        }
    }
    impl<'a> From<MayBeNull<FloatingPointType>> for NonAnyType<'a> {
        fn from(x: MayBeNull<FloatingPointType>) -> Self {
            NonAnyType::FloatingPoint(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Boolean>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Boolean>) -> Self {
            NonAnyType::Boolean(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Byte>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Byte>) -> Self {
            NonAnyType::Byte(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Octet>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Octet>) -> Self {
            NonAnyType::Octet(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::ByteString>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::ByteString>) -> Self {
            NonAnyType::ByteString(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::DOMString>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::DOMString>) -> Self {
            NonAnyType::DOMString(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::USVString>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::USVString>) -> Self {
            NonAnyType::USVString(x)
        }
    }
    impl<'a> From<MayBeNull<SequenceType<'a>>> for NonAnyType<'a> {
        fn from(x: MayBeNull<SequenceType<'a>>) -> Self {
            NonAnyType::Sequence(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Object>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Object>) -> Self {
            NonAnyType::Object(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Symbol>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Symbol>) -> Self {
            NonAnyType::Symbol(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Error>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Error>) -> Self {
            NonAnyType::Error(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::ArrayBuffer>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::ArrayBuffer>) -> Self {
            NonAnyType::ArrayBuffer(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::DataView>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::DataView>) -> Self {
            NonAnyType::DataView(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Int8Array>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Int8Array>) -> Self {
            NonAnyType::Int8Array(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Int16Array>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Int16Array>) -> Self {
            NonAnyType::Int16Array(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Int32Array>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Int32Array>) -> Self {
            NonAnyType::Int32Array(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Uint8Array>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Uint8Array>) -> Self {
            NonAnyType::Uint8Array(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Uint16Array>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Uint16Array>) -> Self {
            NonAnyType::Uint16Array(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Uint32Array>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Uint32Array>) -> Self {
            NonAnyType::Uint32Array(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Uint8ClampedArray>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Uint8ClampedArray>) -> Self {
            NonAnyType::Uint8ClampedArray(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Float32Array>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Float32Array>) -> Self {
            NonAnyType::Float32Array(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Float64Array>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::Float64Array>) -> Self {
            NonAnyType::Float64Array(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::ArrayBufferView>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::ArrayBufferView>) -> Self {
            NonAnyType::ArrayBufferView(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::BufferSource>> for NonAnyType<'a> {
        fn from(x: MayBeNull<crate::term::BufferSource>) -> Self {
            NonAnyType::BufferSource(x)
        }
    }
    impl<'a> From<MayBeNull<FrozenArrayType<'a>>> for NonAnyType<'a> {
        fn from(x: MayBeNull<FrozenArrayType<'a>>) -> Self {
            NonAnyType::FrozenArrayType(x)
        }
    }
    impl<'a> From<MayBeNull<ObservableArrayType<'a>>> for NonAnyType<'a> {
        fn from(x: MayBeNull<ObservableArrayType<'a>>) -> Self {
            NonAnyType::ObservableArrayType(x)
        }
    }
    impl<'a> From<MayBeNull<RecordType<'a>>> for NonAnyType<'a> {
        fn from(x: MayBeNull<RecordType<'a>>) -> Self {
            NonAnyType::RecordType(x)
        }
    }
    impl<'a> From<MayBeNull<Identifier<'a>>> for NonAnyType<'a> {
        fn from(x: MayBeNull<Identifier<'a>>) -> Self {
            NonAnyType::Identifier(x)
        }
    }
    impl<'a> crate::Parse<'a> for NonAnyType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <PromiseType<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <MayBeNull<IntegerType> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <MayBeNull<FloatingPointType> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <MayBeNull<crate::term::Boolean> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::branch::alt((
                        nom::combinator::map(
                            <MayBeNull<crate::term::Byte> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::combinator::map(
                            <MayBeNull<crate::term::Octet> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::branch::alt((
                            nom::combinator::map(
                                <MayBeNull<
                                    crate::term::ByteString,
                                > as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                            nom::combinator::map(
                                <MayBeNull<
                                    crate::term::DOMString,
                                > as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                            nom::branch::alt((
                                nom::combinator::map(
                                    <MayBeNull<
                                        crate::term::USVString,
                                    > as crate::Parse<'a>>::parse,
                                    From::from,
                                ),
                                nom::combinator::map(
                                    <MayBeNull<SequenceType<'a>> as crate::Parse<'a>>::parse,
                                    From::from,
                                ),
                                nom::branch::alt((
                                    nom::combinator::map(
                                        <MayBeNull<crate::term::Object> as crate::Parse<'a>>::parse,
                                        From::from,
                                    ),
                                    nom::combinator::map(
                                        <MayBeNull<crate::term::Symbol> as crate::Parse<'a>>::parse,
                                        From::from,
                                    ),
                                    nom::branch::alt((
                                        nom::combinator::map(
                                            <MayBeNull<crate::term::Error> as crate::Parse<'a>>::parse,
                                            From::from,
                                        ),
                                        nom::combinator::map(
                                            <MayBeNull<
                                                crate::term::ArrayBuffer,
                                            > as crate::Parse<'a>>::parse,
                                            From::from,
                                        ),
                                        nom::branch::alt((
                                            nom::combinator::map(
                                                <MayBeNull<
                                                    crate::term::DataView,
                                                > as crate::Parse<'a>>::parse,
                                                From::from,
                                            ),
                                            nom::combinator::map(
                                                <MayBeNull<
                                                    crate::term::Int8Array,
                                                > as crate::Parse<'a>>::parse,
                                                From::from,
                                            ),
                                            nom::branch::alt((
                                                nom::combinator::map(
                                                    <MayBeNull<
                                                        crate::term::Int16Array,
                                                    > as crate::Parse<'a>>::parse,
                                                    From::from,
                                                ),
                                                nom::combinator::map(
                                                    <MayBeNull<
                                                        crate::term::Int32Array,
                                                    > as crate::Parse<'a>>::parse,
                                                    From::from,
                                                ),
                                                nom::branch::alt((
                                                    nom::combinator::map(
                                                        <MayBeNull<
                                                            crate::term::Uint8Array,
                                                        > as crate::Parse<'a>>::parse,
                                                        From::from,
                                                    ),
                                                    nom::combinator::map(
                                                        <MayBeNull<
                                                            crate::term::Uint16Array,
                                                        > as crate::Parse<'a>>::parse,
                                                        From::from,
                                                    ),
                                                    nom::branch::alt((
                                                        nom::combinator::map(
                                                            <MayBeNull<
                                                                crate::term::Uint32Array,
                                                            > as crate::Parse<'a>>::parse,
                                                            From::from,
                                                        ),
                                                        nom::combinator::map(
                                                            <MayBeNull<
                                                                crate::term::Uint8ClampedArray,
                                                            > as crate::Parse<'a>>::parse,
                                                            From::from,
                                                        ),
                                                        nom::branch::alt((
                                                            nom::combinator::map(
                                                                <MayBeNull<
                                                                    crate::term::Float32Array,
                                                                > as crate::Parse<'a>>::parse,
                                                                From::from,
                                                            ),
                                                            nom::combinator::map(
                                                                <MayBeNull<
                                                                    crate::term::Float64Array,
                                                                > as crate::Parse<'a>>::parse,
                                                                From::from,
                                                            ),
                                                            nom::branch::alt((
                                                                nom::combinator::map(
                                                                    <MayBeNull<
                                                                        crate::term::ArrayBufferView,
                                                                    > as crate::Parse<'a>>::parse,
                                                                    From::from,
                                                                ),
                                                                nom::combinator::map(
                                                                    <MayBeNull<
                                                                        crate::term::BufferSource,
                                                                    > as crate::Parse<'a>>::parse,
                                                                    From::from,
                                                                ),
                                                                nom::branch::alt((
                                                                    nom::combinator::map(
                                                                        <MayBeNull<FrozenArrayType<'a>> as crate::Parse<'a>>::parse,
                                                                        From::from,
                                                                    ),
                                                                    nom::combinator::map(
                                                                        <MayBeNull<
                                                                            ObservableArrayType<'a>,
                                                                        > as crate::Parse<'a>>::parse,
                                                                        From::from,
                                                                    ),
                                                                    nom::branch::alt((
                                                                        nom::combinator::map(
                                                                            <MayBeNull<RecordType<'a>> as crate::Parse<'a>>::parse,
                                                                            From::from,
                                                                        ),
                                                                        nom::combinator::map(
                                                                            <MayBeNull<Identifier<'a>> as crate::Parse<'a>>::parse,
                                                                            From::from,
                                                                        ),
                                                                    )),
                                                                )),
                                                            )),
                                                        )),
                                                    )),
                                                )),
                                            )),
                                        )),
                                    )),
                                )),
                            )),
                        )),
                    )),
                )),
            ))(input)
        }
    }
    /// Parses `sequence<Type>`
    pub struct SequenceType<'a> {
        pub sequence: crate::term::Sequence,
        pub generics: Generics<Box<AttributedType<'a>>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for SequenceType<'a> {
        #[inline]
        fn clone(&self) -> SequenceType<'a> {
            SequenceType {
                sequence: ::core::clone::Clone::clone(&self.sequence),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for SequenceType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "SequenceType",
                "sequence",
                &&self.sequence,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for SequenceType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for SequenceType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Sequence>;
            let _: ::core::cmp::AssertParamIsEq<Generics<Box<AttributedType<'a>>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for SequenceType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for SequenceType<'a> {
        #[inline]
        fn eq(&self, other: &SequenceType<'a>) -> bool {
            self.sequence == other.sequence && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for SequenceType<'a> {
        #[inline]
        fn cmp(&self, other: &SequenceType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.sequence, &other.sequence) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for SequenceType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SequenceType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.sequence, &other.sequence) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for SequenceType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.sequence, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    impl<'a> crate::Parse<'a> for SequenceType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::Sequence as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, sequence)) => {
                        use nom::lib::std::result::Result::*;
                        match <Generics<
                            Box<AttributedType<'a>>,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, generics)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { sequence, generics }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `FrozenArray<Type>`
    pub struct FrozenArrayType<'a> {
        pub frozen_array: crate::term::FrozenArray,
        pub generics: Generics<Box<AttributedType<'a>>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for FrozenArrayType<'a> {
        #[inline]
        fn clone(&self) -> FrozenArrayType<'a> {
            FrozenArrayType {
                frozen_array: ::core::clone::Clone::clone(&self.frozen_array),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for FrozenArrayType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FrozenArrayType",
                "frozen_array",
                &&self.frozen_array,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for FrozenArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for FrozenArrayType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::FrozenArray>;
            let _: ::core::cmp::AssertParamIsEq<Generics<Box<AttributedType<'a>>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for FrozenArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for FrozenArrayType<'a> {
        #[inline]
        fn eq(&self, other: &FrozenArrayType<'a>) -> bool {
            self.frozen_array == other.frozen_array && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for FrozenArrayType<'a> {
        #[inline]
        fn cmp(&self, other: &FrozenArrayType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.frozen_array, &other.frozen_array) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for FrozenArrayType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FrozenArrayType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.frozen_array,
                &other.frozen_array,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for FrozenArrayType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.frozen_array, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    impl<'a> crate::Parse<'a> for FrozenArrayType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::FrozenArray as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, frozen_array)) => {
                        use nom::lib::std::result::Result::*;
                        match <Generics<
                            Box<AttributedType<'a>>,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, generics)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { frozen_array, generics }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `ObservableArray<Type>`
    pub struct ObservableArrayType<'a> {
        pub observable_array: crate::term::ObservableArray,
        pub generics: Generics<Box<AttributedType<'a>>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ObservableArrayType<'a> {
        #[inline]
        fn clone(&self) -> ObservableArrayType<'a> {
            ObservableArrayType {
                observable_array: ::core::clone::Clone::clone(&self.observable_array),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ObservableArrayType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ObservableArrayType",
                "observable_array",
                &&self.observable_array,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ObservableArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ObservableArrayType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::ObservableArray>;
            let _: ::core::cmp::AssertParamIsEq<Generics<Box<AttributedType<'a>>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ObservableArrayType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ObservableArrayType<'a> {
        #[inline]
        fn eq(&self, other: &ObservableArrayType<'a>) -> bool {
            self.observable_array == other.observable_array
                && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ObservableArrayType<'a> {
        #[inline]
        fn cmp(&self, other: &ObservableArrayType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(
                &self.observable_array,
                &other.observable_array,
            ) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ObservableArrayType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ObservableArrayType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.observable_array,
                &other.observable_array,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ObservableArrayType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.observable_array, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    impl<'a> crate::Parse<'a> for ObservableArrayType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::ObservableArray as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, observable_array)) => {
                        use nom::lib::std::result::Result::*;
                        match <Generics<
                            Box<AttributedType<'a>>,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, generics)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { observable_array, generics }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses a nullable type. Ex: `object | object??`
    ///
    /// `??` means an actual ? not an optional requirement
    pub struct MayBeNull<T> {
        pub type_: T,
        pub q_mark: Option<term::QMark>,
    }
    #[automatically_derived]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for MayBeNull<T> {
        #[inline]
        fn clone(&self) -> MayBeNull<T> {
            MayBeNull {
                type_: ::core::clone::Clone::clone(&self.type_),
                q_mark: ::core::clone::Clone::clone(&self.q_mark),
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for MayBeNull<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "MayBeNull",
                "type_",
                &&self.type_,
                "q_mark",
                &&self.q_mark,
            )
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralEq for MayBeNull<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::Eq> ::core::cmp::Eq for MayBeNull<T> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<T>;
            let _: ::core::cmp::AssertParamIsEq<Option<term::QMark>>;
        }
    }
    #[automatically_derived]
    impl<T> ::core::marker::StructuralPartialEq for MayBeNull<T> {}
    #[automatically_derived]
    impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for MayBeNull<T> {
        #[inline]
        fn eq(&self, other: &MayBeNull<T>) -> bool {
            self.type_ == other.type_ && self.q_mark == other.q_mark
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::Ord> ::core::cmp::Ord for MayBeNull<T> {
        #[inline]
        fn cmp(&self, other: &MayBeNull<T>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.q_mark, &other.q_mark)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for MayBeNull<T> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MayBeNull<T>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.type_, &other.type_) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.q_mark, &other.q_mark)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<T: ::core::hash::Hash> ::core::hash::Hash for MayBeNull<T> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.type_, state);
            ::core::hash::Hash::hash(&self.q_mark, state)
        }
    }
    #[automatically_derived]
    impl<T: ::core::marker::Copy> ::core::marker::Copy for MayBeNull<T> {}
    impl<'a, T> crate::Parse<'a> for MayBeNull<T>
    where
        T: Parse<'a>,
    {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <T as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, type_)) => {
                        use nom::lib::std::result::Result::*;
                        match <Option<term::QMark> as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, q_mark)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { type_, q_mark }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses a `Promise<Type|undefined>` type
    pub struct PromiseType<'a> {
        pub promise: crate::term::Promise,
        pub generics: Generics<Box<ReturnType<'a>>>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for PromiseType<'a> {
        #[inline]
        fn clone(&self) -> PromiseType<'a> {
            PromiseType {
                promise: ::core::clone::Clone::clone(&self.promise),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for PromiseType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "PromiseType",
                "promise",
                &&self.promise,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for PromiseType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for PromiseType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Promise>;
            let _: ::core::cmp::AssertParamIsEq<Generics<Box<ReturnType<'a>>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for PromiseType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for PromiseType<'a> {
        #[inline]
        fn eq(&self, other: &PromiseType<'a>) -> bool {
            self.promise == other.promise && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for PromiseType<'a> {
        #[inline]
        fn cmp(&self, other: &PromiseType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.promise, &other.promise) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for PromiseType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &PromiseType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.promise, &other.promise) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for PromiseType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.promise, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    impl<'a> crate::Parse<'a> for PromiseType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::Promise as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, promise)) => {
                        use nom::lib::std::result::Result::*;
                        match <Generics<
                            Box<ReturnType<'a>>,
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, generics)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { promise, generics }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `unsigned? short|long|(long long)`
    pub enum IntegerType {
        LongLong(LongLongType),
        Long(LongType),
        Short(ShortType),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IntegerType {
        #[inline]
        fn clone(&self) -> IntegerType {
            let _: ::core::clone::AssertParamIsClone<LongLongType>;
            let _: ::core::clone::AssertParamIsClone<LongType>;
            let _: ::core::clone::AssertParamIsClone<ShortType>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IntegerType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                IntegerType::LongLong(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LongLong",
                        &__self_0,
                    )
                }
                IntegerType::Long(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Long",
                        &__self_0,
                    )
                }
                IntegerType::Short(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Short",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for IntegerType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for IntegerType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<LongLongType>;
            let _: ::core::cmp::AssertParamIsEq<LongType>;
            let _: ::core::cmp::AssertParamIsEq<ShortType>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IntegerType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IntegerType {
        #[inline]
        fn eq(&self, other: &IntegerType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        IntegerType::LongLong(__self_0),
                        IntegerType::LongLong(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (IntegerType::Long(__self_0), IntegerType::Long(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (IntegerType::Short(__self_0), IntegerType::Short(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for IntegerType {
        #[inline]
        fn cmp(&self, other: &IntegerType) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            IntegerType::LongLong(__self_0),
                            IntegerType::LongLong(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (IntegerType::Long(__self_0), IntegerType::Long(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (IntegerType::Short(__self_0), IntegerType::Short(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for IntegerType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &IntegerType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            IntegerType::LongLong(__self_0),
                            IntegerType::LongLong(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (IntegerType::Long(__self_0), IntegerType::Long(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (IntegerType::Short(__self_0), IntegerType::Short(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for IntegerType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                IntegerType::LongLong(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                IntegerType::Long(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                IntegerType::Short(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for IntegerType {}
    /// Parses `unsigned? long long`
    pub struct LongLongType {
        pub unsigned: Option<crate::term::Unsigned>,
        pub long_long: (crate::term::Long, crate::term::Long),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LongLongType {
        #[inline]
        fn clone(&self) -> LongLongType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unsigned>>;
            let _: ::core::clone::AssertParamIsClone<
                (crate::term::Long, crate::term::Long),
            >;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LongLongType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "LongLongType",
                "unsigned",
                &&self.unsigned,
                "long_long",
                &&self.long_long,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for LongLongType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for LongLongType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unsigned>>;
            let _: ::core::cmp::AssertParamIsEq<(crate::term::Long, crate::term::Long)>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LongLongType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LongLongType {
        #[inline]
        fn eq(&self, other: &LongLongType) -> bool {
            self.unsigned == other.unsigned && self.long_long == other.long_long
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for LongLongType {
        #[inline]
        fn cmp(&self, other: &LongLongType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unsigned, &other.unsigned) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.long_long, &other.long_long)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for LongLongType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &LongLongType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.unsigned, &other.unsigned) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.long_long,
                        &other.long_long,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for LongLongType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unsigned, state);
            ::core::hash::Hash::hash(&self.long_long, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for LongLongType {}
    impl<'a> crate::Parse<'a> for LongLongType {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<crate::term::Unsigned> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, unsigned)) => {
                        use nom::lib::std::result::Result::*;
                        match <(
                            crate::term::Long,
                            crate::term::Long,
                        ) as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, long_long)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { unsigned, long_long }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `unsigned? long`
    pub struct LongType {
        pub unsigned: Option<crate::term::Unsigned>,
        pub long: crate::term::Long,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LongType {
        #[inline]
        fn clone(&self) -> LongType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unsigned>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Long>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LongType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "LongType",
                "unsigned",
                &&self.unsigned,
                "long",
                &&self.long,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for LongType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for LongType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unsigned>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Long>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LongType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LongType {
        #[inline]
        fn eq(&self, other: &LongType) -> bool {
            self.unsigned == other.unsigned && self.long == other.long
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for LongType {
        #[inline]
        fn cmp(&self, other: &LongType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unsigned, &other.unsigned) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.long, &other.long)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for LongType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &LongType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.unsigned, &other.unsigned) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.long, &other.long)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for LongType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unsigned, state);
            ::core::hash::Hash::hash(&self.long, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for LongType {}
    impl<'a> crate::Parse<'a> for LongType {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<crate::term::Unsigned> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, unsigned)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Long as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, long)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { unsigned, long }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `unsigned? short`
    pub struct ShortType {
        pub unsigned: Option<crate::term::Unsigned>,
        pub short: crate::term::Short,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ShortType {
        #[inline]
        fn clone(&self) -> ShortType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unsigned>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Short>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ShortType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ShortType",
                "unsigned",
                &&self.unsigned,
                "short",
                &&self.short,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ShortType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ShortType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unsigned>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Short>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ShortType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ShortType {
        #[inline]
        fn eq(&self, other: &ShortType) -> bool {
            self.unsigned == other.unsigned && self.short == other.short
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ShortType {
        #[inline]
        fn cmp(&self, other: &ShortType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unsigned, &other.unsigned) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.short, &other.short)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ShortType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ShortType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.unsigned, &other.unsigned) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.short, &other.short)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ShortType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unsigned, state);
            ::core::hash::Hash::hash(&self.short, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ShortType {}
    impl<'a> crate::Parse<'a> for ShortType {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<crate::term::Unsigned> as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, unsigned)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Short as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, short)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { unsigned, short }))
                            }
                        }
                    }
                }
            }
        }
    }
    impl From<LongLongType> for IntegerType {
        fn from(x: LongLongType) -> Self {
            IntegerType::LongLong(x)
        }
    }
    impl From<LongType> for IntegerType {
        fn from(x: LongType) -> Self {
            IntegerType::Long(x)
        }
    }
    impl From<ShortType> for IntegerType {
        fn from(x: ShortType) -> Self {
            IntegerType::Short(x)
        }
    }
    impl<'a> crate::Parse<'a> for IntegerType {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <LongLongType as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(<LongType as crate::Parse<'a>>::parse, From::from),
                nom::combinator::map(<ShortType as crate::Parse<'a>>::parse, From::from),
            ))(input)
        }
    }
    /// Parses `unrestricted? float|double`
    pub enum FloatingPointType {
        Float(FloatType),
        Double(DoubleType),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FloatingPointType {
        #[inline]
        fn clone(&self) -> FloatingPointType {
            let _: ::core::clone::AssertParamIsClone<FloatType>;
            let _: ::core::clone::AssertParamIsClone<DoubleType>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FloatingPointType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FloatingPointType::Float(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Float",
                        &__self_0,
                    )
                }
                FloatingPointType::Double(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Double",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FloatingPointType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FloatingPointType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<FloatType>;
            let _: ::core::cmp::AssertParamIsEq<DoubleType>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FloatingPointType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FloatingPointType {
        #[inline]
        fn eq(&self, other: &FloatingPointType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        FloatingPointType::Float(__self_0),
                        FloatingPointType::Float(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        FloatingPointType::Double(__self_0),
                        FloatingPointType::Double(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FloatingPointType {
        #[inline]
        fn cmp(&self, other: &FloatingPointType) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            FloatingPointType::Float(__self_0),
                            FloatingPointType::Float(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            FloatingPointType::Double(__self_0),
                            FloatingPointType::Double(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FloatingPointType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FloatingPointType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            FloatingPointType::Float(__self_0),
                            FloatingPointType::Float(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            FloatingPointType::Double(__self_0),
                            FloatingPointType::Double(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FloatingPointType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                FloatingPointType::Float(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                FloatingPointType::Double(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FloatingPointType {}
    /// Parses `unrestricted? float`
    pub struct FloatType {
        pub unrestricted: Option<crate::term::Unrestricted>,
        pub float: crate::term::Float,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FloatType {
        #[inline]
        fn clone(&self) -> FloatType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unrestricted>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Float>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FloatType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FloatType",
                "unrestricted",
                &&self.unrestricted,
                "float",
                &&self.float,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FloatType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FloatType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unrestricted>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Float>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FloatType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FloatType {
        #[inline]
        fn eq(&self, other: &FloatType) -> bool {
            self.unrestricted == other.unrestricted && self.float == other.float
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FloatType {
        #[inline]
        fn cmp(&self, other: &FloatType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unrestricted, &other.unrestricted) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.float, &other.float)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FloatType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FloatType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.unrestricted,
                &other.unrestricted,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.float, &other.float)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FloatType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unrestricted, state);
            ::core::hash::Hash::hash(&self.float, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FloatType {}
    impl<'a> crate::Parse<'a> for FloatType {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    crate::term::Unrestricted,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, unrestricted)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Float as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, float)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { unrestricted, float }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `unrestricted? double`
    pub struct DoubleType {
        pub unrestricted: Option<crate::term::Unrestricted>,
        pub double: crate::term::Double,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DoubleType {
        #[inline]
        fn clone(&self) -> DoubleType {
            let _: ::core::clone::AssertParamIsClone<Option<crate::term::Unrestricted>>;
            let _: ::core::clone::AssertParamIsClone<crate::term::Double>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DoubleType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "DoubleType",
                "unrestricted",
                &&self.unrestricted,
                "double",
                &&self.double,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DoubleType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DoubleType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<crate::term::Unrestricted>>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::Double>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DoubleType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DoubleType {
        #[inline]
        fn eq(&self, other: &DoubleType) -> bool {
            self.unrestricted == other.unrestricted && self.double == other.double
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DoubleType {
        #[inline]
        fn cmp(&self, other: &DoubleType) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.unrestricted, &other.unrestricted) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.double, &other.double)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DoubleType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DoubleType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.unrestricted,
                &other.unrestricted,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.double, &other.double)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DoubleType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.unrestricted, state);
            ::core::hash::Hash::hash(&self.double, state)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DoubleType {}
    impl<'a> crate::Parse<'a> for DoubleType {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    crate::term::Unrestricted,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, unrestricted)) => {
                        use nom::lib::std::result::Result::*;
                        match <crate::term::Double as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, double)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { unrestricted, double }))
                            }
                        }
                    }
                }
            }
        }
    }
    impl From<FloatType> for FloatingPointType {
        fn from(x: FloatType) -> Self {
            FloatingPointType::Float(x)
        }
    }
    impl From<DoubleType> for FloatingPointType {
        fn from(x: DoubleType) -> Self {
            FloatingPointType::Double(x)
        }
    }
    impl<'a> crate::Parse<'a> for FloatingPointType {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(<FloatType as crate::Parse<'a>>::parse, From::from),
                nom::combinator::map(<DoubleType as crate::Parse<'a>>::parse, From::from),
            ))(input)
        }
    }
    /// Parses `record<StringType, Type>`
    pub struct RecordType<'a> {
        pub record: crate::term::Record,
        pub generics: Generics<
            (Box<RecordKeyType<'a>>, crate::term::Comma, Box<AttributedType<'a>>),
        >,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for RecordType<'a> {
        #[inline]
        fn clone(&self) -> RecordType<'a> {
            RecordType {
                record: ::core::clone::Clone::clone(&self.record),
                generics: ::core::clone::Clone::clone(&self.generics),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for RecordType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "RecordType",
                "record",
                &&self.record,
                "generics",
                &&self.generics,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for RecordType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for RecordType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Record>;
            let _: ::core::cmp::AssertParamIsEq<
                Generics<
                    (Box<RecordKeyType<'a>>, crate::term::Comma, Box<AttributedType<'a>>),
                >,
            >;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for RecordType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for RecordType<'a> {
        #[inline]
        fn eq(&self, other: &RecordType<'a>) -> bool {
            self.record == other.record && self.generics == other.generics
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for RecordType<'a> {
        #[inline]
        fn cmp(&self, other: &RecordType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.record, &other.record) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for RecordType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RecordType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.record, &other.record) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.generics, &other.generics)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for RecordType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.record, state);
            ::core::hash::Hash::hash(&self.generics, state)
        }
    }
    impl<'a> crate::Parse<'a> for RecordType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <crate::term::Record as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, record)) => {
                        use nom::lib::std::result::Result::*;
                        match <Generics<
                            (
                                Box<RecordKeyType<'a>>,
                                crate::term::Comma,
                                Box<AttributedType<'a>>,
                            ),
                        > as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, generics)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { record, generics }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses one of the string types `ByteString|DOMString|USVString` or any other type.
    pub enum RecordKeyType<'a> {
        Byte(crate::term::ByteString),
        DOM(crate::term::DOMString),
        USV(crate::term::USVString),
        NonAny(NonAnyType<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for RecordKeyType<'a> {
        #[inline]
        fn clone(&self) -> RecordKeyType<'a> {
            match self {
                RecordKeyType::Byte(__self_0) => {
                    RecordKeyType::Byte(::core::clone::Clone::clone(__self_0))
                }
                RecordKeyType::DOM(__self_0) => {
                    RecordKeyType::DOM(::core::clone::Clone::clone(__self_0))
                }
                RecordKeyType::USV(__self_0) => {
                    RecordKeyType::USV(::core::clone::Clone::clone(__self_0))
                }
                RecordKeyType::NonAny(__self_0) => {
                    RecordKeyType::NonAny(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for RecordKeyType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                RecordKeyType::Byte(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Byte",
                        &__self_0,
                    )
                }
                RecordKeyType::DOM(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DOM",
                        &__self_0,
                    )
                }
                RecordKeyType::USV(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "USV",
                        &__self_0,
                    )
                }
                RecordKeyType::NonAny(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NonAny",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for RecordKeyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for RecordKeyType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::ByteString>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::DOMString>;
            let _: ::core::cmp::AssertParamIsEq<crate::term::USVString>;
            let _: ::core::cmp::AssertParamIsEq<NonAnyType<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for RecordKeyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for RecordKeyType<'a> {
        #[inline]
        fn eq(&self, other: &RecordKeyType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (RecordKeyType::Byte(__self_0), RecordKeyType::Byte(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (RecordKeyType::DOM(__self_0), RecordKeyType::DOM(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (RecordKeyType::USV(__self_0), RecordKeyType::USV(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        RecordKeyType::NonAny(__self_0),
                        RecordKeyType::NonAny(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for RecordKeyType<'a> {
        #[inline]
        fn cmp(&self, other: &RecordKeyType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            RecordKeyType::Byte(__self_0),
                            RecordKeyType::Byte(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (RecordKeyType::DOM(__self_0), RecordKeyType::DOM(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (RecordKeyType::USV(__self_0), RecordKeyType::USV(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            RecordKeyType::NonAny(__self_0),
                            RecordKeyType::NonAny(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for RecordKeyType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RecordKeyType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            RecordKeyType::Byte(__self_0),
                            RecordKeyType::Byte(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (RecordKeyType::DOM(__self_0), RecordKeyType::DOM(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (RecordKeyType::USV(__self_0), RecordKeyType::USV(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            RecordKeyType::NonAny(__self_0),
                            RecordKeyType::NonAny(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for RecordKeyType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                RecordKeyType::Byte(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                RecordKeyType::DOM(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                RecordKeyType::USV(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                RecordKeyType::NonAny(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    impl<'a> From<crate::term::ByteString> for RecordKeyType<'a> {
        fn from(x: crate::term::ByteString) -> Self {
            RecordKeyType::Byte(x)
        }
    }
    impl<'a> From<crate::term::DOMString> for RecordKeyType<'a> {
        fn from(x: crate::term::DOMString) -> Self {
            RecordKeyType::DOM(x)
        }
    }
    impl<'a> From<crate::term::USVString> for RecordKeyType<'a> {
        fn from(x: crate::term::USVString) -> Self {
            RecordKeyType::USV(x)
        }
    }
    impl<'a> From<NonAnyType<'a>> for RecordKeyType<'a> {
        fn from(x: NonAnyType<'a>) -> Self {
            RecordKeyType::NonAny(x)
        }
    }
    impl<'a> crate::Parse<'a> for RecordKeyType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <crate::term::ByteString as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <crate::term::DOMString as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <crate::term::USVString as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <NonAnyType<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                )),
            ))(input)
        }
    }
    /// Parses one of the member of a union type
    pub enum UnionMemberType<'a> {
        Single(AttributedNonAnyType<'a>),
        Union(MayBeNull<UnionType<'a>>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for UnionMemberType<'a> {
        #[inline]
        fn clone(&self) -> UnionMemberType<'a> {
            match self {
                UnionMemberType::Single(__self_0) => {
                    UnionMemberType::Single(::core::clone::Clone::clone(__self_0))
                }
                UnionMemberType::Union(__self_0) => {
                    UnionMemberType::Union(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for UnionMemberType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UnionMemberType::Single(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Single",
                        &__self_0,
                    )
                }
                UnionMemberType::Union(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Union",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for UnionMemberType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for UnionMemberType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<AttributedNonAnyType<'a>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<UnionType<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for UnionMemberType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for UnionMemberType<'a> {
        #[inline]
        fn eq(&self, other: &UnionMemberType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        UnionMemberType::Single(__self_0),
                        UnionMemberType::Single(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        UnionMemberType::Union(__self_0),
                        UnionMemberType::Union(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for UnionMemberType<'a> {
        #[inline]
        fn cmp(&self, other: &UnionMemberType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            UnionMemberType::Single(__self_0),
                            UnionMemberType::Single(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            UnionMemberType::Union(__self_0),
                            UnionMemberType::Union(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for UnionMemberType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UnionMemberType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            UnionMemberType::Single(__self_0),
                            UnionMemberType::Single(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            UnionMemberType::Union(__self_0),
                            UnionMemberType::Union(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for UnionMemberType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                UnionMemberType::Single(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                UnionMemberType::Union(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    impl<'a> From<AttributedNonAnyType<'a>> for UnionMemberType<'a> {
        fn from(x: AttributedNonAnyType<'a>) -> Self {
            UnionMemberType::Single(x)
        }
    }
    impl<'a> From<MayBeNull<UnionType<'a>>> for UnionMemberType<'a> {
        fn from(x: MayBeNull<UnionType<'a>>) -> Self {
            UnionMemberType::Union(x)
        }
    }
    impl<'a> crate::Parse<'a> for UnionMemberType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <AttributedNonAnyType<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <MayBeNull<UnionType<'a>> as crate::Parse<'a>>::parse,
                    From::from,
                ),
            ))(input)
        }
    }
    /// Parses a const type
    pub enum ConstType<'a> {
        Integer(MayBeNull<IntegerType>),
        FloatingPoint(MayBeNull<FloatingPointType>),
        Boolean(MayBeNull<crate::term::Boolean>),
        Byte(MayBeNull<crate::term::Byte>),
        Octet(MayBeNull<crate::term::Octet>),
        Identifier(MayBeNull<Identifier<'a>>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ConstType<'a> {
        #[inline]
        fn clone(&self) -> ConstType<'a> {
            match self {
                ConstType::Integer(__self_0) => {
                    ConstType::Integer(::core::clone::Clone::clone(__self_0))
                }
                ConstType::FloatingPoint(__self_0) => {
                    ConstType::FloatingPoint(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Boolean(__self_0) => {
                    ConstType::Boolean(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Byte(__self_0) => {
                    ConstType::Byte(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Octet(__self_0) => {
                    ConstType::Octet(::core::clone::Clone::clone(__self_0))
                }
                ConstType::Identifier(__self_0) => {
                    ConstType::Identifier(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ConstType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ConstType::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                ConstType::FloatingPoint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "FloatingPoint",
                        &__self_0,
                    )
                }
                ConstType::Boolean(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Boolean",
                        &__self_0,
                    )
                }
                ConstType::Byte(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Byte",
                        &__self_0,
                    )
                }
                ConstType::Octet(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Octet",
                        &__self_0,
                    )
                }
                ConstType::Identifier(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Identifier",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ConstType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ConstType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<IntegerType>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<FloatingPointType>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Boolean>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Byte>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<crate::term::Octet>>;
            let _: ::core::cmp::AssertParamIsEq<MayBeNull<Identifier<'a>>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ConstType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ConstType<'a> {
        #[inline]
        fn eq(&self, other: &ConstType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (ConstType::Integer(__self_0), ConstType::Integer(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        ConstType::FloatingPoint(__self_0),
                        ConstType::FloatingPoint(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (ConstType::Boolean(__self_0), ConstType::Boolean(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstType::Byte(__self_0), ConstType::Byte(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (ConstType::Octet(__self_0), ConstType::Octet(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        ConstType::Identifier(__self_0),
                        ConstType::Identifier(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ConstType<'a> {
        #[inline]
        fn cmp(&self, other: &ConstType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (ConstType::Integer(__self_0), ConstType::Integer(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstType::FloatingPoint(__self_0),
                            ConstType::FloatingPoint(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (ConstType::Boolean(__self_0), ConstType::Boolean(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Byte(__self_0), ConstType::Byte(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Octet(__self_0), ConstType::Octet(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstType::Identifier(__self_0),
                            ConstType::Identifier(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ConstType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ConstType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (ConstType::Integer(__self_0), ConstType::Integer(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstType::FloatingPoint(__self_0),
                            ConstType::FloatingPoint(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (ConstType::Boolean(__self_0), ConstType::Boolean(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Byte(__self_0), ConstType::Byte(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (ConstType::Octet(__self_0), ConstType::Octet(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            ConstType::Identifier(__self_0),
                            ConstType::Identifier(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ConstType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                ConstType::Integer(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::FloatingPoint(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ConstType::Boolean(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::Byte(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::Octet(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                ConstType::Identifier(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    impl<'a> From<MayBeNull<IntegerType>> for ConstType<'a> {
        fn from(x: MayBeNull<IntegerType>) -> Self {
            ConstType::Integer(x)
        }
    }
    impl<'a> From<MayBeNull<FloatingPointType>> for ConstType<'a> {
        fn from(x: MayBeNull<FloatingPointType>) -> Self {
            ConstType::FloatingPoint(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Boolean>> for ConstType<'a> {
        fn from(x: MayBeNull<crate::term::Boolean>) -> Self {
            ConstType::Boolean(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Byte>> for ConstType<'a> {
        fn from(x: MayBeNull<crate::term::Byte>) -> Self {
            ConstType::Byte(x)
        }
    }
    impl<'a> From<MayBeNull<crate::term::Octet>> for ConstType<'a> {
        fn from(x: MayBeNull<crate::term::Octet>) -> Self {
            ConstType::Octet(x)
        }
    }
    impl<'a> From<MayBeNull<Identifier<'a>>> for ConstType<'a> {
        fn from(x: MayBeNull<Identifier<'a>>) -> Self {
            ConstType::Identifier(x)
        }
    }
    impl<'a> crate::Parse<'a> for ConstType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <MayBeNull<IntegerType> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <MayBeNull<FloatingPointType> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <MayBeNull<crate::term::Boolean> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <MayBeNull<crate::term::Byte> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::branch::alt((
                        nom::combinator::map(
                            <MayBeNull<crate::term::Octet> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::combinator::map(
                            <MayBeNull<Identifier<'a>> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                    )),
                )),
            ))(input)
        }
    }
    /// Parses the return type which may be `undefined` or any given Type
    pub enum ReturnType<'a> {
        Undefined(crate::term::Undefined),
        Type(Type<'a>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for ReturnType<'a> {
        #[inline]
        fn clone(&self) -> ReturnType<'a> {
            match self {
                ReturnType::Undefined(__self_0) => {
                    ReturnType::Undefined(::core::clone::Clone::clone(__self_0))
                }
                ReturnType::Type(__self_0) => {
                    ReturnType::Type(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ReturnType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ReturnType::Undefined(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Undefined",
                        &__self_0,
                    )
                }
                ReturnType::Type(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Type",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for ReturnType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for ReturnType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<crate::term::Undefined>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for ReturnType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for ReturnType<'a> {
        #[inline]
        fn eq(&self, other: &ReturnType<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        ReturnType::Undefined(__self_0),
                        ReturnType::Undefined(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (ReturnType::Type(__self_0), ReturnType::Type(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for ReturnType<'a> {
        #[inline]
        fn cmp(&self, other: &ReturnType<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            ReturnType::Undefined(__self_0),
                            ReturnType::Undefined(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (ReturnType::Type(__self_0), ReturnType::Type(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for ReturnType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ReturnType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            ReturnType::Undefined(__self_0),
                            ReturnType::Undefined(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (ReturnType::Type(__self_0), ReturnType::Type(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for ReturnType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                ReturnType::Undefined(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                ReturnType::Type(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    impl<'a> From<crate::term::Undefined> for ReturnType<'a> {
        fn from(x: crate::term::Undefined) -> Self {
            ReturnType::Undefined(x)
        }
    }
    impl<'a> From<Type<'a>> for ReturnType<'a> {
        fn from(x: Type<'a>) -> Self {
            ReturnType::Type(x)
        }
    }
    impl<'a> crate::Parse<'a> for ReturnType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            nom::branch::alt((
                nom::combinator::map(
                    <crate::term::Undefined as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(<Type<'a> as crate::Parse<'a>>::parse, From::from),
            ))(input)
        }
    }
    /// Parses `[attributes]? type`
    pub struct AttributedType<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub type_: Type<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributedType<'a> {
        #[inline]
        fn clone(&self) -> AttributedType<'a> {
            AttributedType {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                type_: ::core::clone::Clone::clone(&self.type_),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributedType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "AttributedType",
                "attributes",
                &&self.attributes,
                "type_",
                &&self.type_,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributedType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributedType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributedType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributedType<'a> {
        #[inline]
        fn eq(&self, other: &AttributedType<'a>) -> bool {
            self.attributes == other.attributes && self.type_ == other.type_
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributedType<'a> {
        #[inline]
        fn cmp(&self, other: &AttributedType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.type_, &other.type_)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributedType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributedType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.type_, &other.type_)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributedType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.type_, state)
        }
    }
    impl<'a> crate::Parse<'a> for AttributedType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <Type<'a> as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, type_)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { attributes, type_ }))
                            }
                        }
                    }
                }
            }
        }
    }
    /// Parses `[attributes]? type` where the type is a single non-any type
    pub struct AttributedNonAnyType<'a> {
        pub attributes: Option<ExtendedAttributeList<'a>>,
        pub type_: NonAnyType<'a>,
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for AttributedNonAnyType<'a> {
        #[inline]
        fn clone(&self) -> AttributedNonAnyType<'a> {
            AttributedNonAnyType {
                attributes: ::core::clone::Clone::clone(&self.attributes),
                type_: ::core::clone::Clone::clone(&self.type_),
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for AttributedNonAnyType<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "AttributedNonAnyType",
                "attributes",
                &&self.attributes,
                "type_",
                &&self.type_,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for AttributedNonAnyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for AttributedNonAnyType<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
            let _: ::core::cmp::AssertParamIsEq<NonAnyType<'a>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for AttributedNonAnyType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for AttributedNonAnyType<'a> {
        #[inline]
        fn eq(&self, other: &AttributedNonAnyType<'a>) -> bool {
            self.attributes == other.attributes && self.type_ == other.type_
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for AttributedNonAnyType<'a> {
        #[inline]
        fn cmp(&self, other: &AttributedNonAnyType<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.type_, &other.type_)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for AttributedNonAnyType<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &AttributedNonAnyType<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.attributes,
                &other.attributes,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.type_, &other.type_)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for AttributedNonAnyType<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.attributes, state);
            ::core::hash::Hash::hash(&self.type_, state)
        }
    }
    impl<'a> crate::Parse<'a> for AttributedNonAnyType<'a> {
        fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
            {
                use nom::lib::std::result::Result::*;
                match <Option<
                    ExtendedAttributeList<'a>,
                > as crate::Parse<'a>>::parse(input) {
                    Err(e) => Err(e),
                    Ok((i, attributes)) => {
                        use nom::lib::std::result::Result::*;
                        match <NonAnyType<'a> as crate::Parse<'a>>::parse(i) {
                            Err(e) => Err(e),
                            Ok((i, type_)) => {
                                use nom::lib::std::result::Result::Ok;
                                Ok((i, Self { attributes, type_ }))
                            }
                        }
                    }
                }
            }
        }
    }
}
pub mod lexer {
    use nom::{multi::many0, IResult};
    use crate::common::Identifier;
    use crate::literal::{FloatValueLit, IntegerLit, StringLit};
    use crate::whitespace::sp;
    use crate::Parse;
    pub mod keywords {
        ///ArrayBuffer
        pub struct ArrayBuffer<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for ArrayBuffer<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for ArrayBuffer<'a> {
            #[inline]
            fn clone(&self) -> ArrayBuffer<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for ArrayBuffer<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ArrayBuffer",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for ArrayBuffer<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for ArrayBuffer<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for ArrayBuffer<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for ArrayBuffer<'a> {
            #[inline]
            fn eq(&self, other: &ArrayBuffer<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for ArrayBuffer<'a> {
            #[inline]
            fn cmp(&self, other: &ArrayBuffer<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for ArrayBuffer<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ArrayBuffer<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for ArrayBuffer<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///DataView
        pub struct DataView<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for DataView<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for DataView<'a> {
            #[inline]
            fn clone(&self) -> DataView<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for DataView<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "DataView",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for DataView<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for DataView<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for DataView<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for DataView<'a> {
            #[inline]
            fn eq(&self, other: &DataView<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for DataView<'a> {
            #[inline]
            fn cmp(&self, other: &DataView<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for DataView<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &DataView<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for DataView<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Int8Array
        pub struct Int8Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Int8Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Int8Array<'a> {
            #[inline]
            fn clone(&self) -> Int8Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Int8Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Int8Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Int8Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Int8Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Int8Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Int8Array<'a> {
            #[inline]
            fn eq(&self, other: &Int8Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Int8Array<'a> {
            #[inline]
            fn cmp(&self, other: &Int8Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Int8Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Int8Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Int8Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Int16Array
        pub struct Int16Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Int16Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Int16Array<'a> {
            #[inline]
            fn clone(&self) -> Int16Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Int16Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Int16Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Int16Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Int16Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Int16Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Int16Array<'a> {
            #[inline]
            fn eq(&self, other: &Int16Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Int16Array<'a> {
            #[inline]
            fn cmp(&self, other: &Int16Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Int16Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Int16Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Int16Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Int32Array
        pub struct Int32Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Int32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Int32Array<'a> {
            #[inline]
            fn clone(&self) -> Int32Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Int32Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Int32Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Int32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Int32Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Int32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Int32Array<'a> {
            #[inline]
            fn eq(&self, other: &Int32Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Int32Array<'a> {
            #[inline]
            fn cmp(&self, other: &Int32Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Int32Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Int32Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Int32Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Uint8Array
        pub struct Uint8Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Uint8Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Uint8Array<'a> {
            #[inline]
            fn clone(&self) -> Uint8Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Uint8Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Uint8Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Uint8Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Uint8Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Uint8Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Uint8Array<'a> {
            #[inline]
            fn eq(&self, other: &Uint8Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Uint8Array<'a> {
            #[inline]
            fn cmp(&self, other: &Uint8Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Uint8Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Uint8Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Uint8Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Uint16Array
        pub struct Uint16Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Uint16Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Uint16Array<'a> {
            #[inline]
            fn clone(&self) -> Uint16Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Uint16Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Uint16Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Uint16Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Uint16Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Uint16Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Uint16Array<'a> {
            #[inline]
            fn eq(&self, other: &Uint16Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Uint16Array<'a> {
            #[inline]
            fn cmp(&self, other: &Uint16Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Uint16Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Uint16Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Uint16Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Uint32Array
        pub struct Uint32Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Uint32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Uint32Array<'a> {
            #[inline]
            fn clone(&self) -> Uint32Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Uint32Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Uint32Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Uint32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Uint32Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Uint32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Uint32Array<'a> {
            #[inline]
            fn eq(&self, other: &Uint32Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Uint32Array<'a> {
            #[inline]
            fn cmp(&self, other: &Uint32Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Uint32Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Uint32Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Uint32Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Uint8ClampedArray
        pub struct Uint8ClampedArray<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Uint8ClampedArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Uint8ClampedArray<'a> {
            #[inline]
            fn clone(&self) -> Uint8ClampedArray<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Uint8ClampedArray<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Uint8ClampedArray",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Uint8ClampedArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Uint8ClampedArray<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Uint8ClampedArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Uint8ClampedArray<'a> {
            #[inline]
            fn eq(&self, other: &Uint8ClampedArray<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Uint8ClampedArray<'a> {
            #[inline]
            fn cmp(&self, other: &Uint8ClampedArray<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Uint8ClampedArray<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Uint8ClampedArray<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Uint8ClampedArray<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///BigInt64Array
        pub struct BigInt64Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for BigInt64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for BigInt64Array<'a> {
            #[inline]
            fn clone(&self) -> BigInt64Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for BigInt64Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "BigInt64Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for BigInt64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for BigInt64Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for BigInt64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for BigInt64Array<'a> {
            #[inline]
            fn eq(&self, other: &BigInt64Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for BigInt64Array<'a> {
            #[inline]
            fn cmp(&self, other: &BigInt64Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for BigInt64Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &BigInt64Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for BigInt64Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///BigUint64Array
        pub struct BigUint64Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for BigUint64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for BigUint64Array<'a> {
            #[inline]
            fn clone(&self) -> BigUint64Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for BigUint64Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "BigUint64Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for BigUint64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for BigUint64Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for BigUint64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for BigUint64Array<'a> {
            #[inline]
            fn eq(&self, other: &BigUint64Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for BigUint64Array<'a> {
            #[inline]
            fn cmp(&self, other: &BigUint64Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for BigUint64Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &BigUint64Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for BigUint64Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Float32Array
        pub struct Float32Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Float32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Float32Array<'a> {
            #[inline]
            fn clone(&self) -> Float32Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Float32Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Float32Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Float32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Float32Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Float32Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Float32Array<'a> {
            #[inline]
            fn eq(&self, other: &Float32Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Float32Array<'a> {
            #[inline]
            fn cmp(&self, other: &Float32Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Float32Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Float32Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Float32Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Float64Array
        pub struct Float64Array<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Float64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Float64Array<'a> {
            #[inline]
            fn clone(&self) -> Float64Array<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Float64Array<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Float64Array",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Float64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Float64Array<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Float64Array<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Float64Array<'a> {
            #[inline]
            fn eq(&self, other: &Float64Array<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Float64Array<'a> {
            #[inline]
            fn cmp(&self, other: &Float64Array<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Float64Array<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Float64Array<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Float64Array<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///any
        pub struct Any<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Any<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Any<'a> {
            #[inline]
            fn clone(&self) -> Any<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Any<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Any", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Any<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Any<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Any<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Any<'a> {
            #[inline]
            fn eq(&self, other: &Any<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Any<'a> {
            #[inline]
            fn cmp(&self, other: &Any<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Any<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Any<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Any<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///object
        pub struct Object<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Object<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Object<'a> {
            #[inline]
            fn clone(&self) -> Object<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Object<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Object", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Object<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Object<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Object<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Object<'a> {
            #[inline]
            fn eq(&self, other: &Object<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Object<'a> {
            #[inline]
            fn cmp(&self, other: &Object<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Object<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Object<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Object<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///symbol
        pub struct Symbol<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Symbol<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Symbol<'a> {
            #[inline]
            fn clone(&self) -> Symbol<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Symbol<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Symbol", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Symbol<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Symbol<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Symbol<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Symbol<'a> {
            #[inline]
            fn eq(&self, other: &Symbol<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Symbol<'a> {
            #[inline]
            fn cmp(&self, other: &Symbol<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Symbol<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Symbol<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Symbol<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///ByteString
        pub struct ByteString<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for ByteString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for ByteString<'a> {
            #[inline]
            fn clone(&self) -> ByteString<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for ByteString<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ByteString",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for ByteString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for ByteString<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for ByteString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for ByteString<'a> {
            #[inline]
            fn eq(&self, other: &ByteString<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for ByteString<'a> {
            #[inline]
            fn cmp(&self, other: &ByteString<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for ByteString<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ByteString<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for ByteString<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///DOMString
        pub struct DOMString<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for DOMString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for DOMString<'a> {
            #[inline]
            fn clone(&self) -> DOMString<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for DOMString<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "DOMString",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for DOMString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for DOMString<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for DOMString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for DOMString<'a> {
            #[inline]
            fn eq(&self, other: &DOMString<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for DOMString<'a> {
            #[inline]
            fn cmp(&self, other: &DOMString<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for DOMString<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &DOMString<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for DOMString<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///USVString
        pub struct USVString<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for USVString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for USVString<'a> {
            #[inline]
            fn clone(&self) -> USVString<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for USVString<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "USVString",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for USVString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for USVString<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for USVString<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for USVString<'a> {
            #[inline]
            fn eq(&self, other: &USVString<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for USVString<'a> {
            #[inline]
            fn cmp(&self, other: &USVString<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for USVString<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &USVString<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for USVString<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///async
        pub struct Async<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Async<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Async<'a> {
            #[inline]
            fn clone(&self) -> Async<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Async<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Async", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Async<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Async<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Async<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Async<'a> {
            #[inline]
            fn eq(&self, other: &Async<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Async<'a> {
            #[inline]
            fn cmp(&self, other: &Async<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Async<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Async<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Async<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///attribute
        pub struct Attribute<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Attribute<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Attribute<'a> {
            #[inline]
            fn clone(&self) -> Attribute<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Attribute<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Attribute",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Attribute<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Attribute<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Attribute<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Attribute<'a> {
            #[inline]
            fn eq(&self, other: &Attribute<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Attribute<'a> {
            #[inline]
            fn cmp(&self, other: &Attribute<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Attribute<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Attribute<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Attribute<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///callback
        pub struct Callback<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Callback<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Callback<'a> {
            #[inline]
            fn clone(&self) -> Callback<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Callback<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Callback",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Callback<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Callback<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Callback<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Callback<'a> {
            #[inline]
            fn eq(&self, other: &Callback<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Callback<'a> {
            #[inline]
            fn cmp(&self, other: &Callback<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Callback<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Callback<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Callback<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///constructor
        pub struct Constructor<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Constructor<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Constructor<'a> {
            #[inline]
            fn clone(&self) -> Constructor<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Constructor<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Constructor",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Constructor<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Constructor<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Constructor<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Constructor<'a> {
            #[inline]
            fn eq(&self, other: &Constructor<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Constructor<'a> {
            #[inline]
            fn cmp(&self, other: &Constructor<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Constructor<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Constructor<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Constructor<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///deleter
        pub struct Deleter<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Deleter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Deleter<'a> {
            #[inline]
            fn clone(&self) -> Deleter<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Deleter<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Deleter", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Deleter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Deleter<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Deleter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Deleter<'a> {
            #[inline]
            fn eq(&self, other: &Deleter<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Deleter<'a> {
            #[inline]
            fn cmp(&self, other: &Deleter<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Deleter<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Deleter<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Deleter<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///dictionary
        pub struct Dictionary<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Dictionary<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Dictionary<'a> {
            #[inline]
            fn clone(&self) -> Dictionary<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Dictionary<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Dictionary",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Dictionary<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Dictionary<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Dictionary<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Dictionary<'a> {
            #[inline]
            fn eq(&self, other: &Dictionary<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Dictionary<'a> {
            #[inline]
            fn cmp(&self, other: &Dictionary<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Dictionary<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Dictionary<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Dictionary<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///enum
        pub struct Enum<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Enum<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Enum<'a> {
            #[inline]
            fn clone(&self) -> Enum<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Enum<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Enum", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Enum<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Enum<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Enum<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Enum<'a> {
            #[inline]
            fn eq(&self, other: &Enum<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Enum<'a> {
            #[inline]
            fn cmp(&self, other: &Enum<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Enum<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Enum<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Enum<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///getter
        pub struct Getter<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Getter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Getter<'a> {
            #[inline]
            fn clone(&self) -> Getter<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Getter<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Getter", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Getter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Getter<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Getter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Getter<'a> {
            #[inline]
            fn eq(&self, other: &Getter<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Getter<'a> {
            #[inline]
            fn cmp(&self, other: &Getter<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Getter<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Getter<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Getter<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///includes
        pub struct Includes<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Includes<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Includes<'a> {
            #[inline]
            fn clone(&self) -> Includes<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Includes<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Includes",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Includes<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Includes<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Includes<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Includes<'a> {
            #[inline]
            fn eq(&self, other: &Includes<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Includes<'a> {
            #[inline]
            fn cmp(&self, other: &Includes<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Includes<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Includes<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Includes<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///inherit
        pub struct Inherit<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Inherit<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Inherit<'a> {
            #[inline]
            fn clone(&self) -> Inherit<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Inherit<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Inherit", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Inherit<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Inherit<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Inherit<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Inherit<'a> {
            #[inline]
            fn eq(&self, other: &Inherit<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Inherit<'a> {
            #[inline]
            fn cmp(&self, other: &Inherit<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Inherit<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Inherit<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Inherit<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///interface
        pub struct Interface<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Interface<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Interface<'a> {
            #[inline]
            fn clone(&self) -> Interface<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Interface<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Interface",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Interface<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Interface<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Interface<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Interface<'a> {
            #[inline]
            fn eq(&self, other: &Interface<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Interface<'a> {
            #[inline]
            fn cmp(&self, other: &Interface<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Interface<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Interface<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Interface<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///iterable
        pub struct Iterable<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Iterable<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Iterable<'a> {
            #[inline]
            fn clone(&self) -> Iterable<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Iterable<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Iterable",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Iterable<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Iterable<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Iterable<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Iterable<'a> {
            #[inline]
            fn eq(&self, other: &Iterable<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Iterable<'a> {
            #[inline]
            fn cmp(&self, other: &Iterable<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Iterable<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Iterable<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Iterable<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///maplike
        pub struct Maplike<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Maplike<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Maplike<'a> {
            #[inline]
            fn clone(&self) -> Maplike<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Maplike<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Maplike", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Maplike<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Maplike<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Maplike<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Maplike<'a> {
            #[inline]
            fn eq(&self, other: &Maplike<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Maplike<'a> {
            #[inline]
            fn cmp(&self, other: &Maplike<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Maplike<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Maplike<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Maplike<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///namespace
        pub struct Namespace<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Namespace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Namespace<'a> {
            #[inline]
            fn clone(&self) -> Namespace<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Namespace<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Namespace",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Namespace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Namespace<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Namespace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Namespace<'a> {
            #[inline]
            fn eq(&self, other: &Namespace<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Namespace<'a> {
            #[inline]
            fn cmp(&self, other: &Namespace<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Namespace<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Namespace<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Namespace<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///partial
        pub struct Partial<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Partial<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Partial<'a> {
            #[inline]
            fn clone(&self) -> Partial<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Partial<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Partial", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Partial<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Partial<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Partial<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Partial<'a> {
            #[inline]
            fn eq(&self, other: &Partial<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Partial<'a> {
            #[inline]
            fn cmp(&self, other: &Partial<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Partial<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Partial<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Partial<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///required
        pub struct Required<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Required<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Required<'a> {
            #[inline]
            fn clone(&self) -> Required<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Required<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Required",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Required<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Required<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Required<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Required<'a> {
            #[inline]
            fn eq(&self, other: &Required<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Required<'a> {
            #[inline]
            fn cmp(&self, other: &Required<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Required<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Required<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Required<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///setlike
        pub struct Setlike<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Setlike<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Setlike<'a> {
            #[inline]
            fn clone(&self) -> Setlike<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Setlike<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Setlike", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Setlike<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Setlike<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Setlike<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Setlike<'a> {
            #[inline]
            fn eq(&self, other: &Setlike<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Setlike<'a> {
            #[inline]
            fn cmp(&self, other: &Setlike<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Setlike<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Setlike<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Setlike<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///setter
        pub struct Setter<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Setter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Setter<'a> {
            #[inline]
            fn clone(&self) -> Setter<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Setter<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Setter", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Setter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Setter<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Setter<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Setter<'a> {
            #[inline]
            fn eq(&self, other: &Setter<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Setter<'a> {
            #[inline]
            fn cmp(&self, other: &Setter<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Setter<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Setter<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Setter<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///static
        pub struct Static<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Static<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Static<'a> {
            #[inline]
            fn clone(&self) -> Static<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Static<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Static", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Static<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Static<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Static<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Static<'a> {
            #[inline]
            fn eq(&self, other: &Static<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Static<'a> {
            #[inline]
            fn cmp(&self, other: &Static<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Static<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Static<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Static<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///stringifier
        pub struct Stringifier<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Stringifier<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Stringifier<'a> {
            #[inline]
            fn clone(&self) -> Stringifier<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Stringifier<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Stringifier",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Stringifier<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Stringifier<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Stringifier<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Stringifier<'a> {
            #[inline]
            fn eq(&self, other: &Stringifier<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Stringifier<'a> {
            #[inline]
            fn cmp(&self, other: &Stringifier<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Stringifier<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Stringifier<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Stringifier<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///typedef
        pub struct Typedef<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Typedef<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Typedef<'a> {
            #[inline]
            fn clone(&self) -> Typedef<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Typedef<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Typedef", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Typedef<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Typedef<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Typedef<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Typedef<'a> {
            #[inline]
            fn eq(&self, other: &Typedef<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Typedef<'a> {
            #[inline]
            fn cmp(&self, other: &Typedef<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Typedef<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Typedef<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Typedef<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///unrestricted
        pub struct Unrestricted<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Unrestricted<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Unrestricted<'a> {
            #[inline]
            fn clone(&self) -> Unrestricted<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Unrestricted<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Unrestricted",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Unrestricted<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Unrestricted<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Unrestricted<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Unrestricted<'a> {
            #[inline]
            fn eq(&self, other: &Unrestricted<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Unrestricted<'a> {
            #[inline]
            fn cmp(&self, other: &Unrestricted<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Unrestricted<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Unrestricted<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Unrestricted<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///or
        pub struct Or<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Or<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Or<'a> {
            #[inline]
            fn clone(&self) -> Or<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Or<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Or", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Or<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Or<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Or<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Or<'a> {
            #[inline]
            fn eq(&self, other: &Or<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Or<'a> {
            #[inline]
            fn cmp(&self, other: &Or<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Or<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Or<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Or<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///optional
        pub struct Optional<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Optional<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Optional<'a> {
            #[inline]
            fn clone(&self) -> Optional<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Optional<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Optional",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Optional<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Optional<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Optional<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Optional<'a> {
            #[inline]
            fn eq(&self, other: &Optional<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Optional<'a> {
            #[inline]
            fn cmp(&self, other: &Optional<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Optional<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Optional<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Optional<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///const
        pub struct Const<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Const<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Const<'a> {
            #[inline]
            fn clone(&self) -> Const<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Const<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Const", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Const<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Const<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Const<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Const<'a> {
            #[inline]
            fn eq(&self, other: &Const<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Const<'a> {
            #[inline]
            fn cmp(&self, other: &Const<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Const<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Const<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Const<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///-Infinity
        pub struct NegInfinity<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for NegInfinity<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for NegInfinity<'a> {
            #[inline]
            fn clone(&self) -> NegInfinity<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for NegInfinity<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "NegInfinity",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for NegInfinity<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for NegInfinity<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for NegInfinity<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for NegInfinity<'a> {
            #[inline]
            fn eq(&self, other: &NegInfinity<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for NegInfinity<'a> {
            #[inline]
            fn cmp(&self, other: &NegInfinity<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for NegInfinity<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &NegInfinity<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for NegInfinity<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///FrozenArray
        pub struct FrozenArray<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for FrozenArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for FrozenArray<'a> {
            #[inline]
            fn clone(&self) -> FrozenArray<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for FrozenArray<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "FrozenArray",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for FrozenArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for FrozenArray<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for FrozenArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for FrozenArray<'a> {
            #[inline]
            fn eq(&self, other: &FrozenArray<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for FrozenArray<'a> {
            #[inline]
            fn cmp(&self, other: &FrozenArray<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for FrozenArray<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &FrozenArray<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for FrozenArray<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Infinity
        pub struct Infinity<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Infinity<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Infinity<'a> {
            #[inline]
            fn clone(&self) -> Infinity<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Infinity<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Infinity",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Infinity<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Infinity<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Infinity<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Infinity<'a> {
            #[inline]
            fn eq(&self, other: &Infinity<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Infinity<'a> {
            #[inline]
            fn cmp(&self, other: &Infinity<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Infinity<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Infinity<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Infinity<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///NaN
        pub struct NaN<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for NaN<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for NaN<'a> {
            #[inline]
            fn clone(&self) -> NaN<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for NaN<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "NaN", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for NaN<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for NaN<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for NaN<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for NaN<'a> {
            #[inline]
            fn eq(&self, other: &NaN<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for NaN<'a> {
            #[inline]
            fn cmp(&self, other: &NaN<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for NaN<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &NaN<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for NaN<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///ObservableArray
        pub struct ObservableArray<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for ObservableArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for ObservableArray<'a> {
            #[inline]
            fn clone(&self) -> ObservableArray<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for ObservableArray<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ObservableArray",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for ObservableArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for ObservableArray<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for ObservableArray<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for ObservableArray<'a> {
            #[inline]
            fn eq(&self, other: &ObservableArray<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for ObservableArray<'a> {
            #[inline]
            fn cmp(&self, other: &ObservableArray<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for ObservableArray<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ObservableArray<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for ObservableArray<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///bigint
        pub struct Bigint<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Bigint<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Bigint<'a> {
            #[inline]
            fn clone(&self) -> Bigint<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Bigint<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Bigint", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Bigint<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Bigint<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Bigint<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Bigint<'a> {
            #[inline]
            fn eq(&self, other: &Bigint<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Bigint<'a> {
            #[inline]
            fn cmp(&self, other: &Bigint<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Bigint<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Bigint<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Bigint<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///boolean
        pub struct Boolean<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Boolean<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Boolean<'a> {
            #[inline]
            fn clone(&self) -> Boolean<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Boolean<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Boolean", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Boolean<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Boolean<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Boolean<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Boolean<'a> {
            #[inline]
            fn eq(&self, other: &Boolean<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Boolean<'a> {
            #[inline]
            fn cmp(&self, other: &Boolean<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Boolean<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Boolean<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Boolean<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///byte
        pub struct Byte<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Byte<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Byte<'a> {
            #[inline]
            fn clone(&self) -> Byte<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Byte<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Byte", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Byte<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Byte<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Byte<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Byte<'a> {
            #[inline]
            fn eq(&self, other: &Byte<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Byte<'a> {
            #[inline]
            fn cmp(&self, other: &Byte<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Byte<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Byte<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Byte<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///double
        pub struct Double<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Double<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Double<'a> {
            #[inline]
            fn clone(&self) -> Double<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Double<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Double", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Double<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Double<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Double<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Double<'a> {
            #[inline]
            fn eq(&self, other: &Double<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Double<'a> {
            #[inline]
            fn cmp(&self, other: &Double<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Double<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Double<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Double<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///false
        pub struct False<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for False<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for False<'a> {
            #[inline]
            fn clone(&self) -> False<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for False<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "False", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for False<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for False<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for False<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for False<'a> {
            #[inline]
            fn eq(&self, other: &False<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for False<'a> {
            #[inline]
            fn cmp(&self, other: &False<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for False<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &False<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for False<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///float
        pub struct Float<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Float<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Float<'a> {
            #[inline]
            fn clone(&self) -> Float<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Float<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Float", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Float<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Float<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Float<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Float<'a> {
            #[inline]
            fn eq(&self, other: &Float<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Float<'a> {
            #[inline]
            fn cmp(&self, other: &Float<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Float<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Float<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Float<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///long
        pub struct Long<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Long<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Long<'a> {
            #[inline]
            fn clone(&self) -> Long<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Long<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Long", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Long<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Long<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Long<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Long<'a> {
            #[inline]
            fn eq(&self, other: &Long<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Long<'a> {
            #[inline]
            fn cmp(&self, other: &Long<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Long<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Long<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Long<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///null
        pub struct Null<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Null<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Null<'a> {
            #[inline]
            fn clone(&self) -> Null<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Null<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Null", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Null<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Null<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Null<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Null<'a> {
            #[inline]
            fn eq(&self, other: &Null<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Null<'a> {
            #[inline]
            fn cmp(&self, other: &Null<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Null<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Null<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Null<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///octet
        pub struct Octet<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Octet<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Octet<'a> {
            #[inline]
            fn clone(&self) -> Octet<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Octet<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Octet", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Octet<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Octet<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Octet<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Octet<'a> {
            #[inline]
            fn eq(&self, other: &Octet<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Octet<'a> {
            #[inline]
            fn cmp(&self, other: &Octet<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Octet<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Octet<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Octet<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///sequence
        pub struct Sequence<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Sequence<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Sequence<'a> {
            #[inline]
            fn clone(&self) -> Sequence<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Sequence<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Sequence",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Sequence<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Sequence<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Sequence<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Sequence<'a> {
            #[inline]
            fn eq(&self, other: &Sequence<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Sequence<'a> {
            #[inline]
            fn cmp(&self, other: &Sequence<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Sequence<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Sequence<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Sequence<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///short
        pub struct Short<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Short<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Short<'a> {
            #[inline]
            fn clone(&self) -> Short<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Short<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Short", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Short<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Short<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Short<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Short<'a> {
            #[inline]
            fn eq(&self, other: &Short<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Short<'a> {
            #[inline]
            fn cmp(&self, other: &Short<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Short<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Short<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Short<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///true
        pub struct True<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for True<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for True<'a> {
            #[inline]
            fn clone(&self) -> True<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for True<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "True", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for True<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for True<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for True<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for True<'a> {
            #[inline]
            fn eq(&self, other: &True<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for True<'a> {
            #[inline]
            fn cmp(&self, other: &True<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for True<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &True<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for True<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///unsigned
        pub struct Unsigned<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Unsigned<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Unsigned<'a> {
            #[inline]
            fn clone(&self) -> Unsigned<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Unsigned<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Unsigned",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Unsigned<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Unsigned<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Unsigned<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Unsigned<'a> {
            #[inline]
            fn eq(&self, other: &Unsigned<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Unsigned<'a> {
            #[inline]
            fn cmp(&self, other: &Unsigned<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Unsigned<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Unsigned<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Unsigned<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///undefined
        pub struct Undefined<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Undefined<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Undefined<'a> {
            #[inline]
            fn clone(&self) -> Undefined<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Undefined<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Undefined",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Undefined<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Undefined<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Undefined<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Undefined<'a> {
            #[inline]
            fn eq(&self, other: &Undefined<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Undefined<'a> {
            #[inline]
            fn cmp(&self, other: &Undefined<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Undefined<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Undefined<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Undefined<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///record
        pub struct Record<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Record<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Record<'a> {
            #[inline]
            fn clone(&self) -> Record<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Record<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Record", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Record<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Record<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Record<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Record<'a> {
            #[inline]
            fn eq(&self, other: &Record<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Record<'a> {
            #[inline]
            fn cmp(&self, other: &Record<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Record<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Record<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Record<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///Promise
        pub struct Promise<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Promise<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Promise<'a> {
            #[inline]
            fn clone(&self) -> Promise<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Promise<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Promise", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Promise<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Promise<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Promise<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Promise<'a> {
            #[inline]
            fn eq(&self, other: &Promise<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Promise<'a> {
            #[inline]
            fn cmp(&self, other: &Promise<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Promise<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Promise<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Promise<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///readonly
        pub struct ReadOnly<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for ReadOnly<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for ReadOnly<'a> {
            #[inline]
            fn clone(&self) -> ReadOnly<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for ReadOnly<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ReadOnly",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for ReadOnly<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for ReadOnly<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for ReadOnly<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for ReadOnly<'a> {
            #[inline]
            fn eq(&self, other: &ReadOnly<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for ReadOnly<'a> {
            #[inline]
            fn cmp(&self, other: &ReadOnly<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for ReadOnly<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ReadOnly<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for ReadOnly<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///mixin
        pub struct Mixin<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Mixin<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Mixin<'a> {
            #[inline]
            fn clone(&self) -> Mixin<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Mixin<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Mixin", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Mixin<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Mixin<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Mixin<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Mixin<'a> {
            #[inline]
            fn eq(&self, other: &Mixin<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Mixin<'a> {
            #[inline]
            fn cmp(&self, other: &Mixin<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Mixin<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Mixin<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Mixin<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///(
        pub struct OpenParen<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for OpenParen<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for OpenParen<'a> {
            #[inline]
            fn clone(&self) -> OpenParen<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for OpenParen<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "OpenParen",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for OpenParen<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for OpenParen<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for OpenParen<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for OpenParen<'a> {
            #[inline]
            fn eq(&self, other: &OpenParen<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for OpenParen<'a> {
            #[inline]
            fn cmp(&self, other: &OpenParen<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for OpenParen<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &OpenParen<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for OpenParen<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///)
        pub struct CloseParen<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for CloseParen<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for CloseParen<'a> {
            #[inline]
            fn clone(&self) -> CloseParen<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for CloseParen<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CloseParen",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for CloseParen<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for CloseParen<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for CloseParen<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for CloseParen<'a> {
            #[inline]
            fn eq(&self, other: &CloseParen<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for CloseParen<'a> {
            #[inline]
            fn cmp(&self, other: &CloseParen<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for CloseParen<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CloseParen<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for CloseParen<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///[
        pub struct OpenBracket<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for OpenBracket<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for OpenBracket<'a> {
            #[inline]
            fn clone(&self) -> OpenBracket<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for OpenBracket<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "OpenBracket",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for OpenBracket<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for OpenBracket<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for OpenBracket<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for OpenBracket<'a> {
            #[inline]
            fn eq(&self, other: &OpenBracket<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for OpenBracket<'a> {
            #[inline]
            fn cmp(&self, other: &OpenBracket<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for OpenBracket<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &OpenBracket<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for OpenBracket<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///]
        pub struct CloseBracket<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for CloseBracket<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for CloseBracket<'a> {
            #[inline]
            fn clone(&self) -> CloseBracket<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for CloseBracket<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CloseBracket",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for CloseBracket<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for CloseBracket<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for CloseBracket<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for CloseBracket<'a> {
            #[inline]
            fn eq(&self, other: &CloseBracket<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for CloseBracket<'a> {
            #[inline]
            fn cmp(&self, other: &CloseBracket<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for CloseBracket<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CloseBracket<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for CloseBracket<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///{
        pub struct OpenBrace<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for OpenBrace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for OpenBrace<'a> {
            #[inline]
            fn clone(&self) -> OpenBrace<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for OpenBrace<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "OpenBrace",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for OpenBrace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for OpenBrace<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for OpenBrace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for OpenBrace<'a> {
            #[inline]
            fn eq(&self, other: &OpenBrace<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for OpenBrace<'a> {
            #[inline]
            fn cmp(&self, other: &OpenBrace<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for OpenBrace<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &OpenBrace<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for OpenBrace<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///}
        pub struct CloseBrace<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for CloseBrace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for CloseBrace<'a> {
            #[inline]
            fn clone(&self) -> CloseBrace<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for CloseBrace<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CloseBrace",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for CloseBrace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for CloseBrace<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for CloseBrace<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for CloseBrace<'a> {
            #[inline]
            fn eq(&self, other: &CloseBrace<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for CloseBrace<'a> {
            #[inline]
            fn cmp(&self, other: &CloseBrace<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for CloseBrace<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CloseBrace<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for CloseBrace<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///,
        pub struct Comma<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Comma<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Comma<'a> {
            #[inline]
            fn clone(&self) -> Comma<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Comma<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Comma", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Comma<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Comma<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Comma<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Comma<'a> {
            #[inline]
            fn eq(&self, other: &Comma<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Comma<'a> {
            #[inline]
            fn cmp(&self, other: &Comma<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Comma<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Comma<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Comma<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///-
        pub struct Minus<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Minus<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Minus<'a> {
            #[inline]
            fn clone(&self) -> Minus<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Minus<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Minus", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Minus<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Minus<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Minus<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Minus<'a> {
            #[inline]
            fn eq(&self, other: &Minus<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Minus<'a> {
            #[inline]
            fn cmp(&self, other: &Minus<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Minus<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Minus<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Minus<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///.
        pub struct Dot<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Dot<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Dot<'a> {
            #[inline]
            fn clone(&self) -> Dot<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Dot<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Dot", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Dot<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Dot<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Dot<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Dot<'a> {
            #[inline]
            fn eq(&self, other: &Dot<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Dot<'a> {
            #[inline]
            fn cmp(&self, other: &Dot<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Dot<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Dot<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Dot<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///...
        pub struct Ellipsis<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Ellipsis<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Ellipsis<'a> {
            #[inline]
            fn clone(&self) -> Ellipsis<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Ellipsis<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Ellipsis",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Ellipsis<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Ellipsis<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Ellipsis<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Ellipsis<'a> {
            #[inline]
            fn eq(&self, other: &Ellipsis<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Ellipsis<'a> {
            #[inline]
            fn cmp(&self, other: &Ellipsis<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Ellipsis<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Ellipsis<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Ellipsis<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///:
        pub struct Colon<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Colon<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Colon<'a> {
            #[inline]
            fn clone(&self) -> Colon<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Colon<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Colon", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Colon<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Colon<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Colon<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Colon<'a> {
            #[inline]
            fn eq(&self, other: &Colon<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Colon<'a> {
            #[inline]
            fn cmp(&self, other: &Colon<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Colon<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Colon<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Colon<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///;
        pub struct SemiColon<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for SemiColon<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for SemiColon<'a> {
            #[inline]
            fn clone(&self) -> SemiColon<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for SemiColon<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "SemiColon",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for SemiColon<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for SemiColon<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for SemiColon<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for SemiColon<'a> {
            #[inline]
            fn eq(&self, other: &SemiColon<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for SemiColon<'a> {
            #[inline]
            fn cmp(&self, other: &SemiColon<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for SemiColon<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &SemiColon<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for SemiColon<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///<
        pub struct LessThan<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for LessThan<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for LessThan<'a> {
            #[inline]
            fn clone(&self) -> LessThan<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for LessThan<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "LessThan",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for LessThan<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for LessThan<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for LessThan<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for LessThan<'a> {
            #[inline]
            fn eq(&self, other: &LessThan<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for LessThan<'a> {
            #[inline]
            fn cmp(&self, other: &LessThan<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for LessThan<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &LessThan<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for LessThan<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///=
        pub struct Assign<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Assign<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Assign<'a> {
            #[inline]
            fn clone(&self) -> Assign<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Assign<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Assign", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Assign<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Assign<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Assign<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Assign<'a> {
            #[inline]
            fn eq(&self, other: &Assign<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Assign<'a> {
            #[inline]
            fn cmp(&self, other: &Assign<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Assign<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Assign<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Assign<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///>
        pub struct GreaterThan<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for GreaterThan<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for GreaterThan<'a> {
            #[inline]
            fn clone(&self) -> GreaterThan<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for GreaterThan<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GreaterThan",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for GreaterThan<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for GreaterThan<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for GreaterThan<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for GreaterThan<'a> {
            #[inline]
            fn eq(&self, other: &GreaterThan<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for GreaterThan<'a> {
            #[inline]
            fn cmp(&self, other: &GreaterThan<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for GreaterThan<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &GreaterThan<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for GreaterThan<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///?
        pub struct QuestionMark<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for QuestionMark<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for QuestionMark<'a> {
            #[inline]
            fn clone(&self) -> QuestionMark<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for QuestionMark<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "QuestionMark",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for QuestionMark<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for QuestionMark<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for QuestionMark<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for QuestionMark<'a> {
            #[inline]
            fn eq(&self, other: &QuestionMark<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for QuestionMark<'a> {
            #[inline]
            fn cmp(&self, other: &QuestionMark<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for QuestionMark<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &QuestionMark<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for QuestionMark<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        ///*
        pub struct Wildcard<'a>(pub &'a str);
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Wildcard<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Wildcard<'a> {
            #[inline]
            fn clone(&self) -> Wildcard<'a> {
                let _: ::core::clone::AssertParamIsClone<&'a str>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Wildcard<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Wildcard",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Wildcard<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Wildcard<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Wildcard<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Wildcard<'a> {
            #[inline]
            fn eq(&self, other: &Wildcard<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Wildcard<'a> {
            #[inline]
            fn cmp(&self, other: &Wildcard<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Wildcard<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Wildcard<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Wildcard<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        pub enum Keyword<'a> {
            ///ArrayBuffer
            ArrayBuffer(ArrayBuffer<'a>),
            ///DataView
            DataView(DataView<'a>),
            ///Int8Array
            Int8Array(Int8Array<'a>),
            ///Int16Array
            Int16Array(Int16Array<'a>),
            ///Int32Array
            Int32Array(Int32Array<'a>),
            ///Uint8Array
            Uint8Array(Uint8Array<'a>),
            ///Uint16Array
            Uint16Array(Uint16Array<'a>),
            ///Uint32Array
            Uint32Array(Uint32Array<'a>),
            ///Uint8ClampedArray
            Uint8ClampedArray(Uint8ClampedArray<'a>),
            ///BigInt64Array
            BigInt64Array(BigInt64Array<'a>),
            ///BigUint64Array
            BigUint64Array(BigUint64Array<'a>),
            ///Float32Array
            Float32Array(Float32Array<'a>),
            ///Float64Array
            Float64Array(Float64Array<'a>),
            ///any
            Any(Any<'a>),
            ///object
            Object(Object<'a>),
            ///symbol
            Symbol(Symbol<'a>),
            ///ByteString
            ByteString(ByteString<'a>),
            ///DOMString
            DOMString(DOMString<'a>),
            ///USVString
            USVString(USVString<'a>),
            ///async
            Async(Async<'a>),
            ///attribute
            Attribute(Attribute<'a>),
            ///callback
            Callback(Callback<'a>),
            ///constructor
            Constructor(Constructor<'a>),
            ///deleter
            Deleter(Deleter<'a>),
            ///dictionary
            Dictionary(Dictionary<'a>),
            ///enum
            Enum(Enum<'a>),
            ///getter
            Getter(Getter<'a>),
            ///includes
            Includes(Includes<'a>),
            ///inherit
            Inherit(Inherit<'a>),
            ///interface
            Interface(Interface<'a>),
            ///iterable
            Iterable(Iterable<'a>),
            ///maplike
            Maplike(Maplike<'a>),
            ///namespace
            Namespace(Namespace<'a>),
            ///partial
            Partial(Partial<'a>),
            ///required
            Required(Required<'a>),
            ///setlike
            Setlike(Setlike<'a>),
            ///setter
            Setter(Setter<'a>),
            ///static
            Static(Static<'a>),
            ///stringifier
            Stringifier(Stringifier<'a>),
            ///typedef
            Typedef(Typedef<'a>),
            ///unrestricted
            Unrestricted(Unrestricted<'a>),
            ///or
            Or(Or<'a>),
            ///optional
            Optional(Optional<'a>),
            ///const
            Const(Const<'a>),
            ///-Infinity
            NegInfinity(NegInfinity<'a>),
            ///FrozenArray
            FrozenArray(FrozenArray<'a>),
            ///Infinity
            Infinity(Infinity<'a>),
            ///NaN
            NaN(NaN<'a>),
            ///ObservableArray
            ObservableArray(ObservableArray<'a>),
            ///bigint
            Bigint(Bigint<'a>),
            ///boolean
            Boolean(Boolean<'a>),
            ///byte
            Byte(Byte<'a>),
            ///double
            Double(Double<'a>),
            ///false
            False(False<'a>),
            ///float
            Float(Float<'a>),
            ///long
            Long(Long<'a>),
            ///null
            Null(Null<'a>),
            ///octet
            Octet(Octet<'a>),
            ///sequence
            Sequence(Sequence<'a>),
            ///short
            Short(Short<'a>),
            ///true
            True(True<'a>),
            ///unsigned
            Unsigned(Unsigned<'a>),
            ///undefined
            Undefined(Undefined<'a>),
            ///record
            Record(Record<'a>),
            ///Promise
            Promise(Promise<'a>),
            ///readonly
            ReadOnly(ReadOnly<'a>),
            ///mixin
            Mixin(Mixin<'a>),
            ///(
            OpenParen(OpenParen<'a>),
            ///)
            CloseParen(CloseParen<'a>),
            ///[
            OpenBracket(OpenBracket<'a>),
            ///]
            CloseBracket(CloseBracket<'a>),
            ///{
            OpenBrace(OpenBrace<'a>),
            ///}
            CloseBrace(CloseBrace<'a>),
            ///,
            Comma(Comma<'a>),
            ///-
            Minus(Minus<'a>),
            ///.
            Dot(Dot<'a>),
            ///...
            Ellipsis(Ellipsis<'a>),
            ///:
            Colon(Colon<'a>),
            ///;
            SemiColon(SemiColon<'a>),
            ///<
            LessThan(LessThan<'a>),
            ///=
            Assign(Assign<'a>),
            ///>
            GreaterThan(GreaterThan<'a>),
            ///?
            QuestionMark(QuestionMark<'a>),
            ///*
            Wildcard(Wildcard<'a>),
        }
        #[automatically_derived]
        impl<'a> ::core::marker::Copy for Keyword<'a> {}
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Keyword<'a> {
            #[inline]
            fn clone(&self) -> Keyword<'a> {
                let _: ::core::clone::AssertParamIsClone<ArrayBuffer<'a>>;
                let _: ::core::clone::AssertParamIsClone<DataView<'a>>;
                let _: ::core::clone::AssertParamIsClone<Int8Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Int16Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Int32Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Uint8Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Uint16Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Uint32Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Uint8ClampedArray<'a>>;
                let _: ::core::clone::AssertParamIsClone<BigInt64Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<BigUint64Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Float32Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Float64Array<'a>>;
                let _: ::core::clone::AssertParamIsClone<Any<'a>>;
                let _: ::core::clone::AssertParamIsClone<Object<'a>>;
                let _: ::core::clone::AssertParamIsClone<Symbol<'a>>;
                let _: ::core::clone::AssertParamIsClone<ByteString<'a>>;
                let _: ::core::clone::AssertParamIsClone<DOMString<'a>>;
                let _: ::core::clone::AssertParamIsClone<USVString<'a>>;
                let _: ::core::clone::AssertParamIsClone<Async<'a>>;
                let _: ::core::clone::AssertParamIsClone<Attribute<'a>>;
                let _: ::core::clone::AssertParamIsClone<Callback<'a>>;
                let _: ::core::clone::AssertParamIsClone<Constructor<'a>>;
                let _: ::core::clone::AssertParamIsClone<Deleter<'a>>;
                let _: ::core::clone::AssertParamIsClone<Dictionary<'a>>;
                let _: ::core::clone::AssertParamIsClone<Enum<'a>>;
                let _: ::core::clone::AssertParamIsClone<Getter<'a>>;
                let _: ::core::clone::AssertParamIsClone<Includes<'a>>;
                let _: ::core::clone::AssertParamIsClone<Inherit<'a>>;
                let _: ::core::clone::AssertParamIsClone<Interface<'a>>;
                let _: ::core::clone::AssertParamIsClone<Iterable<'a>>;
                let _: ::core::clone::AssertParamIsClone<Maplike<'a>>;
                let _: ::core::clone::AssertParamIsClone<Namespace<'a>>;
                let _: ::core::clone::AssertParamIsClone<Partial<'a>>;
                let _: ::core::clone::AssertParamIsClone<Required<'a>>;
                let _: ::core::clone::AssertParamIsClone<Setlike<'a>>;
                let _: ::core::clone::AssertParamIsClone<Setter<'a>>;
                let _: ::core::clone::AssertParamIsClone<Static<'a>>;
                let _: ::core::clone::AssertParamIsClone<Stringifier<'a>>;
                let _: ::core::clone::AssertParamIsClone<Typedef<'a>>;
                let _: ::core::clone::AssertParamIsClone<Unrestricted<'a>>;
                let _: ::core::clone::AssertParamIsClone<Or<'a>>;
                let _: ::core::clone::AssertParamIsClone<Optional<'a>>;
                let _: ::core::clone::AssertParamIsClone<Const<'a>>;
                let _: ::core::clone::AssertParamIsClone<NegInfinity<'a>>;
                let _: ::core::clone::AssertParamIsClone<FrozenArray<'a>>;
                let _: ::core::clone::AssertParamIsClone<Infinity<'a>>;
                let _: ::core::clone::AssertParamIsClone<NaN<'a>>;
                let _: ::core::clone::AssertParamIsClone<ObservableArray<'a>>;
                let _: ::core::clone::AssertParamIsClone<Bigint<'a>>;
                let _: ::core::clone::AssertParamIsClone<Boolean<'a>>;
                let _: ::core::clone::AssertParamIsClone<Byte<'a>>;
                let _: ::core::clone::AssertParamIsClone<Double<'a>>;
                let _: ::core::clone::AssertParamIsClone<False<'a>>;
                let _: ::core::clone::AssertParamIsClone<Float<'a>>;
                let _: ::core::clone::AssertParamIsClone<Long<'a>>;
                let _: ::core::clone::AssertParamIsClone<Null<'a>>;
                let _: ::core::clone::AssertParamIsClone<Octet<'a>>;
                let _: ::core::clone::AssertParamIsClone<Sequence<'a>>;
                let _: ::core::clone::AssertParamIsClone<Short<'a>>;
                let _: ::core::clone::AssertParamIsClone<True<'a>>;
                let _: ::core::clone::AssertParamIsClone<Unsigned<'a>>;
                let _: ::core::clone::AssertParamIsClone<Undefined<'a>>;
                let _: ::core::clone::AssertParamIsClone<Record<'a>>;
                let _: ::core::clone::AssertParamIsClone<Promise<'a>>;
                let _: ::core::clone::AssertParamIsClone<ReadOnly<'a>>;
                let _: ::core::clone::AssertParamIsClone<Mixin<'a>>;
                let _: ::core::clone::AssertParamIsClone<OpenParen<'a>>;
                let _: ::core::clone::AssertParamIsClone<CloseParen<'a>>;
                let _: ::core::clone::AssertParamIsClone<OpenBracket<'a>>;
                let _: ::core::clone::AssertParamIsClone<CloseBracket<'a>>;
                let _: ::core::clone::AssertParamIsClone<OpenBrace<'a>>;
                let _: ::core::clone::AssertParamIsClone<CloseBrace<'a>>;
                let _: ::core::clone::AssertParamIsClone<Comma<'a>>;
                let _: ::core::clone::AssertParamIsClone<Minus<'a>>;
                let _: ::core::clone::AssertParamIsClone<Dot<'a>>;
                let _: ::core::clone::AssertParamIsClone<Ellipsis<'a>>;
                let _: ::core::clone::AssertParamIsClone<Colon<'a>>;
                let _: ::core::clone::AssertParamIsClone<SemiColon<'a>>;
                let _: ::core::clone::AssertParamIsClone<LessThan<'a>>;
                let _: ::core::clone::AssertParamIsClone<Assign<'a>>;
                let _: ::core::clone::AssertParamIsClone<GreaterThan<'a>>;
                let _: ::core::clone::AssertParamIsClone<QuestionMark<'a>>;
                let _: ::core::clone::AssertParamIsClone<Wildcard<'a>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Keyword<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Keyword::ArrayBuffer(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ArrayBuffer",
                            &__self_0,
                        )
                    }
                    Keyword::DataView(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "DataView",
                            &__self_0,
                        )
                    }
                    Keyword::Int8Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Int8Array",
                            &__self_0,
                        )
                    }
                    Keyword::Int16Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Int16Array",
                            &__self_0,
                        )
                    }
                    Keyword::Int32Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Int32Array",
                            &__self_0,
                        )
                    }
                    Keyword::Uint8Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Uint8Array",
                            &__self_0,
                        )
                    }
                    Keyword::Uint16Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Uint16Array",
                            &__self_0,
                        )
                    }
                    Keyword::Uint32Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Uint32Array",
                            &__self_0,
                        )
                    }
                    Keyword::Uint8ClampedArray(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Uint8ClampedArray",
                            &__self_0,
                        )
                    }
                    Keyword::BigInt64Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "BigInt64Array",
                            &__self_0,
                        )
                    }
                    Keyword::BigUint64Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "BigUint64Array",
                            &__self_0,
                        )
                    }
                    Keyword::Float32Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Float32Array",
                            &__self_0,
                        )
                    }
                    Keyword::Float64Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Float64Array",
                            &__self_0,
                        )
                    }
                    Keyword::Any(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Any",
                            &__self_0,
                        )
                    }
                    Keyword::Object(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Object",
                            &__self_0,
                        )
                    }
                    Keyword::Symbol(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Symbol",
                            &__self_0,
                        )
                    }
                    Keyword::ByteString(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ByteString",
                            &__self_0,
                        )
                    }
                    Keyword::DOMString(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "DOMString",
                            &__self_0,
                        )
                    }
                    Keyword::USVString(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "USVString",
                            &__self_0,
                        )
                    }
                    Keyword::Async(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Async",
                            &__self_0,
                        )
                    }
                    Keyword::Attribute(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Attribute",
                            &__self_0,
                        )
                    }
                    Keyword::Callback(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Callback",
                            &__self_0,
                        )
                    }
                    Keyword::Constructor(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Constructor",
                            &__self_0,
                        )
                    }
                    Keyword::Deleter(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Deleter",
                            &__self_0,
                        )
                    }
                    Keyword::Dictionary(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Dictionary",
                            &__self_0,
                        )
                    }
                    Keyword::Enum(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Enum",
                            &__self_0,
                        )
                    }
                    Keyword::Getter(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Getter",
                            &__self_0,
                        )
                    }
                    Keyword::Includes(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Includes",
                            &__self_0,
                        )
                    }
                    Keyword::Inherit(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Inherit",
                            &__self_0,
                        )
                    }
                    Keyword::Interface(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Interface",
                            &__self_0,
                        )
                    }
                    Keyword::Iterable(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Iterable",
                            &__self_0,
                        )
                    }
                    Keyword::Maplike(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Maplike",
                            &__self_0,
                        )
                    }
                    Keyword::Namespace(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Namespace",
                            &__self_0,
                        )
                    }
                    Keyword::Partial(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Partial",
                            &__self_0,
                        )
                    }
                    Keyword::Required(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Required",
                            &__self_0,
                        )
                    }
                    Keyword::Setlike(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Setlike",
                            &__self_0,
                        )
                    }
                    Keyword::Setter(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Setter",
                            &__self_0,
                        )
                    }
                    Keyword::Static(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Static",
                            &__self_0,
                        )
                    }
                    Keyword::Stringifier(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Stringifier",
                            &__self_0,
                        )
                    }
                    Keyword::Typedef(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Typedef",
                            &__self_0,
                        )
                    }
                    Keyword::Unrestricted(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Unrestricted",
                            &__self_0,
                        )
                    }
                    Keyword::Or(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Or",
                            &__self_0,
                        )
                    }
                    Keyword::Optional(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Optional",
                            &__self_0,
                        )
                    }
                    Keyword::Const(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Const",
                            &__self_0,
                        )
                    }
                    Keyword::NegInfinity(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NegInfinity",
                            &__self_0,
                        )
                    }
                    Keyword::FrozenArray(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "FrozenArray",
                            &__self_0,
                        )
                    }
                    Keyword::Infinity(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Infinity",
                            &__self_0,
                        )
                    }
                    Keyword::NaN(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NaN",
                            &__self_0,
                        )
                    }
                    Keyword::ObservableArray(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ObservableArray",
                            &__self_0,
                        )
                    }
                    Keyword::Bigint(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Bigint",
                            &__self_0,
                        )
                    }
                    Keyword::Boolean(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Boolean",
                            &__self_0,
                        )
                    }
                    Keyword::Byte(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Byte",
                            &__self_0,
                        )
                    }
                    Keyword::Double(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Double",
                            &__self_0,
                        )
                    }
                    Keyword::False(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "False",
                            &__self_0,
                        )
                    }
                    Keyword::Float(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Float",
                            &__self_0,
                        )
                    }
                    Keyword::Long(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Long",
                            &__self_0,
                        )
                    }
                    Keyword::Null(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Null",
                            &__self_0,
                        )
                    }
                    Keyword::Octet(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Octet",
                            &__self_0,
                        )
                    }
                    Keyword::Sequence(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Sequence",
                            &__self_0,
                        )
                    }
                    Keyword::Short(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Short",
                            &__self_0,
                        )
                    }
                    Keyword::True(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "True",
                            &__self_0,
                        )
                    }
                    Keyword::Unsigned(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Unsigned",
                            &__self_0,
                        )
                    }
                    Keyword::Undefined(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Undefined",
                            &__self_0,
                        )
                    }
                    Keyword::Record(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Record",
                            &__self_0,
                        )
                    }
                    Keyword::Promise(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Promise",
                            &__self_0,
                        )
                    }
                    Keyword::ReadOnly(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ReadOnly",
                            &__self_0,
                        )
                    }
                    Keyword::Mixin(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Mixin",
                            &__self_0,
                        )
                    }
                    Keyword::OpenParen(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OpenParen",
                            &__self_0,
                        )
                    }
                    Keyword::CloseParen(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "CloseParen",
                            &__self_0,
                        )
                    }
                    Keyword::OpenBracket(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OpenBracket",
                            &__self_0,
                        )
                    }
                    Keyword::CloseBracket(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "CloseBracket",
                            &__self_0,
                        )
                    }
                    Keyword::OpenBrace(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "OpenBrace",
                            &__self_0,
                        )
                    }
                    Keyword::CloseBrace(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "CloseBrace",
                            &__self_0,
                        )
                    }
                    Keyword::Comma(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Comma",
                            &__self_0,
                        )
                    }
                    Keyword::Minus(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Minus",
                            &__self_0,
                        )
                    }
                    Keyword::Dot(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Dot",
                            &__self_0,
                        )
                    }
                    Keyword::Ellipsis(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Ellipsis",
                            &__self_0,
                        )
                    }
                    Keyword::Colon(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Colon",
                            &__self_0,
                        )
                    }
                    Keyword::SemiColon(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "SemiColon",
                            &__self_0,
                        )
                    }
                    Keyword::LessThan(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "LessThan",
                            &__self_0,
                        )
                    }
                    Keyword::Assign(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Assign",
                            &__self_0,
                        )
                    }
                    Keyword::GreaterThan(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "GreaterThan",
                            &__self_0,
                        )
                    }
                    Keyword::QuestionMark(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "QuestionMark",
                            &__self_0,
                        )
                    }
                    Keyword::Wildcard(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Wildcard",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Keyword<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Keyword<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ArrayBuffer<'a>>;
                let _: ::core::cmp::AssertParamIsEq<DataView<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Int8Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Int16Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Int32Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Uint8Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Uint16Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Uint32Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Uint8ClampedArray<'a>>;
                let _: ::core::cmp::AssertParamIsEq<BigInt64Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<BigUint64Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Float32Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Float64Array<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Any<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Object<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Symbol<'a>>;
                let _: ::core::cmp::AssertParamIsEq<ByteString<'a>>;
                let _: ::core::cmp::AssertParamIsEq<DOMString<'a>>;
                let _: ::core::cmp::AssertParamIsEq<USVString<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Async<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Attribute<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Callback<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Constructor<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Deleter<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Dictionary<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Enum<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Getter<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Includes<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Inherit<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Interface<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Iterable<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Maplike<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Namespace<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Partial<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Required<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Setlike<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Setter<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Static<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Stringifier<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Typedef<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Unrestricted<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Or<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Optional<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Const<'a>>;
                let _: ::core::cmp::AssertParamIsEq<NegInfinity<'a>>;
                let _: ::core::cmp::AssertParamIsEq<FrozenArray<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Infinity<'a>>;
                let _: ::core::cmp::AssertParamIsEq<NaN<'a>>;
                let _: ::core::cmp::AssertParamIsEq<ObservableArray<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Bigint<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Boolean<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Byte<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Double<'a>>;
                let _: ::core::cmp::AssertParamIsEq<False<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Float<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Long<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Null<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Octet<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Sequence<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Short<'a>>;
                let _: ::core::cmp::AssertParamIsEq<True<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Unsigned<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Undefined<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Record<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Promise<'a>>;
                let _: ::core::cmp::AssertParamIsEq<ReadOnly<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Mixin<'a>>;
                let _: ::core::cmp::AssertParamIsEq<OpenParen<'a>>;
                let _: ::core::cmp::AssertParamIsEq<CloseParen<'a>>;
                let _: ::core::cmp::AssertParamIsEq<OpenBracket<'a>>;
                let _: ::core::cmp::AssertParamIsEq<CloseBracket<'a>>;
                let _: ::core::cmp::AssertParamIsEq<OpenBrace<'a>>;
                let _: ::core::cmp::AssertParamIsEq<CloseBrace<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Comma<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Minus<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Dot<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Ellipsis<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Colon<'a>>;
                let _: ::core::cmp::AssertParamIsEq<SemiColon<'a>>;
                let _: ::core::cmp::AssertParamIsEq<LessThan<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Assign<'a>>;
                let _: ::core::cmp::AssertParamIsEq<GreaterThan<'a>>;
                let _: ::core::cmp::AssertParamIsEq<QuestionMark<'a>>;
                let _: ::core::cmp::AssertParamIsEq<Wildcard<'a>>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Keyword<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Keyword<'a> {
            #[inline]
            fn eq(&self, other: &Keyword<'a>) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            Keyword::ArrayBuffer(__self_0),
                            Keyword::ArrayBuffer(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::DataView(__self_0), Keyword::DataView(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Int8Array(__self_0), Keyword::Int8Array(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::Int16Array(__self_0),
                            Keyword::Int16Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::Int32Array(__self_0),
                            Keyword::Int32Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::Uint8Array(__self_0),
                            Keyword::Uint8Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::Uint16Array(__self_0),
                            Keyword::Uint16Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::Uint32Array(__self_0),
                            Keyword::Uint32Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::Uint8ClampedArray(__self_0),
                            Keyword::Uint8ClampedArray(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::BigInt64Array(__self_0),
                            Keyword::BigInt64Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::BigUint64Array(__self_0),
                            Keyword::BigUint64Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::Float32Array(__self_0),
                            Keyword::Float32Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::Float64Array(__self_0),
                            Keyword::Float64Array(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Any(__self_0), Keyword::Any(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Object(__self_0), Keyword::Object(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Symbol(__self_0), Keyword::Symbol(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::ByteString(__self_0),
                            Keyword::ByteString(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::DOMString(__self_0), Keyword::DOMString(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::USVString(__self_0), Keyword::USVString(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Async(__self_0), Keyword::Async(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Attribute(__self_0), Keyword::Attribute(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Callback(__self_0), Keyword::Callback(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::Constructor(__self_0),
                            Keyword::Constructor(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Deleter(__self_0), Keyword::Deleter(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::Dictionary(__self_0),
                            Keyword::Dictionary(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Enum(__self_0), Keyword::Enum(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Getter(__self_0), Keyword::Getter(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Includes(__self_0), Keyword::Includes(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Inherit(__self_0), Keyword::Inherit(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Interface(__self_0), Keyword::Interface(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Iterable(__self_0), Keyword::Iterable(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Maplike(__self_0), Keyword::Maplike(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Namespace(__self_0), Keyword::Namespace(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Partial(__self_0), Keyword::Partial(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Required(__self_0), Keyword::Required(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Setlike(__self_0), Keyword::Setlike(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Setter(__self_0), Keyword::Setter(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Static(__self_0), Keyword::Static(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::Stringifier(__self_0),
                            Keyword::Stringifier(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Typedef(__self_0), Keyword::Typedef(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::Unrestricted(__self_0),
                            Keyword::Unrestricted(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Or(__self_0), Keyword::Or(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Optional(__self_0), Keyword::Optional(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Const(__self_0), Keyword::Const(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::NegInfinity(__self_0),
                            Keyword::NegInfinity(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::FrozenArray(__self_0),
                            Keyword::FrozenArray(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Infinity(__self_0), Keyword::Infinity(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::NaN(__self_0), Keyword::NaN(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::ObservableArray(__self_0),
                            Keyword::ObservableArray(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Bigint(__self_0), Keyword::Bigint(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Boolean(__self_0), Keyword::Boolean(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Byte(__self_0), Keyword::Byte(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Double(__self_0), Keyword::Double(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::False(__self_0), Keyword::False(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Float(__self_0), Keyword::Float(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Long(__self_0), Keyword::Long(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Null(__self_0), Keyword::Null(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Octet(__self_0), Keyword::Octet(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Sequence(__self_0), Keyword::Sequence(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Short(__self_0), Keyword::Short(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::True(__self_0), Keyword::True(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Unsigned(__self_0), Keyword::Unsigned(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Undefined(__self_0), Keyword::Undefined(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Record(__self_0), Keyword::Record(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Promise(__self_0), Keyword::Promise(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::ReadOnly(__self_0), Keyword::ReadOnly(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Mixin(__self_0), Keyword::Mixin(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::OpenParen(__self_0), Keyword::OpenParen(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::CloseParen(__self_0),
                            Keyword::CloseParen(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::OpenBracket(__self_0),
                            Keyword::OpenBracket(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::CloseBracket(__self_0),
                            Keyword::CloseBracket(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::OpenBrace(__self_0), Keyword::OpenBrace(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::CloseBrace(__self_0),
                            Keyword::CloseBrace(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Comma(__self_0), Keyword::Comma(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Minus(__self_0), Keyword::Minus(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Dot(__self_0), Keyword::Dot(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Ellipsis(__self_0), Keyword::Ellipsis(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Colon(__self_0), Keyword::Colon(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::SemiColon(__self_0), Keyword::SemiColon(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::LessThan(__self_0), Keyword::LessThan(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (Keyword::Assign(__self_0), Keyword::Assign(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            Keyword::GreaterThan(__self_0),
                            Keyword::GreaterThan(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            Keyword::QuestionMark(__self_0),
                            Keyword::QuestionMark(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Keyword::Wildcard(__self_0), Keyword::Wildcard(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Keyword<'a> {
            #[inline]
            fn cmp(&self, other: &Keyword<'a>) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                Keyword::ArrayBuffer(__self_0),
                                Keyword::ArrayBuffer(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::DataView(__self_0),
                                Keyword::DataView(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Int8Array(__self_0),
                                Keyword::Int8Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Int16Array(__self_0),
                                Keyword::Int16Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Int32Array(__self_0),
                                Keyword::Int32Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Uint8Array(__self_0),
                                Keyword::Uint8Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Uint16Array(__self_0),
                                Keyword::Uint16Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Uint32Array(__self_0),
                                Keyword::Uint32Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Uint8ClampedArray(__self_0),
                                Keyword::Uint8ClampedArray(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::BigInt64Array(__self_0),
                                Keyword::BigInt64Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::BigUint64Array(__self_0),
                                Keyword::BigUint64Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Float32Array(__self_0),
                                Keyword::Float32Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Float64Array(__self_0),
                                Keyword::Float64Array(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Any(__self_0), Keyword::Any(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Object(__self_0), Keyword::Object(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Symbol(__self_0), Keyword::Symbol(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::ByteString(__self_0),
                                Keyword::ByteString(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::DOMString(__self_0),
                                Keyword::DOMString(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::USVString(__self_0),
                                Keyword::USVString(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Async(__self_0), Keyword::Async(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Attribute(__self_0),
                                Keyword::Attribute(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Callback(__self_0),
                                Keyword::Callback(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Constructor(__self_0),
                                Keyword::Constructor(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Deleter(__self_0), Keyword::Deleter(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Dictionary(__self_0),
                                Keyword::Dictionary(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Enum(__self_0), Keyword::Enum(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Getter(__self_0), Keyword::Getter(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Includes(__self_0),
                                Keyword::Includes(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Inherit(__self_0), Keyword::Inherit(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Interface(__self_0),
                                Keyword::Interface(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Iterable(__self_0),
                                Keyword::Iterable(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Maplike(__self_0), Keyword::Maplike(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Namespace(__self_0),
                                Keyword::Namespace(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Partial(__self_0), Keyword::Partial(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Required(__self_0),
                                Keyword::Required(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Setlike(__self_0), Keyword::Setlike(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Setter(__self_0), Keyword::Setter(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Static(__self_0), Keyword::Static(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Stringifier(__self_0),
                                Keyword::Stringifier(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Typedef(__self_0), Keyword::Typedef(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Unrestricted(__self_0),
                                Keyword::Unrestricted(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Or(__self_0), Keyword::Or(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Optional(__self_0),
                                Keyword::Optional(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Const(__self_0), Keyword::Const(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::NegInfinity(__self_0),
                                Keyword::NegInfinity(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::FrozenArray(__self_0),
                                Keyword::FrozenArray(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Infinity(__self_0),
                                Keyword::Infinity(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::NaN(__self_0), Keyword::NaN(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::ObservableArray(__self_0),
                                Keyword::ObservableArray(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Bigint(__self_0), Keyword::Bigint(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Boolean(__self_0), Keyword::Boolean(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Byte(__self_0), Keyword::Byte(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Double(__self_0), Keyword::Double(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::False(__self_0), Keyword::False(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Float(__self_0), Keyword::Float(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Long(__self_0), Keyword::Long(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Null(__self_0), Keyword::Null(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Octet(__self_0), Keyword::Octet(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Sequence(__self_0),
                                Keyword::Sequence(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Short(__self_0), Keyword::Short(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::True(__self_0), Keyword::True(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Unsigned(__self_0),
                                Keyword::Unsigned(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Undefined(__self_0),
                                Keyword::Undefined(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Record(__self_0), Keyword::Record(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Promise(__self_0), Keyword::Promise(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::ReadOnly(__self_0),
                                Keyword::ReadOnly(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Mixin(__self_0), Keyword::Mixin(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::OpenParen(__self_0),
                                Keyword::OpenParen(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::CloseParen(__self_0),
                                Keyword::CloseParen(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::OpenBracket(__self_0),
                                Keyword::OpenBracket(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::CloseBracket(__self_0),
                                Keyword::CloseBracket(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::OpenBrace(__self_0),
                                Keyword::OpenBrace(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::CloseBrace(__self_0),
                                Keyword::CloseBrace(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Comma(__self_0), Keyword::Comma(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Minus(__self_0), Keyword::Minus(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Dot(__self_0), Keyword::Dot(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Ellipsis(__self_0),
                                Keyword::Ellipsis(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Colon(__self_0), Keyword::Colon(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::SemiColon(__self_0),
                                Keyword::SemiColon(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::LessThan(__self_0),
                                Keyword::LessThan(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Keyword::Assign(__self_0), Keyword::Assign(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::GreaterThan(__self_0),
                                Keyword::GreaterThan(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::QuestionMark(__self_0),
                                Keyword::QuestionMark(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Keyword::Wildcard(__self_0),
                                Keyword::Wildcard(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Keyword<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Keyword<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match (self, other) {
                            (
                                Keyword::ArrayBuffer(__self_0),
                                Keyword::ArrayBuffer(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::DataView(__self_0),
                                Keyword::DataView(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Int8Array(__self_0),
                                Keyword::Int8Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Int16Array(__self_0),
                                Keyword::Int16Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Int32Array(__self_0),
                                Keyword::Int32Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Uint8Array(__self_0),
                                Keyword::Uint8Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Uint16Array(__self_0),
                                Keyword::Uint16Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Uint32Array(__self_0),
                                Keyword::Uint32Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Uint8ClampedArray(__self_0),
                                Keyword::Uint8ClampedArray(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::BigInt64Array(__self_0),
                                Keyword::BigInt64Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::BigUint64Array(__self_0),
                                Keyword::BigUint64Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Float32Array(__self_0),
                                Keyword::Float32Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Float64Array(__self_0),
                                Keyword::Float64Array(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Any(__self_0), Keyword::Any(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Object(__self_0), Keyword::Object(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Symbol(__self_0), Keyword::Symbol(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::ByteString(__self_0),
                                Keyword::ByteString(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::DOMString(__self_0),
                                Keyword::DOMString(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::USVString(__self_0),
                                Keyword::USVString(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Async(__self_0), Keyword::Async(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Attribute(__self_0),
                                Keyword::Attribute(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Callback(__self_0),
                                Keyword::Callback(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Constructor(__self_0),
                                Keyword::Constructor(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Deleter(__self_0), Keyword::Deleter(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Dictionary(__self_0),
                                Keyword::Dictionary(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Enum(__self_0), Keyword::Enum(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Getter(__self_0), Keyword::Getter(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Includes(__self_0),
                                Keyword::Includes(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Inherit(__self_0), Keyword::Inherit(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Interface(__self_0),
                                Keyword::Interface(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Iterable(__self_0),
                                Keyword::Iterable(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Maplike(__self_0), Keyword::Maplike(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Namespace(__self_0),
                                Keyword::Namespace(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Partial(__self_0), Keyword::Partial(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Required(__self_0),
                                Keyword::Required(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Setlike(__self_0), Keyword::Setlike(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Setter(__self_0), Keyword::Setter(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Static(__self_0), Keyword::Static(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Stringifier(__self_0),
                                Keyword::Stringifier(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Typedef(__self_0), Keyword::Typedef(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Unrestricted(__self_0),
                                Keyword::Unrestricted(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Or(__self_0), Keyword::Or(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Optional(__self_0),
                                Keyword::Optional(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Const(__self_0), Keyword::Const(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::NegInfinity(__self_0),
                                Keyword::NegInfinity(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::FrozenArray(__self_0),
                                Keyword::FrozenArray(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Infinity(__self_0),
                                Keyword::Infinity(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::NaN(__self_0), Keyword::NaN(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::ObservableArray(__self_0),
                                Keyword::ObservableArray(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Bigint(__self_0), Keyword::Bigint(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Boolean(__self_0), Keyword::Boolean(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Byte(__self_0), Keyword::Byte(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Double(__self_0), Keyword::Double(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::False(__self_0), Keyword::False(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Float(__self_0), Keyword::Float(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Long(__self_0), Keyword::Long(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Null(__self_0), Keyword::Null(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Octet(__self_0), Keyword::Octet(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Sequence(__self_0),
                                Keyword::Sequence(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Short(__self_0), Keyword::Short(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::True(__self_0), Keyword::True(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Unsigned(__self_0),
                                Keyword::Unsigned(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Undefined(__self_0),
                                Keyword::Undefined(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Record(__self_0), Keyword::Record(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Promise(__self_0), Keyword::Promise(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::ReadOnly(__self_0),
                                Keyword::ReadOnly(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Mixin(__self_0), Keyword::Mixin(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::OpenParen(__self_0),
                                Keyword::OpenParen(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::CloseParen(__self_0),
                                Keyword::CloseParen(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::OpenBracket(__self_0),
                                Keyword::OpenBracket(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::CloseBracket(__self_0),
                                Keyword::CloseBracket(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::OpenBrace(__self_0),
                                Keyword::OpenBrace(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::CloseBrace(__self_0),
                                Keyword::CloseBrace(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Comma(__self_0), Keyword::Comma(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Minus(__self_0), Keyword::Minus(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (Keyword::Dot(__self_0), Keyword::Dot(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::Ellipsis(__self_0),
                                Keyword::Ellipsis(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Colon(__self_0), Keyword::Colon(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::SemiColon(__self_0),
                                Keyword::SemiColon(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::LessThan(__self_0),
                                Keyword::LessThan(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Keyword::Assign(__self_0), Keyword::Assign(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            (
                                Keyword::GreaterThan(__self_0),
                                Keyword::GreaterThan(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::QuestionMark(__self_0),
                                Keyword::QuestionMark(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                Keyword::Wildcard(__self_0),
                                Keyword::Wildcard(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Keyword<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state);
                match self {
                    Keyword::ArrayBuffer(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::DataView(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Int8Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Int16Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Int32Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Uint8Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Uint16Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Uint32Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Uint8ClampedArray(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::BigInt64Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::BigUint64Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Float32Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Float64Array(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Any(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Object(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Symbol(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::ByteString(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::DOMString(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::USVString(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Async(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Attribute(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Callback(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Constructor(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Deleter(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Dictionary(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Enum(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Getter(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Includes(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Inherit(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Interface(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Iterable(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Maplike(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Namespace(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Partial(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Required(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Setlike(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Setter(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Static(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Stringifier(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Typedef(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Unrestricted(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Or(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Optional(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Const(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::NegInfinity(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::FrozenArray(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Infinity(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::NaN(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::ObservableArray(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Bigint(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Boolean(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Byte(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Double(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::False(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Float(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Long(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Null(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Octet(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Sequence(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Short(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::True(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Unsigned(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Undefined(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Record(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Promise(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::ReadOnly(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Mixin(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::OpenParen(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::CloseParen(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::OpenBracket(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::CloseBracket(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::OpenBrace(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::CloseBrace(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Comma(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Minus(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Dot(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::Ellipsis(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Colon(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                    Keyword::SemiColon(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::LessThan(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Assign(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::GreaterThan(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::QuestionMark(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Keyword::Wildcard(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        impl<'a> Keyword<'a> {
            pub fn parse(input: &str) -> nom::IResult<&str, Keyword> {
                nom::branch::alt((
                    nom::combinator::map(
                        nom::combinator::recognize(
                            nom::bytes::complete::tag("ArrayBuffer"),
                        ),
                        |k| Keyword::ArrayBuffer(ArrayBuffer(k)),
                    ),
                    nom::combinator::map(
                        nom::combinator::recognize(
                            nom::bytes::complete::tag("DataView"),
                        ),
                        |k| Keyword::DataView(DataView(k)),
                    ),
                    nom::branch::alt((
                        nom::combinator::map(
                            nom::combinator::recognize(
                                nom::bytes::complete::tag("Int8Array"),
                            ),
                            |k| Keyword::Int8Array(Int8Array(k)),
                        ),
                        nom::combinator::map(
                            nom::combinator::recognize(
                                nom::bytes::complete::tag("Int16Array"),
                            ),
                            |k| Keyword::Int16Array(Int16Array(k)),
                        ),
                        nom::branch::alt((
                            nom::combinator::map(
                                nom::combinator::recognize(
                                    nom::bytes::complete::tag("Int32Array"),
                                ),
                                |k| Keyword::Int32Array(Int32Array(k)),
                            ),
                            nom::combinator::map(
                                nom::combinator::recognize(
                                    nom::bytes::complete::tag("Uint8Array"),
                                ),
                                |k| Keyword::Uint8Array(Uint8Array(k)),
                            ),
                            nom::branch::alt((
                                nom::combinator::map(
                                    nom::combinator::recognize(
                                        nom::bytes::complete::tag("Uint16Array"),
                                    ),
                                    |k| Keyword::Uint16Array(Uint16Array(k)),
                                ),
                                nom::combinator::map(
                                    nom::combinator::recognize(
                                        nom::bytes::complete::tag("Uint32Array"),
                                    ),
                                    |k| Keyword::Uint32Array(Uint32Array(k)),
                                ),
                                nom::branch::alt((
                                    nom::combinator::map(
                                        nom::combinator::recognize(
                                            nom::bytes::complete::tag("Uint8ClampedArray"),
                                        ),
                                        |k| Keyword::Uint8ClampedArray(Uint8ClampedArray(k)),
                                    ),
                                    nom::combinator::map(
                                        nom::combinator::recognize(
                                            nom::bytes::complete::tag("BigInt64Array"),
                                        ),
                                        |k| Keyword::BigInt64Array(BigInt64Array(k)),
                                    ),
                                    nom::branch::alt((
                                        nom::combinator::map(
                                            nom::combinator::recognize(
                                                nom::bytes::complete::tag("BigUint64Array"),
                                            ),
                                            |k| Keyword::BigUint64Array(BigUint64Array(k)),
                                        ),
                                        nom::combinator::map(
                                            nom::combinator::recognize(
                                                nom::bytes::complete::tag("Float32Array"),
                                            ),
                                            |k| Keyword::Float32Array(Float32Array(k)),
                                        ),
                                        nom::branch::alt((
                                            nom::combinator::map(
                                                nom::combinator::recognize(
                                                    nom::bytes::complete::tag("Float64Array"),
                                                ),
                                                |k| Keyword::Float64Array(Float64Array(k)),
                                            ),
                                            nom::combinator::map(
                                                nom::combinator::recognize(
                                                    nom::bytes::complete::tag("any"),
                                                ),
                                                |k| Keyword::Any(Any(k)),
                                            ),
                                            nom::branch::alt((
                                                nom::combinator::map(
                                                    nom::combinator::recognize(
                                                        nom::bytes::complete::tag("object"),
                                                    ),
                                                    |k| Keyword::Object(Object(k)),
                                                ),
                                                nom::combinator::map(
                                                    nom::combinator::recognize(
                                                        nom::bytes::complete::tag("symbol"),
                                                    ),
                                                    |k| Keyword::Symbol(Symbol(k)),
                                                ),
                                                nom::branch::alt((
                                                    nom::combinator::map(
                                                        nom::combinator::recognize(
                                                            nom::bytes::complete::tag("ByteString"),
                                                        ),
                                                        |k| Keyword::ByteString(ByteString(k)),
                                                    ),
                                                    nom::combinator::map(
                                                        nom::combinator::recognize(
                                                            nom::bytes::complete::tag("DOMString"),
                                                        ),
                                                        |k| Keyword::DOMString(DOMString(k)),
                                                    ),
                                                    nom::branch::alt((
                                                        nom::combinator::map(
                                                            nom::combinator::recognize(
                                                                nom::bytes::complete::tag("USVString"),
                                                            ),
                                                            |k| Keyword::USVString(USVString(k)),
                                                        ),
                                                        nom::combinator::map(
                                                            nom::combinator::recognize(
                                                                nom::bytes::complete::tag("async"),
                                                            ),
                                                            |k| Keyword::Async(Async(k)),
                                                        ),
                                                        nom::branch::alt((
                                                            nom::combinator::map(
                                                                nom::combinator::recognize(
                                                                    nom::bytes::complete::tag("attribute"),
                                                                ),
                                                                |k| Keyword::Attribute(Attribute(k)),
                                                            ),
                                                            nom::combinator::map(
                                                                nom::combinator::recognize(
                                                                    nom::bytes::complete::tag("callback"),
                                                                ),
                                                                |k| Keyword::Callback(Callback(k)),
                                                            ),
                                                            nom::branch::alt((
                                                                nom::combinator::map(
                                                                    nom::combinator::recognize(
                                                                        nom::bytes::complete::tag("constructor"),
                                                                    ),
                                                                    |k| Keyword::Constructor(Constructor(k)),
                                                                ),
                                                                nom::combinator::map(
                                                                    nom::combinator::recognize(
                                                                        nom::bytes::complete::tag("deleter"),
                                                                    ),
                                                                    |k| Keyword::Deleter(Deleter(k)),
                                                                ),
                                                                nom::branch::alt((
                                                                    nom::combinator::map(
                                                                        nom::combinator::recognize(
                                                                            nom::bytes::complete::tag("dictionary"),
                                                                        ),
                                                                        |k| Keyword::Dictionary(Dictionary(k)),
                                                                    ),
                                                                    nom::combinator::map(
                                                                        nom::combinator::recognize(
                                                                            nom::bytes::complete::tag("enum"),
                                                                        ),
                                                                        |k| Keyword::Enum(Enum(k)),
                                                                    ),
                                                                    nom::branch::alt((
                                                                        nom::combinator::map(
                                                                            nom::combinator::recognize(
                                                                                nom::bytes::complete::tag("getter"),
                                                                            ),
                                                                            |k| Keyword::Getter(Getter(k)),
                                                                        ),
                                                                        nom::combinator::map(
                                                                            nom::combinator::recognize(
                                                                                nom::bytes::complete::tag("includes"),
                                                                            ),
                                                                            |k| Keyword::Includes(Includes(k)),
                                                                        ),
                                                                        nom::branch::alt((
                                                                            nom::combinator::map(
                                                                                nom::combinator::recognize(
                                                                                    nom::bytes::complete::tag("inherit"),
                                                                                ),
                                                                                |k| Keyword::Inherit(Inherit(k)),
                                                                            ),
                                                                            nom::combinator::map(
                                                                                nom::combinator::recognize(
                                                                                    nom::bytes::complete::tag("interface"),
                                                                                ),
                                                                                |k| Keyword::Interface(Interface(k)),
                                                                            ),
                                                                            nom::branch::alt((
                                                                                nom::combinator::map(
                                                                                    nom::combinator::recognize(
                                                                                        nom::bytes::complete::tag("iterable"),
                                                                                    ),
                                                                                    |k| Keyword::Iterable(Iterable(k)),
                                                                                ),
                                                                                nom::combinator::map(
                                                                                    nom::combinator::recognize(
                                                                                        nom::bytes::complete::tag("maplike"),
                                                                                    ),
                                                                                    |k| Keyword::Maplike(Maplike(k)),
                                                                                ),
                                                                                nom::branch::alt((
                                                                                    nom::combinator::map(
                                                                                        nom::combinator::recognize(
                                                                                            nom::bytes::complete::tag("namespace"),
                                                                                        ),
                                                                                        |k| Keyword::Namespace(Namespace(k)),
                                                                                    ),
                                                                                    nom::combinator::map(
                                                                                        nom::combinator::recognize(
                                                                                            nom::bytes::complete::tag("partial"),
                                                                                        ),
                                                                                        |k| Keyword::Partial(Partial(k)),
                                                                                    ),
                                                                                    nom::branch::alt((
                                                                                        nom::combinator::map(
                                                                                            nom::combinator::recognize(
                                                                                                nom::bytes::complete::tag("required"),
                                                                                            ),
                                                                                            |k| Keyword::Required(Required(k)),
                                                                                        ),
                                                                                        nom::combinator::map(
                                                                                            nom::combinator::recognize(
                                                                                                nom::bytes::complete::tag("setlike"),
                                                                                            ),
                                                                                            |k| Keyword::Setlike(Setlike(k)),
                                                                                        ),
                                                                                        nom::branch::alt((
                                                                                            nom::combinator::map(
                                                                                                nom::combinator::recognize(
                                                                                                    nom::bytes::complete::tag("setter"),
                                                                                                ),
                                                                                                |k| Keyword::Setter(Setter(k)),
                                                                                            ),
                                                                                            nom::combinator::map(
                                                                                                nom::combinator::recognize(
                                                                                                    nom::bytes::complete::tag("static"),
                                                                                                ),
                                                                                                |k| Keyword::Static(Static(k)),
                                                                                            ),
                                                                                            nom::branch::alt((
                                                                                                nom::combinator::map(
                                                                                                    nom::combinator::recognize(
                                                                                                        nom::bytes::complete::tag("stringifier"),
                                                                                                    ),
                                                                                                    |k| Keyword::Stringifier(Stringifier(k)),
                                                                                                ),
                                                                                                nom::combinator::map(
                                                                                                    nom::combinator::recognize(
                                                                                                        nom::bytes::complete::tag("typedef"),
                                                                                                    ),
                                                                                                    |k| Keyword::Typedef(Typedef(k)),
                                                                                                ),
                                                                                                nom::branch::alt((
                                                                                                    nom::combinator::map(
                                                                                                        nom::combinator::recognize(
                                                                                                            nom::bytes::complete::tag("unrestricted"),
                                                                                                        ),
                                                                                                        |k| Keyword::Unrestricted(Unrestricted(k)),
                                                                                                    ),
                                                                                                    nom::combinator::map(
                                                                                                        nom::combinator::recognize(nom::bytes::complete::tag("or")),
                                                                                                        |k| Keyword::Or(Or(k)),
                                                                                                    ),
                                                                                                    nom::branch::alt((
                                                                                                        nom::combinator::map(
                                                                                                            nom::combinator::recognize(
                                                                                                                nom::bytes::complete::tag("optional"),
                                                                                                            ),
                                                                                                            |k| Keyword::Optional(Optional(k)),
                                                                                                        ),
                                                                                                        nom::combinator::map(
                                                                                                            nom::combinator::recognize(
                                                                                                                nom::bytes::complete::tag("const"),
                                                                                                            ),
                                                                                                            |k| Keyword::Const(Const(k)),
                                                                                                        ),
                                                                                                        nom::branch::alt((
                                                                                                            nom::combinator::map(
                                                                                                                nom::combinator::recognize(
                                                                                                                    nom::bytes::complete::tag("-Infinity"),
                                                                                                                ),
                                                                                                                |k| Keyword::NegInfinity(NegInfinity(k)),
                                                                                                            ),
                                                                                                            nom::combinator::map(
                                                                                                                nom::combinator::recognize(
                                                                                                                    nom::bytes::complete::tag("FrozenArray"),
                                                                                                                ),
                                                                                                                |k| Keyword::FrozenArray(FrozenArray(k)),
                                                                                                            ),
                                                                                                            nom::branch::alt((
                                                                                                                nom::combinator::map(
                                                                                                                    nom::combinator::recognize(
                                                                                                                        nom::bytes::complete::tag("Infinity"),
                                                                                                                    ),
                                                                                                                    |k| Keyword::Infinity(Infinity(k)),
                                                                                                                ),
                                                                                                                nom::combinator::map(
                                                                                                                    nom::combinator::recognize(
                                                                                                                        nom::bytes::complete::tag("NaN"),
                                                                                                                    ),
                                                                                                                    |k| Keyword::NaN(NaN(k)),
                                                                                                                ),
                                                                                                                nom::branch::alt((
                                                                                                                    nom::combinator::map(
                                                                                                                        nom::combinator::recognize(
                                                                                                                            nom::bytes::complete::tag("ObservableArray"),
                                                                                                                        ),
                                                                                                                        |k| Keyword::ObservableArray(ObservableArray(k)),
                                                                                                                    ),
                                                                                                                    nom::combinator::map(
                                                                                                                        nom::combinator::recognize(
                                                                                                                            nom::bytes::complete::tag("bigint"),
                                                                                                                        ),
                                                                                                                        |k| Keyword::Bigint(Bigint(k)),
                                                                                                                    ),
                                                                                                                    nom::branch::alt((
                                                                                                                        nom::combinator::map(
                                                                                                                            nom::combinator::recognize(
                                                                                                                                nom::bytes::complete::tag("boolean"),
                                                                                                                            ),
                                                                                                                            |k| Keyword::Boolean(Boolean(k)),
                                                                                                                        ),
                                                                                                                        nom::combinator::map(
                                                                                                                            nom::combinator::recognize(
                                                                                                                                nom::bytes::complete::tag("byte"),
                                                                                                                            ),
                                                                                                                            |k| Keyword::Byte(Byte(k)),
                                                                                                                        ),
                                                                                                                        nom::branch::alt((
                                                                                                                            nom::combinator::map(
                                                                                                                                nom::combinator::recognize(
                                                                                                                                    nom::bytes::complete::tag("double"),
                                                                                                                                ),
                                                                                                                                |k| Keyword::Double(Double(k)),
                                                                                                                            ),
                                                                                                                            nom::combinator::map(
                                                                                                                                nom::combinator::recognize(
                                                                                                                                    nom::bytes::complete::tag("false"),
                                                                                                                                ),
                                                                                                                                |k| Keyword::False(False(k)),
                                                                                                                            ),
                                                                                                                            nom::branch::alt((
                                                                                                                                nom::combinator::map(
                                                                                                                                    nom::combinator::recognize(
                                                                                                                                        nom::bytes::complete::tag("float"),
                                                                                                                                    ),
                                                                                                                                    |k| Keyword::Float(Float(k)),
                                                                                                                                ),
                                                                                                                                nom::combinator::map(
                                                                                                                                    nom::combinator::recognize(
                                                                                                                                        nom::bytes::complete::tag("long"),
                                                                                                                                    ),
                                                                                                                                    |k| Keyword::Long(Long(k)),
                                                                                                                                ),
                                                                                                                                nom::branch::alt((
                                                                                                                                    nom::combinator::map(
                                                                                                                                        nom::combinator::recognize(
                                                                                                                                            nom::bytes::complete::tag("null"),
                                                                                                                                        ),
                                                                                                                                        |k| Keyword::Null(Null(k)),
                                                                                                                                    ),
                                                                                                                                    nom::combinator::map(
                                                                                                                                        nom::combinator::recognize(
                                                                                                                                            nom::bytes::complete::tag("octet"),
                                                                                                                                        ),
                                                                                                                                        |k| Keyword::Octet(Octet(k)),
                                                                                                                                    ),
                                                                                                                                    nom::branch::alt((
                                                                                                                                        nom::combinator::map(
                                                                                                                                            nom::combinator::recognize(
                                                                                                                                                nom::bytes::complete::tag("sequence"),
                                                                                                                                            ),
                                                                                                                                            |k| Keyword::Sequence(Sequence(k)),
                                                                                                                                        ),
                                                                                                                                        nom::combinator::map(
                                                                                                                                            nom::combinator::recognize(
                                                                                                                                                nom::bytes::complete::tag("short"),
                                                                                                                                            ),
                                                                                                                                            |k| Keyword::Short(Short(k)),
                                                                                                                                        ),
                                                                                                                                        nom::branch::alt((
                                                                                                                                            nom::combinator::map(
                                                                                                                                                nom::combinator::recognize(
                                                                                                                                                    nom::bytes::complete::tag("true"),
                                                                                                                                                ),
                                                                                                                                                |k| Keyword::True(True(k)),
                                                                                                                                            ),
                                                                                                                                            nom::combinator::map(
                                                                                                                                                nom::combinator::recognize(
                                                                                                                                                    nom::bytes::complete::tag("unsigned"),
                                                                                                                                                ),
                                                                                                                                                |k| Keyword::Unsigned(Unsigned(k)),
                                                                                                                                            ),
                                                                                                                                            nom::branch::alt((
                                                                                                                                                nom::combinator::map(
                                                                                                                                                    nom::combinator::recognize(
                                                                                                                                                        nom::bytes::complete::tag("undefined"),
                                                                                                                                                    ),
                                                                                                                                                    |k| Keyword::Undefined(Undefined(k)),
                                                                                                                                                ),
                                                                                                                                                nom::combinator::map(
                                                                                                                                                    nom::combinator::recognize(
                                                                                                                                                        nom::bytes::complete::tag("record"),
                                                                                                                                                    ),
                                                                                                                                                    |k| Keyword::Record(Record(k)),
                                                                                                                                                ),
                                                                                                                                                nom::branch::alt((
                                                                                                                                                    nom::combinator::map(
                                                                                                                                                        nom::combinator::recognize(
                                                                                                                                                            nom::bytes::complete::tag("Promise"),
                                                                                                                                                        ),
                                                                                                                                                        |k| Keyword::Promise(Promise(k)),
                                                                                                                                                    ),
                                                                                                                                                    nom::combinator::map(
                                                                                                                                                        nom::combinator::recognize(
                                                                                                                                                            nom::bytes::complete::tag("readonly"),
                                                                                                                                                        ),
                                                                                                                                                        |k| Keyword::ReadOnly(ReadOnly(k)),
                                                                                                                                                    ),
                                                                                                                                                    nom::branch::alt((
                                                                                                                                                        nom::combinator::map(
                                                                                                                                                            nom::combinator::recognize(
                                                                                                                                                                nom::bytes::complete::tag("mixin"),
                                                                                                                                                            ),
                                                                                                                                                            |k| Keyword::Mixin(Mixin(k)),
                                                                                                                                                        ),
                                                                                                                                                        nom::combinator::map(
                                                                                                                                                            nom::combinator::recognize(nom::bytes::complete::tag("(")),
                                                                                                                                                            |k| Keyword::OpenParen(OpenParen(k)),
                                                                                                                                                        ),
                                                                                                                                                        nom::branch::alt((
                                                                                                                                                            nom::combinator::map(
                                                                                                                                                                nom::combinator::recognize(nom::bytes::complete::tag(")")),
                                                                                                                                                                |k| Keyword::CloseParen(CloseParen(k)),
                                                                                                                                                            ),
                                                                                                                                                            nom::combinator::map(
                                                                                                                                                                nom::combinator::recognize(nom::bytes::complete::tag("[")),
                                                                                                                                                                |k| Keyword::OpenBracket(OpenBracket(k)),
                                                                                                                                                            ),
                                                                                                                                                            nom::branch::alt((
                                                                                                                                                                nom::combinator::map(
                                                                                                                                                                    nom::combinator::recognize(nom::bytes::complete::tag("]")),
                                                                                                                                                                    |k| Keyword::CloseBracket(CloseBracket(k)),
                                                                                                                                                                ),
                                                                                                                                                                nom::combinator::map(
                                                                                                                                                                    nom::combinator::recognize(nom::bytes::complete::tag("{")),
                                                                                                                                                                    |k| Keyword::OpenBrace(OpenBrace(k)),
                                                                                                                                                                ),
                                                                                                                                                                nom::branch::alt((
                                                                                                                                                                    nom::combinator::map(
                                                                                                                                                                        nom::combinator::recognize(nom::bytes::complete::tag("}")),
                                                                                                                                                                        |k| Keyword::CloseBrace(CloseBrace(k)),
                                                                                                                                                                    ),
                                                                                                                                                                    nom::combinator::map(
                                                                                                                                                                        nom::combinator::recognize(nom::bytes::complete::tag(",")),
                                                                                                                                                                        |k| Keyword::Comma(Comma(k)),
                                                                                                                                                                    ),
                                                                                                                                                                    nom::branch::alt((
                                                                                                                                                                        nom::combinator::map(
                                                                                                                                                                            nom::combinator::recognize(nom::bytes::complete::tag("-")),
                                                                                                                                                                            |k| Keyword::Minus(Minus(k)),
                                                                                                                                                                        ),
                                                                                                                                                                        nom::combinator::map(
                                                                                                                                                                            nom::combinator::recognize(nom::bytes::complete::tag(".")),
                                                                                                                                                                            |k| Keyword::Dot(Dot(k)),
                                                                                                                                                                        ),
                                                                                                                                                                        nom::branch::alt((
                                                                                                                                                                            nom::combinator::map(
                                                                                                                                                                                nom::combinator::recognize(
                                                                                                                                                                                    nom::bytes::complete::tag("..."),
                                                                                                                                                                                ),
                                                                                                                                                                                |k| Keyword::Ellipsis(Ellipsis(k)),
                                                                                                                                                                            ),
                                                                                                                                                                            nom::combinator::map(
                                                                                                                                                                                nom::combinator::recognize(nom::bytes::complete::tag(":")),
                                                                                                                                                                                |k| Keyword::Colon(Colon(k)),
                                                                                                                                                                            ),
                                                                                                                                                                            nom::branch::alt((
                                                                                                                                                                                nom::combinator::map(
                                                                                                                                                                                    nom::combinator::recognize(nom::bytes::complete::tag(";")),
                                                                                                                                                                                    |k| Keyword::SemiColon(SemiColon(k)),
                                                                                                                                                                                ),
                                                                                                                                                                                nom::combinator::map(
                                                                                                                                                                                    nom::combinator::recognize(nom::bytes::complete::tag("<")),
                                                                                                                                                                                    |k| Keyword::LessThan(LessThan(k)),
                                                                                                                                                                                ),
                                                                                                                                                                                nom::branch::alt((
                                                                                                                                                                                    nom::combinator::map(
                                                                                                                                                                                        nom::combinator::recognize(nom::bytes::complete::tag("=")),
                                                                                                                                                                                        |k| Keyword::Assign(Assign(k)),
                                                                                                                                                                                    ),
                                                                                                                                                                                    nom::combinator::map(
                                                                                                                                                                                        nom::combinator::recognize(nom::bytes::complete::tag(">")),
                                                                                                                                                                                        |k| Keyword::GreaterThan(GreaterThan(k)),
                                                                                                                                                                                    ),
                                                                                                                                                                                    nom::branch::alt((
                                                                                                                                                                                        nom::combinator::map(
                                                                                                                                                                                            nom::combinator::recognize(nom::bytes::complete::tag("?")),
                                                                                                                                                                                            |k| Keyword::QuestionMark(QuestionMark(k)),
                                                                                                                                                                                        ),
                                                                                                                                                                                        nom::combinator::map(
                                                                                                                                                                                            nom::combinator::recognize(nom::bytes::complete::tag("*")),
                                                                                                                                                                                            |k| Keyword::Wildcard(Wildcard(k)),
                                                                                                                                                                                        ),
                                                                                                                                                                                    )),
                                                                                                                                                                                )),
                                                                                                                                                                            )),
                                                                                                                                                                        )),
                                                                                                                                                                    )),
                                                                                                                                                                )),
                                                                                                                                                            )),
                                                                                                                                                        )),
                                                                                                                                                    )),
                                                                                                                                                )),
                                                                                                                                            )),
                                                                                                                                        )),
                                                                                                                                    )),
                                                                                                                                )),
                                                                                                                            )),
                                                                                                                        )),
                                                                                                                    )),
                                                                                                                )),
                                                                                                            )),
                                                                                                        )),
                                                                                                    )),
                                                                                                )),
                                                                                            )),
                                                                                        )),
                                                                                    )),
                                                                                )),
                                                                            )),
                                                                        )),
                                                                    )),
                                                                )),
                                                            )),
                                                        )),
                                                    )),
                                                )),
                                            )),
                                        )),
                                    )),
                                )),
                            )),
                        )),
                    )),
                ))(input)
            }
        }
    }
    use keywords::Keyword;
    pub type NomResult<'a, O> = IResult<&'a str, O>;
    pub enum Tag<'a> {
        Kw(Keyword<'a>),
        Int(IntegerLit<'a>),
        Dec(FloatValueLit<'a>),
        Id(Identifier<'a>),
        Str(StringLit<'a>),
        Other(char),
        Eof(()),
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Tag<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Tag<'a> {
        #[inline]
        fn clone(&self) -> Tag<'a> {
            let _: ::core::clone::AssertParamIsClone<Keyword<'a>>;
            let _: ::core::clone::AssertParamIsClone<IntegerLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<FloatValueLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<Identifier<'a>>;
            let _: ::core::clone::AssertParamIsClone<StringLit<'a>>;
            let _: ::core::clone::AssertParamIsClone<char>;
            let _: ::core::clone::AssertParamIsClone<()>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Tag<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Tag::Kw(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Kw", &__self_0)
                }
                Tag::Int(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Int",
                        &__self_0,
                    )
                }
                Tag::Dec(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dec",
                        &__self_0,
                    )
                }
                Tag::Id(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Id", &__self_0)
                }
                Tag::Str(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Str",
                        &__self_0,
                    )
                }
                Tag::Other(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Other",
                        &__self_0,
                    )
                }
                Tag::Eof(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Eof",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Tag<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Tag<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Keyword<'a>>;
            let _: ::core::cmp::AssertParamIsEq<IntegerLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<FloatValueLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
            let _: ::core::cmp::AssertParamIsEq<StringLit<'a>>;
            let _: ::core::cmp::AssertParamIsEq<char>;
            let _: ::core::cmp::AssertParamIsEq<()>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Tag<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Tag<'a> {
        #[inline]
        fn eq(&self, other: &Tag<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Tag::Kw(__self_0), Tag::Kw(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Tag::Int(__self_0), Tag::Int(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Tag::Dec(__self_0), Tag::Dec(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Tag::Id(__self_0), Tag::Id(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Tag::Str(__self_0), Tag::Str(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Tag::Other(__self_0), Tag::Other(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Tag::Eof(__self_0), Tag::Eof(__arg1_0)) => *__self_0 == *__arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Tag<'a> {
        #[inline]
        fn cmp(&self, other: &Tag<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (Tag::Kw(__self_0), Tag::Kw(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Tag::Int(__self_0), Tag::Int(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Tag::Dec(__self_0), Tag::Dec(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Tag::Id(__self_0), Tag::Id(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Tag::Str(__self_0), Tag::Str(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Tag::Other(__self_0), Tag::Other(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (Tag::Eof(__self_0), Tag::Eof(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Tag<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Tag<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (Tag::Kw(__self_0), Tag::Kw(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Tag::Int(__self_0), Tag::Int(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Tag::Dec(__self_0), Tag::Dec(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Tag::Id(__self_0), Tag::Id(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Tag::Str(__self_0), Tag::Str(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Tag::Other(__self_0), Tag::Other(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (Tag::Eof(__self_0), Tag::Eof(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Tag<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Tag::Kw(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Tag::Int(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Tag::Dec(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Tag::Id(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Tag::Str(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Tag::Other(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Tag::Eof(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    pub struct Token<'a> {
        pub tag: Tag<'a>,
        pub trivia: &'a str,
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Token<'a> {
        #[inline]
        fn clone(&self) -> Token<'a> {
            let _: ::core::clone::AssertParamIsClone<Tag<'a>>;
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Token<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Token",
                "tag",
                &&self.tag,
                "trivia",
                &&self.trivia,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Token<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Tag<'a>>;
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Token<'a> {
        #[inline]
        fn eq(&self, other: &Token<'a>) -> bool {
            self.tag == other.tag && self.trivia == other.trivia
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Token<'a> {
        #[inline]
        fn cmp(&self, other: &Token<'a>) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.tag, &other.tag) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.trivia, &other.trivia)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Token<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Token<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.tag, &other.tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.trivia, &other.trivia)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Token<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.tag, state);
            ::core::hash::Hash::hash(&self.trivia, state)
        }
    }
    impl Token<'_> {
        pub fn new<'a>((trivia, tag): (&'a str, Tag<'a>)) -> Token<'a> {
            Token { tag, trivia }
        }
    }
    fn other(input: &str) -> NomResult<char> {
        nom::character::complete::satisfy(|c| {
            !"\t\n\r ".contains(c) && !c.is_alphanumeric()
        })(input)
    }
    fn token(input: &str) -> NomResult<Tag> {
        nom::branch::alt((
            nom::combinator::map(FloatValueLit::parse, Tag::Dec),
            nom::combinator::map(IntegerLit::parse, Tag::Int),
            nom::combinator::map(Keyword::parse, Tag::Kw),
            nom::combinator::map(Identifier::parse, Tag::Id),
            nom::combinator::map(StringLit::parse, Tag::Str),
            nom::combinator::map(other, Tag::Other),
        ))(input)
    }
    pub fn lex(input: &str) -> Result<Vec<Token>, nom::Err<nom::error::Error<&str>>> {
        let (unread, (mut tokens, eof)) = nom::sequence::tuple((
            many0(nom::combinator::map(nom::sequence::tuple((sp, token)), Token::new)),
            nom::combinator::map(
                nom::sequence::tuple((sp, nom::combinator::eof)),
                |(trivia, _)| Token { tag: Tag::Eof(()), trivia },
            ),
        ))(input)?;
        if !unread.is_empty() {
            ::core::panicking::panic("assertion failed: unread.is_empty()")
        }
        tokens.push(eof);
        Ok(tokens)
    }
}
pub mod parser {
    mod impl_nom_traits {
        use std::{
            iter::{Copied, Enumerate},
            ops::{Range, RangeFrom, RangeFull, RangeTo},
        };
        use nom::{InputIter, InputLength, InputTake, Needed, Slice};
        use crate::lexer::Token;
        pub struct Tokens<'slice, 'token>(pub &'slice [Token<'token>]);
        #[automatically_derived]
        impl<'slice, 'token> ::core::marker::Copy for Tokens<'slice, 'token> {}
        #[automatically_derived]
        impl<'slice, 'token> ::core::clone::Clone for Tokens<'slice, 'token> {
            #[inline]
            fn clone(&self) -> Tokens<'slice, 'token> {
                let _: ::core::clone::AssertParamIsClone<&'slice [Token<'token>]>;
                *self
            }
        }
        #[automatically_derived]
        impl<'slice, 'token> ::core::fmt::Debug for Tokens<'slice, 'token> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Tokens", &&self.0)
            }
        }
        #[automatically_derived]
        impl<'slice, 'token> ::core::marker::StructuralEq for Tokens<'slice, 'token> {}
        #[automatically_derived]
        impl<'slice, 'token> ::core::cmp::Eq for Tokens<'slice, 'token> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<&'slice [Token<'token>]>;
            }
        }
        #[automatically_derived]
        impl<'slice, 'token> ::core::marker::StructuralPartialEq
        for Tokens<'slice, 'token> {}
        #[automatically_derived]
        impl<'slice, 'token> ::core::cmp::PartialEq for Tokens<'slice, 'token> {
            #[inline]
            fn eq(&self, other: &Tokens<'slice, 'token>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'slice, 'token> ::core::cmp::Ord for Tokens<'slice, 'token> {
            #[inline]
            fn cmp(&self, other: &Tokens<'slice, 'token>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'slice, 'token> ::core::cmp::PartialOrd for Tokens<'slice, 'token> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Tokens<'slice, 'token>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'slice, 'token> ::core::hash::Hash for Tokens<'slice, 'token> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl<'slice, 'token> InputLength for Tokens<'slice, 'token> {
            #[inline]
            fn input_len(&self) -> usize {
                self.0.input_len()
            }
        }
        impl<'slice, 'token> InputTake for Tokens<'slice, 'token> {
            #[inline]
            fn take(&self, count: usize) -> Self {
                Self(&self.0[..count])
            }
            #[inline]
            fn take_split(&self, count: usize) -> (Self, Self) {
                let (prefix, suffix) = self.0.split_at(count);
                (Self(suffix), Self(prefix))
            }
        }
        impl<'a> InputLength for Token<'a> {
            #[inline]
            fn input_len(&self) -> usize {
                1
            }
        }
        impl<'slice, 'token> Slice<Range<usize>> for Tokens<'slice, 'token> {
            #[inline]
            fn slice(&self, range: Range<usize>) -> Self {
                Self(self.0.slice(range))
            }
        }
        impl<'slice, 'token> Slice<RangeTo<usize>> for Tokens<'slice, 'token> {
            #[inline]
            fn slice(&self, range: RangeTo<usize>) -> Self {
                Self(self.0.slice(range))
            }
        }
        impl<'slice, 'token> Slice<RangeFrom<usize>> for Tokens<'slice, 'token> {
            #[inline]
            fn slice(&self, range: RangeFrom<usize>) -> Self {
                Self(self.0.slice(range))
            }
        }
        impl<'slice, 'token> Slice<RangeFull> for Tokens<'slice, 'token> {
            #[inline]
            fn slice(&self, range: RangeFull) -> Self {
                Self(self.0.slice(range))
            }
        }
        impl<'slice, 'token> InputIter for Tokens<'slice, 'token> {
            type Item = Token<'token>;
            type Iter = Enumerate<Self::IterElem>;
            type IterElem = Copied<::std::slice::Iter<'slice, Token<'token>>>;
            #[inline]
            fn iter_indices(&self) -> Self::Iter {
                self.iter_elements().enumerate()
            }
            #[inline]
            fn iter_elements(&self) -> Self::IterElem {
                self.0.iter().copied()
            }
            #[inline]
            fn position<P>(&self, predicate: P) -> Option<usize>
            where
                P: Fn(Self::Item) -> bool,
            {
                self.0.iter().position(|b| predicate(*b))
            }
            #[inline]
            fn slice_index(&self, count: usize) -> Result<usize, Needed> {
                if self.0.len() >= count {
                    Ok(count)
                } else {
                    Err(Needed::new(count - self.0.len()))
                }
            }
        }
    }
    use impl_nom_traits::Tokens;
    #[macro_use]
    mod eat {
        use super::impl_nom_traits::Tokens;
        pub struct VariantToken<'a, T> {
            pub variant: T,
            pub trivia: &'a str,
        }
        #[automatically_derived]
        impl<'a, T: ::core::clone::Clone> ::core::clone::Clone for VariantToken<'a, T> {
            #[inline]
            fn clone(&self) -> VariantToken<'a, T> {
                VariantToken {
                    variant: ::core::clone::Clone::clone(&self.variant),
                    trivia: ::core::clone::Clone::clone(&self.trivia),
                }
            }
        }
        #[automatically_derived]
        impl<'a, T: ::core::fmt::Debug> ::core::fmt::Debug for VariantToken<'a, T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "VariantToken",
                    "variant",
                    &&self.variant,
                    "trivia",
                    &&self.trivia,
                )
            }
        }
        #[automatically_derived]
        impl<'a, T> ::core::marker::StructuralEq for VariantToken<'a, T> {}
        #[automatically_derived]
        impl<'a, T: ::core::cmp::Eq> ::core::cmp::Eq for VariantToken<'a, T> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<T>;
                let _: ::core::cmp::AssertParamIsEq<&'a str>;
            }
        }
        #[automatically_derived]
        impl<'a, T> ::core::marker::StructuralPartialEq for VariantToken<'a, T> {}
        #[automatically_derived]
        impl<'a, T: ::core::cmp::PartialEq> ::core::cmp::PartialEq
        for VariantToken<'a, T> {
            #[inline]
            fn eq(&self, other: &VariantToken<'a, T>) -> bool {
                self.variant == other.variant && self.trivia == other.trivia
            }
        }
        #[automatically_derived]
        impl<'a, T: ::core::cmp::Ord> ::core::cmp::Ord for VariantToken<'a, T> {
            #[inline]
            fn cmp(&self, other: &VariantToken<'a, T>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.variant, &other.variant) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.trivia, &other.trivia)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a, T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd
        for VariantToken<'a, T> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &VariantToken<'a, T>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.variant,
                    &other.variant,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(&self.trivia, &other.trivia)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a, T: ::core::hash::Hash> ::core::hash::Hash for VariantToken<'a, T> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.variant, state);
                ::core::hash::Hash::hash(&self.trivia, state)
            }
        }
        pub fn annotate<'slice, 'token, F, R>(f: F) -> F
        where
            F: Fn(Tokens<'slice, 'token>) -> nom::IResult<Tokens<'slice, 'token>, R>,
            'token: 'slice,
        {
            f
        }
    }
    #[macro_use]
    mod generate_match_test {}
    mod extended_attributes {
        use nom::{IResult, Parser};
        use super::{eat::VariantToken, impl_nom_traits::Tokens};
        use crate::{common::Identifier, lexer::keywords};
        pub struct ExtendedAttributeNoArgs<'a>(pub VariantToken<'a, Identifier<'a>>);
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for ExtendedAttributeNoArgs<'a> {
            #[inline]
            fn clone(&self) -> ExtendedAttributeNoArgs<'a> {
                ExtendedAttributeNoArgs(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for ExtendedAttributeNoArgs<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ExtendedAttributeNoArgs",
                    &&self.0,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for ExtendedAttributeNoArgs<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for ExtendedAttributeNoArgs<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeNoArgs<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for ExtendedAttributeNoArgs<'a> {
            #[inline]
            fn eq(&self, other: &ExtendedAttributeNoArgs<'a>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for ExtendedAttributeNoArgs<'a> {
            #[inline]
            fn cmp(&self, other: &ExtendedAttributeNoArgs<'a>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeNoArgs<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ExtendedAttributeNoArgs<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for ExtendedAttributeNoArgs<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        pub enum ExtendedAttribute<'a> {
            NoArgs(ExtendedAttributeNoArgs<'a>),
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for ExtendedAttribute<'a> {
            #[inline]
            fn clone(&self) -> ExtendedAttribute<'a> {
                match self {
                    ExtendedAttribute::NoArgs(__self_0) => {
                        ExtendedAttribute::NoArgs(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for ExtendedAttribute<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ExtendedAttribute::NoArgs(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "NoArgs",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for ExtendedAttribute<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for ExtendedAttribute<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ExtendedAttributeNoArgs<'a>>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttribute<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for ExtendedAttribute<'a> {
            #[inline]
            fn eq(&self, other: &ExtendedAttribute<'a>) -> bool {
                match (self, other) {
                    (
                        ExtendedAttribute::NoArgs(__self_0),
                        ExtendedAttribute::NoArgs(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for ExtendedAttribute<'a> {
            #[inline]
            fn cmp(&self, other: &ExtendedAttribute<'a>) -> ::core::cmp::Ordering {
                match (self, other) {
                    (
                        ExtendedAttribute::NoArgs(__self_0),
                        ExtendedAttribute::NoArgs(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for ExtendedAttribute<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ExtendedAttribute<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match (self, other) {
                    (
                        ExtendedAttribute::NoArgs(__self_0),
                        ExtendedAttribute::NoArgs(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for ExtendedAttribute<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match self {
                    ExtendedAttribute::NoArgs(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        pub struct ExtendedAttributeList<'a> {
            pub open_bracket: VariantToken<'a, keywords::OpenBracket<'a>>,
            pub body: Vec<ExtendedAttribute<'a>>,
            pub close_bracket: VariantToken<'a, keywords::CloseBracket<'a>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for ExtendedAttributeList<'a> {
            #[inline]
            fn clone(&self) -> ExtendedAttributeList<'a> {
                ExtendedAttributeList {
                    open_bracket: ::core::clone::Clone::clone(&self.open_bracket),
                    body: ::core::clone::Clone::clone(&self.body),
                    close_bracket: ::core::clone::Clone::clone(&self.close_bracket),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for ExtendedAttributeList<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ExtendedAttributeList",
                    "open_bracket",
                    &&self.open_bracket,
                    "body",
                    &&self.body,
                    "close_bracket",
                    &&self.close_bracket,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for ExtendedAttributeList<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for ExtendedAttributeList<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::OpenBracket<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<Vec<ExtendedAttribute<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::CloseBracket<'a>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for ExtendedAttributeList<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for ExtendedAttributeList<'a> {
            #[inline]
            fn eq(&self, other: &ExtendedAttributeList<'a>) -> bool {
                self.open_bracket == other.open_bracket && self.body == other.body
                    && self.close_bracket == other.close_bracket
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for ExtendedAttributeList<'a> {
            #[inline]
            fn cmp(&self, other: &ExtendedAttributeList<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.open_bracket, &other.open_bracket) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                            ::core::cmp::Ordering::Equal => {
                                ::core::cmp::Ord::cmp(
                                    &self.close_bracket,
                                    &other.close_bracket,
                                )
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for ExtendedAttributeList<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ExtendedAttributeList<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.open_bracket,
                    &other.open_bracket,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.body,
                            &other.body,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &self.close_bracket,
                                    &other.close_bracket,
                                )
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for ExtendedAttributeList<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.open_bracket, state);
                ::core::hash::Hash::hash(&self.body, state);
                ::core::hash::Hash::hash(&self.close_bracket, state)
            }
        }
        impl ExtendedAttributeList<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, ExtendedAttributeList<'token>> {
                let (remaining, (open_bracket, body, close_bracket, _)) = nom::sequence::tuple((
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::OpenBracket(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    nom::multi::separated_list1(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Comma(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                        nom::branch::alt((
                            crate::parser::eat::annotate(|
                                    input: Tokens,
                                | -> IResult<Tokens, _> {
                                    use nom::{InputIter, Slice};
                                    match input.iter_elements().next() {
                                        Some(
                                            crate::lexer::Token {
                                                tag: crate::lexer::Tag::Id(variant),
                                                trivia,
                                            },
                                        ) => {
                                            Ok((
                                                input.slice(1..),
                                                crate::parser::eat::VariantToken {
                                                    variant,
                                                    trivia,
                                                },
                                            ))
                                        }
                                        _ => {
                                            Err(
                                                nom::Err::Error(nom::error::Error {
                                                    input,
                                                    code: nom::error::ErrorKind::Char,
                                                }),
                                            )
                                        }
                                    }
                                })
                                .map(ExtendedAttributeNoArgs)
                                .map(ExtendedAttribute::NoArgs),
                        )),
                    ),
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::CloseBracket(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    nom::combinator::cut(
                        nom::combinator::not(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::OpenBracket(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                    ),
                ))(tokens)?;
                Ok((
                    remaining,
                    ExtendedAttributeList {
                        open_bracket,
                        body,
                        close_bracket,
                    },
                ))
            }
        }
    }
    mod r#type {
        pub mod buffer_related_type {
            use nom::{IResult, Parser};
            use crate::lexer::keywords;
            use crate::parser::{eat::VariantToken, impl_nom_traits::Tokens};
            pub enum BufferRelatedType<'a> {
                ArrayBuffer(VariantToken<'a, keywords::ArrayBuffer<'a>>),
                DataView(VariantToken<'a, keywords::DataView<'a>>),
                Int8Array(VariantToken<'a, keywords::Int8Array<'a>>),
                Int16Array(VariantToken<'a, keywords::Int16Array<'a>>),
                Int32Array(VariantToken<'a, keywords::Int32Array<'a>>),
                Uint8Array(VariantToken<'a, keywords::Uint8Array<'a>>),
                Uint16Array(VariantToken<'a, keywords::Uint16Array<'a>>),
                Uint32Array(VariantToken<'a, keywords::Uint32Array<'a>>),
                Uint8ClampedArray(VariantToken<'a, keywords::Uint8ClampedArray<'a>>),
                BigInt64Array(VariantToken<'a, keywords::BigInt64Array<'a>>),
                BigUint64Array(VariantToken<'a, keywords::BigUint64Array<'a>>),
                Float32Array(VariantToken<'a, keywords::Float32Array<'a>>),
                Float64Array(VariantToken<'a, keywords::Float64Array<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for BufferRelatedType<'a> {
                #[inline]
                fn clone(&self) -> BufferRelatedType<'a> {
                    match self {
                        BufferRelatedType::ArrayBuffer(__self_0) => {
                            BufferRelatedType::ArrayBuffer(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::DataView(__self_0) => {
                            BufferRelatedType::DataView(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Int8Array(__self_0) => {
                            BufferRelatedType::Int8Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Int16Array(__self_0) => {
                            BufferRelatedType::Int16Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Int32Array(__self_0) => {
                            BufferRelatedType::Int32Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Uint8Array(__self_0) => {
                            BufferRelatedType::Uint8Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Uint16Array(__self_0) => {
                            BufferRelatedType::Uint16Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Uint32Array(__self_0) => {
                            BufferRelatedType::Uint32Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Uint8ClampedArray(__self_0) => {
                            BufferRelatedType::Uint8ClampedArray(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::BigInt64Array(__self_0) => {
                            BufferRelatedType::BigInt64Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::BigUint64Array(__self_0) => {
                            BufferRelatedType::BigUint64Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Float32Array(__self_0) => {
                            BufferRelatedType::Float32Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        BufferRelatedType::Float64Array(__self_0) => {
                            BufferRelatedType::Float64Array(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for BufferRelatedType<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        BufferRelatedType::ArrayBuffer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "ArrayBuffer",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::DataView(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "DataView",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Int8Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Int8Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Int16Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Int16Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Int32Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Int32Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Uint8Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uint8Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Uint16Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uint16Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Uint32Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uint32Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Uint8ClampedArray(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Uint8ClampedArray",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::BigInt64Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "BigInt64Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::BigUint64Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "BigUint64Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Float32Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Float32Array",
                                &__self_0,
                            )
                        }
                        BufferRelatedType::Float64Array(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Float64Array",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for BufferRelatedType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for BufferRelatedType<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::ArrayBuffer<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::DataView<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Int8Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Int16Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Int32Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Uint8Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Uint16Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Uint32Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Uint8ClampedArray<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::BigInt64Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::BigUint64Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Float32Array<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Float64Array<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for BufferRelatedType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for BufferRelatedType<'a> {
                #[inline]
                fn eq(&self, other: &BufferRelatedType<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                BufferRelatedType::ArrayBuffer(__self_0),
                                BufferRelatedType::ArrayBuffer(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::DataView(__self_0),
                                BufferRelatedType::DataView(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Int8Array(__self_0),
                                BufferRelatedType::Int8Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Int16Array(__self_0),
                                BufferRelatedType::Int16Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Int32Array(__self_0),
                                BufferRelatedType::Int32Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Uint8Array(__self_0),
                                BufferRelatedType::Uint8Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Uint16Array(__self_0),
                                BufferRelatedType::Uint16Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Uint32Array(__self_0),
                                BufferRelatedType::Uint32Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Uint8ClampedArray(__self_0),
                                BufferRelatedType::Uint8ClampedArray(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::BigInt64Array(__self_0),
                                BufferRelatedType::BigInt64Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::BigUint64Array(__self_0),
                                BufferRelatedType::BigUint64Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Float32Array(__self_0),
                                BufferRelatedType::Float32Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                BufferRelatedType::Float64Array(__self_0),
                                BufferRelatedType::Float64Array(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for BufferRelatedType<'a> {
                #[inline]
                fn cmp(&self, other: &BufferRelatedType<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (
                                    BufferRelatedType::ArrayBuffer(__self_0),
                                    BufferRelatedType::ArrayBuffer(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::DataView(__self_0),
                                    BufferRelatedType::DataView(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Int8Array(__self_0),
                                    BufferRelatedType::Int8Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Int16Array(__self_0),
                                    BufferRelatedType::Int16Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Int32Array(__self_0),
                                    BufferRelatedType::Int32Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Uint8Array(__self_0),
                                    BufferRelatedType::Uint8Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Uint16Array(__self_0),
                                    BufferRelatedType::Uint16Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Uint32Array(__self_0),
                                    BufferRelatedType::Uint32Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Uint8ClampedArray(__self_0),
                                    BufferRelatedType::Uint8ClampedArray(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::BigInt64Array(__self_0),
                                    BufferRelatedType::BigInt64Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::BigUint64Array(__self_0),
                                    BufferRelatedType::BigUint64Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Float32Array(__self_0),
                                    BufferRelatedType::Float32Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    BufferRelatedType::Float64Array(__self_0),
                                    BufferRelatedType::Float64Array(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for BufferRelatedType<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &BufferRelatedType<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (
                                    BufferRelatedType::ArrayBuffer(__self_0),
                                    BufferRelatedType::ArrayBuffer(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::DataView(__self_0),
                                    BufferRelatedType::DataView(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Int8Array(__self_0),
                                    BufferRelatedType::Int8Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Int16Array(__self_0),
                                    BufferRelatedType::Int16Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Int32Array(__self_0),
                                    BufferRelatedType::Int32Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Uint8Array(__self_0),
                                    BufferRelatedType::Uint8Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Uint16Array(__self_0),
                                    BufferRelatedType::Uint16Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Uint32Array(__self_0),
                                    BufferRelatedType::Uint32Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Uint8ClampedArray(__self_0),
                                    BufferRelatedType::Uint8ClampedArray(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::BigInt64Array(__self_0),
                                    BufferRelatedType::BigInt64Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::BigUint64Array(__self_0),
                                    BufferRelatedType::BigUint64Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Float32Array(__self_0),
                                    BufferRelatedType::Float32Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BufferRelatedType::Float64Array(__self_0),
                                    BufferRelatedType::Float64Array(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for BufferRelatedType<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        BufferRelatedType::ArrayBuffer(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::DataView(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Int8Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Int16Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Int32Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Uint8Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Uint16Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Uint32Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Uint8ClampedArray(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::BigInt64Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::BigUint64Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Float32Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BufferRelatedType::Float64Array(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl BufferRelatedType<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, BufferRelatedType<'token>> {
                    nom::branch::alt((
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::ArrayBuffer(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::ArrayBuffer),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::DataView(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::DataView),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Int8Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Int8Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Int16Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Int16Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Int32Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Int32Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Uint8Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Uint8Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Uint16Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Uint16Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Uint32Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Uint32Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Uint8ClampedArray(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Uint8ClampedArray),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::BigInt64Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::BigInt64Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::BigUint64Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::BigUint64Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Float32Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Float32Array),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Float64Array(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BufferRelatedType::Float64Array),
                    ))(tokens)
                }
            }
        }
        pub mod primitive_type {
            use nom::{IResult, Parser};
            use crate::lexer::keywords;
            use crate::parser::{eat::VariantToken, impl_nom_traits::Tokens};
            pub enum IntegerSize<'a> {
                LongLong(
                    (
                        VariantToken<'a, keywords::Long<'a>>,
                        VariantToken<'a, keywords::Long<'a>>,
                    ),
                ),
                Long(VariantToken<'a, keywords::Long<'a>>),
                Short(VariantToken<'a, keywords::Short<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for IntegerSize<'a> {
                #[inline]
                fn clone(&self) -> IntegerSize<'a> {
                    match self {
                        IntegerSize::LongLong(__self_0) => {
                            IntegerSize::LongLong(::core::clone::Clone::clone(__self_0))
                        }
                        IntegerSize::Long(__self_0) => {
                            IntegerSize::Long(::core::clone::Clone::clone(__self_0))
                        }
                        IntegerSize::Short(__self_0) => {
                            IntegerSize::Short(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for IntegerSize<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        IntegerSize::LongLong(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "LongLong",
                                &__self_0,
                            )
                        }
                        IntegerSize::Long(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Long",
                                &__self_0,
                            )
                        }
                        IntegerSize::Short(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Short",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for IntegerSize<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for IntegerSize<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        (
                            VariantToken<'a, keywords::Long<'a>>,
                            VariantToken<'a, keywords::Long<'a>>,
                        ),
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Long<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Short<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for IntegerSize<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for IntegerSize<'a> {
                #[inline]
                fn eq(&self, other: &IntegerSize<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                IntegerSize::LongLong(__self_0),
                                IntegerSize::LongLong(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                IntegerSize::Long(__self_0),
                                IntegerSize::Long(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                IntegerSize::Short(__self_0),
                                IntegerSize::Short(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for IntegerSize<'a> {
                #[inline]
                fn cmp(&self, other: &IntegerSize<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (
                                    IntegerSize::LongLong(__self_0),
                                    IntegerSize::LongLong(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    IntegerSize::Long(__self_0),
                                    IntegerSize::Long(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    IntegerSize::Short(__self_0),
                                    IntegerSize::Short(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for IntegerSize<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &IntegerSize<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (
                                    IntegerSize::LongLong(__self_0),
                                    IntegerSize::LongLong(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    IntegerSize::Long(__self_0),
                                    IntegerSize::Long(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    IntegerSize::Short(__self_0),
                                    IntegerSize::Short(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for IntegerSize<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        IntegerSize::LongLong(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        IntegerSize::Long(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        IntegerSize::Short(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl IntegerSize<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, IntegerSize<'token>> {
                    nom::branch::alt((
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Short(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(IntegerSize::Short),
                        nom::sequence::tuple((
                                crate::parser::eat::annotate(|
                                    input: Tokens,
                                | -> IResult<Tokens, _> {
                                    use crate::lexer::{keywords::Keyword, Tag};
                                    use nom::{InputIter, Slice};
                                    match input.iter_elements().next() {
                                        Some(
                                            crate::lexer::Token {
                                                tag: Tag::Kw(Keyword::Long(variant)),
                                                trivia,
                                            },
                                        ) => {
                                            Ok((
                                                input.slice(1..),
                                                crate::parser::eat::VariantToken {
                                                    variant,
                                                    trivia,
                                                },
                                            ))
                                        }
                                        _ => {
                                            Err(
                                                nom::Err::Error(nom::error::Error {
                                                    input,
                                                    code: nom::error::ErrorKind::Char,
                                                }),
                                            )
                                        }
                                    }
                                }),
                                nom::combinator::opt(
                                    crate::parser::eat::annotate(|
                                        input: Tokens,
                                    | -> IResult<Tokens, _> {
                                        use crate::lexer::{keywords::Keyword, Tag};
                                        use nom::{InputIter, Slice};
                                        match input.iter_elements().next() {
                                            Some(
                                                crate::lexer::Token {
                                                    tag: Tag::Kw(Keyword::Long(variant)),
                                                    trivia,
                                                },
                                            ) => {
                                                Ok((
                                                    input.slice(1..),
                                                    crate::parser::eat::VariantToken {
                                                        variant,
                                                        trivia,
                                                    },
                                                ))
                                            }
                                            _ => {
                                                Err(
                                                    nom::Err::Error(nom::error::Error {
                                                        input,
                                                        code: nom::error::ErrorKind::Char,
                                                    }),
                                                )
                                            }
                                        }
                                    }),
                                ),
                            ))
                            .map(|(long, long_long)| match long_long {
                                Some(long_long) => IntegerSize::LongLong((long, long_long)),
                                None => IntegerSize::Long(long),
                            }),
                    ))(tokens)
                }
            }
            pub struct IntegerType<'a> {
                pub unsigned: Option<VariantToken<'a, keywords::Unsigned<'a>>>,
                pub size: IntegerSize<'a>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for IntegerType<'a> {
                #[inline]
                fn clone(&self) -> IntegerType<'a> {
                    IntegerType {
                        unsigned: ::core::clone::Clone::clone(&self.unsigned),
                        size: ::core::clone::Clone::clone(&self.size),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for IntegerType<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "IntegerType",
                        "unsigned",
                        &&self.unsigned,
                        "size",
                        &&self.size,
                    )
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for IntegerType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for IntegerType<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        Option<VariantToken<'a, keywords::Unsigned<'a>>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<IntegerSize<'a>>;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for IntegerType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for IntegerType<'a> {
                #[inline]
                fn eq(&self, other: &IntegerType<'a>) -> bool {
                    self.unsigned == other.unsigned && self.size == other.size
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for IntegerType<'a> {
                #[inline]
                fn cmp(&self, other: &IntegerType<'a>) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(&self.unsigned, &other.unsigned) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.size, &other.size)
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for IntegerType<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &IntegerType<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.unsigned,
                        &other.unsigned,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.size, &other.size)
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for IntegerType<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.unsigned, state);
                    ::core::hash::Hash::hash(&self.size, state)
                }
            }
            impl IntegerType<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, IntegerType<'token>> {
                    nom::branch::alt((
                        nom::sequence::tuple((
                                crate::parser::eat::annotate(|
                                    input: Tokens,
                                | -> IResult<Tokens, _> {
                                    use crate::lexer::{keywords::Keyword, Tag};
                                    use nom::{InputIter, Slice};
                                    match input.iter_elements().next() {
                                        Some(
                                            crate::lexer::Token {
                                                tag: Tag::Kw(Keyword::Unsigned(variant)),
                                                trivia,
                                            },
                                        ) => {
                                            Ok((
                                                input.slice(1..),
                                                crate::parser::eat::VariantToken {
                                                    variant,
                                                    trivia,
                                                },
                                            ))
                                        }
                                        _ => {
                                            Err(
                                                nom::Err::Error(nom::error::Error {
                                                    input,
                                                    code: nom::error::ErrorKind::Char,
                                                }),
                                            )
                                        }
                                    }
                                }),
                                nom::combinator::cut(IntegerSize::parse),
                            ))
                            .map(|(unsigned, size)| IntegerType {
                                unsigned: Some(unsigned),
                                size,
                            }),
                        IntegerSize::parse
                            .map(|size| IntegerType {
                                unsigned: None,
                                size,
                            }),
                    ))(tokens)
                }
            }
            pub enum FloatSize<'a> {
                Float(VariantToken<'a, keywords::Float<'a>>),
                Double(VariantToken<'a, keywords::Double<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for FloatSize<'a> {
                #[inline]
                fn clone(&self) -> FloatSize<'a> {
                    match self {
                        FloatSize::Float(__self_0) => {
                            FloatSize::Float(::core::clone::Clone::clone(__self_0))
                        }
                        FloatSize::Double(__self_0) => {
                            FloatSize::Double(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for FloatSize<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        FloatSize::Float(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Float",
                                &__self_0,
                            )
                        }
                        FloatSize::Double(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Double",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for FloatSize<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for FloatSize<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Float<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Double<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for FloatSize<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for FloatSize<'a> {
                #[inline]
                fn eq(&self, other: &FloatSize<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (FloatSize::Float(__self_0), FloatSize::Float(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            (
                                FloatSize::Double(__self_0),
                                FloatSize::Double(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for FloatSize<'a> {
                #[inline]
                fn cmp(&self, other: &FloatSize<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (FloatSize::Float(__self_0), FloatSize::Float(__arg1_0)) => {
                                    ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                                }
                                (
                                    FloatSize::Double(__self_0),
                                    FloatSize::Double(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for FloatSize<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &FloatSize<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (FloatSize::Float(__self_0), FloatSize::Float(__arg1_0)) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    FloatSize::Double(__self_0),
                                    FloatSize::Double(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for FloatSize<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        FloatSize::Float(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        FloatSize::Double(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl FloatSize<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, FloatSize<'token>> {
                    nom::branch::alt((
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Float(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(FloatSize::Float),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Double(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(FloatSize::Double),
                    ))(tokens)
                }
            }
            pub struct FloatType<'a> {
                pub unrestricted: Option<VariantToken<'a, keywords::Unrestricted<'a>>>,
                pub size: FloatSize<'a>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for FloatType<'a> {
                #[inline]
                fn clone(&self) -> FloatType<'a> {
                    FloatType {
                        unrestricted: ::core::clone::Clone::clone(&self.unrestricted),
                        size: ::core::clone::Clone::clone(&self.size),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for FloatType<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "FloatType",
                        "unrestricted",
                        &&self.unrestricted,
                        "size",
                        &&self.size,
                    )
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for FloatType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for FloatType<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        Option<VariantToken<'a, keywords::Unrestricted<'a>>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<FloatSize<'a>>;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for FloatType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for FloatType<'a> {
                #[inline]
                fn eq(&self, other: &FloatType<'a>) -> bool {
                    self.unrestricted == other.unrestricted && self.size == other.size
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for FloatType<'a> {
                #[inline]
                fn cmp(&self, other: &FloatType<'a>) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(
                        &self.unrestricted,
                        &other.unrestricted,
                    ) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.size, &other.size)
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for FloatType<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &FloatType<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.unrestricted,
                        &other.unrestricted,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.size, &other.size)
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for FloatType<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.unrestricted, state);
                    ::core::hash::Hash::hash(&self.size, state)
                }
            }
            impl FloatType<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, FloatType<'token>> {
                    nom::branch::alt((
                        nom::sequence::tuple((
                                crate::parser::eat::annotate(|
                                    input: Tokens,
                                | -> IResult<Tokens, _> {
                                    use crate::lexer::{keywords::Keyword, Tag};
                                    use nom::{InputIter, Slice};
                                    match input.iter_elements().next() {
                                        Some(
                                            crate::lexer::Token {
                                                tag: Tag::Kw(Keyword::Unrestricted(variant)),
                                                trivia,
                                            },
                                        ) => {
                                            Ok((
                                                input.slice(1..),
                                                crate::parser::eat::VariantToken {
                                                    variant,
                                                    trivia,
                                                },
                                            ))
                                        }
                                        _ => {
                                            Err(
                                                nom::Err::Error(nom::error::Error {
                                                    input,
                                                    code: nom::error::ErrorKind::Char,
                                                }),
                                            )
                                        }
                                    }
                                }),
                                nom::combinator::cut(FloatSize::parse),
                            ))
                            .map(|(unrestricted, size)| FloatType {
                                unrestricted: Some(unrestricted),
                                size,
                            }),
                        FloatSize::parse
                            .map(|size| FloatType {
                                unrestricted: None,
                                size,
                            }),
                    ))(tokens)
                }
            }
            pub enum PrimitiveType<'a> {
                Integer(IntegerType<'a>),
                Float(FloatType<'a>),
                Boolean(VariantToken<'a, keywords::Boolean<'a>>),
                Byte(VariantToken<'a, keywords::Byte<'a>>),
                Octet(VariantToken<'a, keywords::Octet<'a>>),
                Bigint(VariantToken<'a, keywords::Bigint<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for PrimitiveType<'a> {
                #[inline]
                fn clone(&self) -> PrimitiveType<'a> {
                    match self {
                        PrimitiveType::Integer(__self_0) => {
                            PrimitiveType::Integer(::core::clone::Clone::clone(__self_0))
                        }
                        PrimitiveType::Float(__self_0) => {
                            PrimitiveType::Float(::core::clone::Clone::clone(__self_0))
                        }
                        PrimitiveType::Boolean(__self_0) => {
                            PrimitiveType::Boolean(::core::clone::Clone::clone(__self_0))
                        }
                        PrimitiveType::Byte(__self_0) => {
                            PrimitiveType::Byte(::core::clone::Clone::clone(__self_0))
                        }
                        PrimitiveType::Octet(__self_0) => {
                            PrimitiveType::Octet(::core::clone::Clone::clone(__self_0))
                        }
                        PrimitiveType::Bigint(__self_0) => {
                            PrimitiveType::Bigint(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for PrimitiveType<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        PrimitiveType::Integer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Integer",
                                &__self_0,
                            )
                        }
                        PrimitiveType::Float(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Float",
                                &__self_0,
                            )
                        }
                        PrimitiveType::Boolean(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Boolean",
                                &__self_0,
                            )
                        }
                        PrimitiveType::Byte(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Byte",
                                &__self_0,
                            )
                        }
                        PrimitiveType::Octet(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Octet",
                                &__self_0,
                            )
                        }
                        PrimitiveType::Bigint(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Bigint",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for PrimitiveType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for PrimitiveType<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<IntegerType<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<FloatType<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Boolean<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Byte<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Octet<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Bigint<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for PrimitiveType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for PrimitiveType<'a> {
                #[inline]
                fn eq(&self, other: &PrimitiveType<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                PrimitiveType::Integer(__self_0),
                                PrimitiveType::Integer(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                PrimitiveType::Float(__self_0),
                                PrimitiveType::Float(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                PrimitiveType::Boolean(__self_0),
                                PrimitiveType::Boolean(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                PrimitiveType::Byte(__self_0),
                                PrimitiveType::Byte(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                PrimitiveType::Octet(__self_0),
                                PrimitiveType::Octet(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                PrimitiveType::Bigint(__self_0),
                                PrimitiveType::Bigint(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for PrimitiveType<'a> {
                #[inline]
                fn cmp(&self, other: &PrimitiveType<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (
                                    PrimitiveType::Integer(__self_0),
                                    PrimitiveType::Integer(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    PrimitiveType::Float(__self_0),
                                    PrimitiveType::Float(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    PrimitiveType::Boolean(__self_0),
                                    PrimitiveType::Boolean(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    PrimitiveType::Byte(__self_0),
                                    PrimitiveType::Byte(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    PrimitiveType::Octet(__self_0),
                                    PrimitiveType::Octet(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    PrimitiveType::Bigint(__self_0),
                                    PrimitiveType::Bigint(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for PrimitiveType<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &PrimitiveType<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (
                                    PrimitiveType::Integer(__self_0),
                                    PrimitiveType::Integer(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    PrimitiveType::Float(__self_0),
                                    PrimitiveType::Float(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    PrimitiveType::Boolean(__self_0),
                                    PrimitiveType::Boolean(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    PrimitiveType::Byte(__self_0),
                                    PrimitiveType::Byte(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    PrimitiveType::Octet(__self_0),
                                    PrimitiveType::Octet(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    PrimitiveType::Bigint(__self_0),
                                    PrimitiveType::Bigint(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for PrimitiveType<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        PrimitiveType::Integer(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        PrimitiveType::Float(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        PrimitiveType::Boolean(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        PrimitiveType::Byte(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        PrimitiveType::Octet(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        PrimitiveType::Bigint(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl PrimitiveType<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, PrimitiveType<'token>> {
                    nom::branch::alt((
                        IntegerType::parse.map(PrimitiveType::Integer),
                        FloatType::parse.map(PrimitiveType::Float),
                        nom::combinator::map(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Boolean(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                            PrimitiveType::Boolean,
                        ),
                        nom::combinator::map(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Byte(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                            PrimitiveType::Byte,
                        ),
                        nom::combinator::map(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Octet(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                            PrimitiveType::Octet,
                        ),
                        nom::combinator::map(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Bigint(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                            PrimitiveType::Bigint,
                        ),
                    ))(tokens)
                }
            }
        }
        pub mod record_type {
            use nom::combinator::cut;
            use nom::IResult;
            use crate::lexer::keywords;
            use crate::parser::{eat::VariantToken, impl_nom_traits::Tokens};
            use super::string_type::StringType;
            use super::TypeWithExtendedAttributes;
            pub struct RecordType<'a> {
                record: VariantToken<'a, keywords::Record<'a>>,
                open_angle: VariantToken<'a, keywords::LessThan<'a>>,
                string_type: StringType<'a>,
                separator: VariantToken<'a, keywords::Comma<'a>>,
                r#type: Box<TypeWithExtendedAttributes<'a>>,
                close_angle: VariantToken<'a, keywords::GreaterThan<'a>>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for RecordType<'a> {
                #[inline]
                fn clone(&self) -> RecordType<'a> {
                    RecordType {
                        record: ::core::clone::Clone::clone(&self.record),
                        open_angle: ::core::clone::Clone::clone(&self.open_angle),
                        string_type: ::core::clone::Clone::clone(&self.string_type),
                        separator: ::core::clone::Clone::clone(&self.separator),
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        close_angle: ::core::clone::Clone::clone(&self.close_angle),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for RecordType<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "record",
                        "open_angle",
                        "string_type",
                        "separator",
                        "type",
                        "close_angle",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &&self.record,
                        &&self.open_angle,
                        &&self.string_type,
                        &&self.separator,
                        &&self.r#type,
                        &&self.close_angle,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "RecordType",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for RecordType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for RecordType<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Record<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::LessThan<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<StringType<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Comma<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        Box<TypeWithExtendedAttributes<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::GreaterThan<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for RecordType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for RecordType<'a> {
                #[inline]
                fn eq(&self, other: &RecordType<'a>) -> bool {
                    self.record == other.record && self.open_angle == other.open_angle
                        && self.string_type == other.string_type
                        && self.separator == other.separator
                        && self.r#type == other.r#type
                        && self.close_angle == other.close_angle
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for RecordType<'a> {
                #[inline]
                fn cmp(&self, other: &RecordType<'a>) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(&self.record, &other.record) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.open_angle,
                                &other.open_angle,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.string_type,
                                        &other.string_type,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.separator,
                                                &other.separator,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(&self.r#type, &other.r#type) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.close_angle, &other.close_angle)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for RecordType<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &RecordType<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.record,
                        &other.record,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.open_angle,
                                &other.open_angle,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.string_type,
                                        &other.string_type,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.separator,
                                                &other.separator,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.r#type,
                                                        &other.r#type,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.close_angle,
                                                                &other.close_angle,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for RecordType<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.record, state);
                    ::core::hash::Hash::hash(&self.open_angle, state);
                    ::core::hash::Hash::hash(&self.string_type, state);
                    ::core::hash::Hash::hash(&self.separator, state);
                    ::core::hash::Hash::hash(&self.r#type, state);
                    ::core::hash::Hash::hash(&self.close_angle, state)
                }
            }
            impl RecordType<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, RecordType<'token>> {
                    let (
                        tokens,
                        (record, open_angle, string_type, separator, r#type, close_angle),
                    ) = nom::sequence::tuple((
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Record(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                        cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::LessThan(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                        cut(StringType::parse),
                        cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Comma(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                        cut(TypeWithExtendedAttributes::parse),
                        cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::GreaterThan(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                    ))(tokens)?;
                    Ok((
                        tokens,
                        RecordType {
                            record,
                            open_angle,
                            string_type,
                            separator,
                            r#type: Box::new(r#type),
                            close_angle,
                        },
                    ))
                }
            }
        }
        pub mod sequence_type {
            use nom::combinator::cut;
            use nom::{IResult, Parser};
            use crate::lexer::keywords;
            use crate::parser::{eat::VariantToken, impl_nom_traits::Tokens};
            use super::TypeWithExtendedAttributes;
            pub enum SequenceToken<'a> {
                Sequence(VariantToken<'a, keywords::Sequence<'a>>),
                FrozenArray(VariantToken<'a, keywords::FrozenArray<'a>>),
                ObservableArray(VariantToken<'a, keywords::ObservableArray<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for SequenceToken<'a> {
                #[inline]
                fn clone(&self) -> SequenceToken<'a> {
                    match self {
                        SequenceToken::Sequence(__self_0) => {
                            SequenceToken::Sequence(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        SequenceToken::FrozenArray(__self_0) => {
                            SequenceToken::FrozenArray(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        SequenceToken::ObservableArray(__self_0) => {
                            SequenceToken::ObservableArray(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for SequenceToken<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        SequenceToken::Sequence(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Sequence",
                                &__self_0,
                            )
                        }
                        SequenceToken::FrozenArray(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FrozenArray",
                                &__self_0,
                            )
                        }
                        SequenceToken::ObservableArray(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "ObservableArray",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for SequenceToken<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for SequenceToken<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Sequence<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::FrozenArray<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::ObservableArray<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for SequenceToken<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for SequenceToken<'a> {
                #[inline]
                fn eq(&self, other: &SequenceToken<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                SequenceToken::Sequence(__self_0),
                                SequenceToken::Sequence(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                SequenceToken::FrozenArray(__self_0),
                                SequenceToken::FrozenArray(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                SequenceToken::ObservableArray(__self_0),
                                SequenceToken::ObservableArray(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for SequenceToken<'a> {
                #[inline]
                fn cmp(&self, other: &SequenceToken<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (
                                    SequenceToken::Sequence(__self_0),
                                    SequenceToken::Sequence(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    SequenceToken::FrozenArray(__self_0),
                                    SequenceToken::FrozenArray(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    SequenceToken::ObservableArray(__self_0),
                                    SequenceToken::ObservableArray(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for SequenceToken<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SequenceToken<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (
                                    SequenceToken::Sequence(__self_0),
                                    SequenceToken::Sequence(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    SequenceToken::FrozenArray(__self_0),
                                    SequenceToken::FrozenArray(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    SequenceToken::ObservableArray(__self_0),
                                    SequenceToken::ObservableArray(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for SequenceToken<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        SequenceToken::Sequence(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        SequenceToken::FrozenArray(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        SequenceToken::ObservableArray(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            pub struct SequenceType<'a> {
                sequence: SequenceToken<'a>,
                open_angle: VariantToken<'a, keywords::LessThan<'a>>,
                r#type: Box<TypeWithExtendedAttributes<'a>>,
                close_angle: VariantToken<'a, keywords::GreaterThan<'a>>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for SequenceType<'a> {
                #[inline]
                fn clone(&self) -> SequenceType<'a> {
                    SequenceType {
                        sequence: ::core::clone::Clone::clone(&self.sequence),
                        open_angle: ::core::clone::Clone::clone(&self.open_angle),
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        close_angle: ::core::clone::Clone::clone(&self.close_angle),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for SequenceType<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "SequenceType",
                        "sequence",
                        &&self.sequence,
                        "open_angle",
                        &&self.open_angle,
                        "type",
                        &&self.r#type,
                        "close_angle",
                        &&self.close_angle,
                    )
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for SequenceType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for SequenceType<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<SequenceToken<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::LessThan<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        Box<TypeWithExtendedAttributes<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::GreaterThan<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for SequenceType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for SequenceType<'a> {
                #[inline]
                fn eq(&self, other: &SequenceType<'a>) -> bool {
                    self.sequence == other.sequence
                        && self.open_angle == other.open_angle
                        && self.r#type == other.r#type
                        && self.close_angle == other.close_angle
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for SequenceType<'a> {
                #[inline]
                fn cmp(&self, other: &SequenceType<'a>) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(&self.sequence, &other.sequence) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.open_angle,
                                &other.open_angle,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.r#type, &other.r#type) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ord::cmp(&self.close_angle, &other.close_angle)
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for SequenceType<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SequenceType<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.sequence,
                        &other.sequence,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.open_angle,
                                &other.open_angle,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.r#type,
                                        &other.r#type,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            ::core::cmp::PartialOrd::partial_cmp(
                                                &self.close_angle,
                                                &other.close_angle,
                                            )
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for SequenceType<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.sequence, state);
                    ::core::hash::Hash::hash(&self.open_angle, state);
                    ::core::hash::Hash::hash(&self.r#type, state);
                    ::core::hash::Hash::hash(&self.close_angle, state)
                }
            }
            impl SequenceType<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, SequenceType<'token>> {
                    let (tokens, (sequence, open_angle, r#type, close_angle)) = nom::sequence::tuple((
                        nom::branch::alt((
                            crate::parser::eat::annotate(|
                                    input: Tokens,
                                | -> IResult<Tokens, _> {
                                    use crate::lexer::{keywords::Keyword, Tag};
                                    use nom::{InputIter, Slice};
                                    match input.iter_elements().next() {
                                        Some(
                                            crate::lexer::Token {
                                                tag: Tag::Kw(Keyword::Sequence(variant)),
                                                trivia,
                                            },
                                        ) => {
                                            Ok((
                                                input.slice(1..),
                                                crate::parser::eat::VariantToken {
                                                    variant,
                                                    trivia,
                                                },
                                            ))
                                        }
                                        _ => {
                                            Err(
                                                nom::Err::Error(nom::error::Error {
                                                    input,
                                                    code: nom::error::ErrorKind::Char,
                                                }),
                                            )
                                        }
                                    }
                                })
                                .map(SequenceToken::Sequence),
                            crate::parser::eat::annotate(|
                                    input: Tokens,
                                | -> IResult<Tokens, _> {
                                    use crate::lexer::{keywords::Keyword, Tag};
                                    use nom::{InputIter, Slice};
                                    match input.iter_elements().next() {
                                        Some(
                                            crate::lexer::Token {
                                                tag: Tag::Kw(Keyword::FrozenArray(variant)),
                                                trivia,
                                            },
                                        ) => {
                                            Ok((
                                                input.slice(1..),
                                                crate::parser::eat::VariantToken {
                                                    variant,
                                                    trivia,
                                                },
                                            ))
                                        }
                                        _ => {
                                            Err(
                                                nom::Err::Error(nom::error::Error {
                                                    input,
                                                    code: nom::error::ErrorKind::Char,
                                                }),
                                            )
                                        }
                                    }
                                })
                                .map(SequenceToken::FrozenArray),
                            crate::parser::eat::annotate(|
                                    input: Tokens,
                                | -> IResult<Tokens, _> {
                                    use crate::lexer::{keywords::Keyword, Tag};
                                    use nom::{InputIter, Slice};
                                    match input.iter_elements().next() {
                                        Some(
                                            crate::lexer::Token {
                                                tag: Tag::Kw(Keyword::ObservableArray(variant)),
                                                trivia,
                                            },
                                        ) => {
                                            Ok((
                                                input.slice(1..),
                                                crate::parser::eat::VariantToken {
                                                    variant,
                                                    trivia,
                                                },
                                            ))
                                        }
                                        _ => {
                                            Err(
                                                nom::Err::Error(nom::error::Error {
                                                    input,
                                                    code: nom::error::ErrorKind::Char,
                                                }),
                                            )
                                        }
                                    }
                                })
                                .map(SequenceToken::ObservableArray),
                        )),
                        cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::LessThan(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                        cut(TypeWithExtendedAttributes::parse),
                        cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::GreaterThan(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                    ))(tokens)?;
                    Ok((
                        tokens,
                        SequenceType {
                            sequence,
                            open_angle,
                            r#type: Box::new(r#type),
                            close_angle,
                        },
                    ))
                }
            }
        }
        pub mod string_type {
            use nom::{IResult, Parser};
            use crate::lexer::keywords;
            use crate::parser::{eat::VariantToken, impl_nom_traits::Tokens};
            pub enum StringType<'a> {
                Byte(VariantToken<'a, keywords::ByteString<'a>>),
                Dom(VariantToken<'a, keywords::DOMString<'a>>),
                Usv(VariantToken<'a, keywords::USVString<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for StringType<'a> {
                #[inline]
                fn clone(&self) -> StringType<'a> {
                    match self {
                        StringType::Byte(__self_0) => {
                            StringType::Byte(::core::clone::Clone::clone(__self_0))
                        }
                        StringType::Dom(__self_0) => {
                            StringType::Dom(::core::clone::Clone::clone(__self_0))
                        }
                        StringType::Usv(__self_0) => {
                            StringType::Usv(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for StringType<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        StringType::Byte(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Byte",
                                &__self_0,
                            )
                        }
                        StringType::Dom(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Dom",
                                &__self_0,
                            )
                        }
                        StringType::Usv(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usv",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for StringType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for StringType<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::ByteString<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::DOMString<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::USVString<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for StringType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for StringType<'a> {
                #[inline]
                fn eq(&self, other: &StringType<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (StringType::Byte(__self_0), StringType::Byte(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            (StringType::Dom(__self_0), StringType::Dom(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            (StringType::Usv(__self_0), StringType::Usv(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for StringType<'a> {
                #[inline]
                fn cmp(&self, other: &StringType<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (StringType::Byte(__self_0), StringType::Byte(__arg1_0)) => {
                                    ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                                }
                                (StringType::Dom(__self_0), StringType::Dom(__arg1_0)) => {
                                    ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                                }
                                (StringType::Usv(__self_0), StringType::Usv(__arg1_0)) => {
                                    ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for StringType<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &StringType<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (StringType::Byte(__self_0), StringType::Byte(__arg1_0)) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (StringType::Dom(__self_0), StringType::Dom(__arg1_0)) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (StringType::Usv(__self_0), StringType::Usv(__arg1_0)) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for StringType<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        StringType::Byte(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        StringType::Dom(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        StringType::Usv(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl StringType<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, StringType<'token>> {
                    nom::branch::alt((
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::ByteString(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(StringType::Byte),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::DOMString(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(StringType::Dom),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::USVString(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(StringType::Usv),
                    ))(tokens)
                }
            }
        }
        use nom::{combinator::cut, IResult, Parser};
        use crate::{common::Identifier, lexer::keywords};
        use self::{
            buffer_related_type::BufferRelatedType, primitive_type::PrimitiveType,
            record_type::RecordType, sequence_type::SequenceType, string_type::StringType,
        };
        use super::{
            eat::VariantToken, extended_attributes::ExtendedAttributeList,
            impl_nom_traits::Tokens,
        };
        pub enum DistinguishableType<'a> {
            Primitive(PrimitiveType<'a>),
            String(StringType<'a>),
            Identifier(VariantToken<'a, Identifier<'a>>),
            Sequence(SequenceType<'a>),
            Object(VariantToken<'a, keywords::Object<'a>>),
            Symbol(VariantToken<'a, keywords::Symbol<'a>>),
            BufferRelated(BufferRelatedType<'a>),
            Record(RecordType<'a>),
            Undefined(VariantToken<'a, keywords::Undefined<'a>>),
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for DistinguishableType<'a> {
            #[inline]
            fn clone(&self) -> DistinguishableType<'a> {
                match self {
                    DistinguishableType::Primitive(__self_0) => {
                        DistinguishableType::Primitive(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DistinguishableType::String(__self_0) => {
                        DistinguishableType::String(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DistinguishableType::Identifier(__self_0) => {
                        DistinguishableType::Identifier(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DistinguishableType::Sequence(__self_0) => {
                        DistinguishableType::Sequence(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DistinguishableType::Object(__self_0) => {
                        DistinguishableType::Object(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DistinguishableType::Symbol(__self_0) => {
                        DistinguishableType::Symbol(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DistinguishableType::BufferRelated(__self_0) => {
                        DistinguishableType::BufferRelated(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DistinguishableType::Record(__self_0) => {
                        DistinguishableType::Record(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DistinguishableType::Undefined(__self_0) => {
                        DistinguishableType::Undefined(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for DistinguishableType<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    DistinguishableType::Primitive(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Primitive",
                            &__self_0,
                        )
                    }
                    DistinguishableType::String(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "String",
                            &__self_0,
                        )
                    }
                    DistinguishableType::Identifier(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Identifier",
                            &__self_0,
                        )
                    }
                    DistinguishableType::Sequence(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Sequence",
                            &__self_0,
                        )
                    }
                    DistinguishableType::Object(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Object",
                            &__self_0,
                        )
                    }
                    DistinguishableType::Symbol(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Symbol",
                            &__self_0,
                        )
                    }
                    DistinguishableType::BufferRelated(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "BufferRelated",
                            &__self_0,
                        )
                    }
                    DistinguishableType::Record(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Record",
                            &__self_0,
                        )
                    }
                    DistinguishableType::Undefined(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Undefined",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for DistinguishableType<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for DistinguishableType<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<PrimitiveType<'a>>;
                let _: ::core::cmp::AssertParamIsEq<StringType<'a>>;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<SequenceType<'a>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Object<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Symbol<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<BufferRelatedType<'a>>;
                let _: ::core::cmp::AssertParamIsEq<RecordType<'a>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Undefined<'a>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for DistinguishableType<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for DistinguishableType<'a> {
            #[inline]
            fn eq(&self, other: &DistinguishableType<'a>) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            DistinguishableType::Primitive(__self_0),
                            DistinguishableType::Primitive(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DistinguishableType::String(__self_0),
                            DistinguishableType::String(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DistinguishableType::Identifier(__self_0),
                            DistinguishableType::Identifier(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DistinguishableType::Sequence(__self_0),
                            DistinguishableType::Sequence(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DistinguishableType::Object(__self_0),
                            DistinguishableType::Object(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DistinguishableType::Symbol(__self_0),
                            DistinguishableType::Symbol(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DistinguishableType::BufferRelated(__self_0),
                            DistinguishableType::BufferRelated(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DistinguishableType::Record(__self_0),
                            DistinguishableType::Record(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DistinguishableType::Undefined(__self_0),
                            DistinguishableType::Undefined(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for DistinguishableType<'a> {
            #[inline]
            fn cmp(&self, other: &DistinguishableType<'a>) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                DistinguishableType::Primitive(__self_0),
                                DistinguishableType::Primitive(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::String(__self_0),
                                DistinguishableType::String(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Identifier(__self_0),
                                DistinguishableType::Identifier(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Sequence(__self_0),
                                DistinguishableType::Sequence(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Object(__self_0),
                                DistinguishableType::Object(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Symbol(__self_0),
                                DistinguishableType::Symbol(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::BufferRelated(__self_0),
                                DistinguishableType::BufferRelated(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Record(__self_0),
                                DistinguishableType::Record(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Undefined(__self_0),
                                DistinguishableType::Undefined(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for DistinguishableType<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &DistinguishableType<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match (self, other) {
                            (
                                DistinguishableType::Primitive(__self_0),
                                DistinguishableType::Primitive(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::String(__self_0),
                                DistinguishableType::String(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Identifier(__self_0),
                                DistinguishableType::Identifier(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Sequence(__self_0),
                                DistinguishableType::Sequence(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Object(__self_0),
                                DistinguishableType::Object(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Symbol(__self_0),
                                DistinguishableType::Symbol(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::BufferRelated(__self_0),
                                DistinguishableType::BufferRelated(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Record(__self_0),
                                DistinguishableType::Record(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                DistinguishableType::Undefined(__self_0),
                                DistinguishableType::Undefined(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for DistinguishableType<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state);
                match self {
                    DistinguishableType::Primitive(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    DistinguishableType::String(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    DistinguishableType::Identifier(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    DistinguishableType::Sequence(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    DistinguishableType::Object(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    DistinguishableType::Symbol(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    DistinguishableType::BufferRelated(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    DistinguishableType::Record(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    DistinguishableType::Undefined(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        impl DistinguishableType<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, DistinguishableType<'token>> {
                nom::branch::alt((
                    PrimitiveType::parse.map(DistinguishableType::Primitive),
                    StringType::parse.map(DistinguishableType::String),
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: crate::lexer::Tag::Id(variant),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        })
                        .map(DistinguishableType::Identifier),
                    SequenceType::parse.map(DistinguishableType::Sequence),
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Object(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        })
                        .map(DistinguishableType::Object),
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Symbol(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        })
                        .map(DistinguishableType::Symbol),
                    BufferRelatedType::parse.map(DistinguishableType::BufferRelated),
                    RecordType::parse.map(DistinguishableType::Record),
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Undefined(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        })
                        .map(DistinguishableType::Undefined),
                ))(tokens)
            }
        }
        pub struct NullableType<'a> {
            pub r#type: DistinguishableType<'a>,
            pub q_mark: Option<VariantToken<'a, keywords::QuestionMark<'a>>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for NullableType<'a> {
            #[inline]
            fn clone(&self) -> NullableType<'a> {
                NullableType {
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                    q_mark: ::core::clone::Clone::clone(&self.q_mark),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for NullableType<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NullableType",
                    "type",
                    &&self.r#type,
                    "q_mark",
                    &&self.q_mark,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for NullableType<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for NullableType<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<DistinguishableType<'a>>;
                let _: ::core::cmp::AssertParamIsEq<
                    Option<VariantToken<'a, keywords::QuestionMark<'a>>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for NullableType<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for NullableType<'a> {
            #[inline]
            fn eq(&self, other: &NullableType<'a>) -> bool {
                self.r#type == other.r#type && self.q_mark == other.q_mark
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for NullableType<'a> {
            #[inline]
            fn cmp(&self, other: &NullableType<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.r#type, &other.r#type) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.q_mark, &other.q_mark)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for NullableType<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &NullableType<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.r#type, &other.r#type) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(&self.q_mark, &other.q_mark)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for NullableType<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.r#type, state);
                ::core::hash::Hash::hash(&self.q_mark, state)
            }
        }
        impl NullableType<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, NullableType<'token>> {
                let (tokens, (r#type, q_mark)) = nom::sequence::tuple((
                    DistinguishableType::parse,
                    nom::combinator::opt(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::QuestionMark(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                ))(tokens)?;
                Ok((tokens, NullableType { r#type, q_mark }))
            }
        }
        pub enum Type<'a> {
            Distinguishable(NullableType<'a>),
            Any(VariantToken<'a, keywords::Any<'a>>),
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for Type<'a> {
            #[inline]
            fn clone(&self) -> Type<'a> {
                match self {
                    Type::Distinguishable(__self_0) => {
                        Type::Distinguishable(::core::clone::Clone::clone(__self_0))
                    }
                    Type::Any(__self_0) => {
                        Type::Any(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for Type<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Type::Distinguishable(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Distinguishable",
                            &__self_0,
                        )
                    }
                    Type::Any(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Any",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for Type<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for Type<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<NullableType<'a>>;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, keywords::Any<'a>>>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for Type<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for Type<'a> {
            #[inline]
            fn eq(&self, other: &Type<'a>) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            Type::Distinguishable(__self_0),
                            Type::Distinguishable(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (Type::Any(__self_0), Type::Any(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for Type<'a> {
            #[inline]
            fn cmp(&self, other: &Type<'a>) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                Type::Distinguishable(__self_0),
                                Type::Distinguishable(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (Type::Any(__self_0), Type::Any(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for Type<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Type<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match (self, other) {
                            (
                                Type::Distinguishable(__self_0),
                                Type::Distinguishable(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (Type::Any(__self_0), Type::Any(__arg1_0)) => {
                                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for Type<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state);
                match self {
                    Type::Distinguishable(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Type::Any(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                }
            }
        }
        impl Type<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, Type<'token>> {
                nom::branch::alt((
                    NullableType::parse.map(Type::Distinguishable),
                    nom::sequence::tuple((
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Any(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                            cut(
                                nom::combinator::not(
                                    crate::parser::eat::annotate(|
                                        input: Tokens,
                                    | -> IResult<Tokens, _> {
                                        use crate::lexer::{keywords::Keyword, Tag};
                                        use nom::{InputIter, Slice};
                                        match input.iter_elements().next() {
                                            Some(
                                                crate::lexer::Token {
                                                    tag: Tag::Kw(Keyword::QuestionMark(variant)),
                                                    trivia,
                                                },
                                            ) => {
                                                Ok((
                                                    input.slice(1..),
                                                    crate::parser::eat::VariantToken {
                                                        variant,
                                                        trivia,
                                                    },
                                                ))
                                            }
                                            _ => {
                                                Err(
                                                    nom::Err::Error(nom::error::Error {
                                                        input,
                                                        code: nom::error::ErrorKind::Char,
                                                    }),
                                                )
                                            }
                                        }
                                    }),
                                ),
                            ),
                        ))
                        .map(|(any, _)| Type::Any(any)),
                ))(tokens)
            }
        }
        pub struct TypeWithExtendedAttributes<'a> {
            pub ext_attrs: Option<ExtendedAttributeList<'a>>,
            pub r#type: Type<'a>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for TypeWithExtendedAttributes<'a> {
            #[inline]
            fn clone(&self) -> TypeWithExtendedAttributes<'a> {
                TypeWithExtendedAttributes {
                    ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for TypeWithExtendedAttributes<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "TypeWithExtendedAttributes",
                    "ext_attrs",
                    &&self.ext_attrs,
                    "type",
                    &&self.r#type,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for TypeWithExtendedAttributes<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for TypeWithExtendedAttributes<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<Type<'a>>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for TypeWithExtendedAttributes<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for TypeWithExtendedAttributes<'a> {
            #[inline]
            fn eq(&self, other: &TypeWithExtendedAttributes<'a>) -> bool {
                self.ext_attrs == other.ext_attrs && self.r#type == other.r#type
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for TypeWithExtendedAttributes<'a> {
            #[inline]
            fn cmp(
                &self,
                other: &TypeWithExtendedAttributes<'a>,
            ) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.r#type, &other.r#type)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for TypeWithExtendedAttributes<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TypeWithExtendedAttributes<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.ext_attrs,
                    &other.ext_attrs,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(&self.r#type, &other.r#type)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for TypeWithExtendedAttributes<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.ext_attrs, state);
                ::core::hash::Hash::hash(&self.r#type, state)
            }
        }
        impl TypeWithExtendedAttributes<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, TypeWithExtendedAttributes<'token>> {
                let (tokens, (ext_attrs, r#type)) = nom::sequence::tuple((
                    nom::combinator::opt(ExtendedAttributeList::parse),
                    Type::parse,
                ))(tokens)?;
                Ok((
                    tokens,
                    TypeWithExtendedAttributes {
                        ext_attrs,
                        r#type,
                    },
                ))
            }
        }
    }
    mod callback {
        use nom::IResult;
        use crate::{common::Identifier, lexer::keywords};
        use super::{
            eat::VariantToken, extended_attributes::ExtendedAttributeList,
            impl_nom_traits::Tokens, r#type::DistinguishableType,
        };
        pub struct CallbackDefinition<'a> {
            pub ext_attrs: Option<ExtendedAttributeList<'a>>,
            pub callback: VariantToken<'a, keywords::Callback<'a>>,
            pub identifier: VariantToken<'a, Identifier<'a>>,
            pub assign: VariantToken<'a, keywords::Assign<'a>>,
            pub r#type: DistinguishableType<'a>,
            pub open_paren: VariantToken<'a, keywords::OpenParen<'a>>,
            pub close_paren: VariantToken<'a, keywords::CloseParen<'a>>,
            pub semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for CallbackDefinition<'a> {
            #[inline]
            fn clone(&self) -> CallbackDefinition<'a> {
                CallbackDefinition {
                    ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                    callback: ::core::clone::Clone::clone(&self.callback),
                    identifier: ::core::clone::Clone::clone(&self.identifier),
                    assign: ::core::clone::Clone::clone(&self.assign),
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                    open_paren: ::core::clone::Clone::clone(&self.open_paren),
                    close_paren: ::core::clone::Clone::clone(&self.close_paren),
                    semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for CallbackDefinition<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "ext_attrs",
                    "callback",
                    "identifier",
                    "assign",
                    "type",
                    "open_paren",
                    "close_paren",
                    "semi_colon",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &&self.ext_attrs,
                    &&self.callback,
                    &&self.identifier,
                    &&self.assign,
                    &&self.r#type,
                    &&self.open_paren,
                    &&self.close_paren,
                    &&self.semi_colon,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "CallbackDefinition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for CallbackDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for CallbackDefinition<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Callback<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Assign<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<DistinguishableType<'a>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::OpenParen<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::CloseParen<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::SemiColon<'a>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for CallbackDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for CallbackDefinition<'a> {
            #[inline]
            fn eq(&self, other: &CallbackDefinition<'a>) -> bool {
                self.ext_attrs == other.ext_attrs && self.callback == other.callback
                    && self.identifier == other.identifier && self.assign == other.assign
                    && self.r#type == other.r#type && self.open_paren == other.open_paren
                    && self.close_paren == other.close_paren
                    && self.semi_colon == other.semi_colon
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for CallbackDefinition<'a> {
            #[inline]
            fn cmp(&self, other: &CallbackDefinition<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.callback, &other.callback) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.r#type, &other.r#type) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        match ::core::cmp::Ord::cmp(
                                                            &self.open_paren,
                                                            &other.open_paren,
                                                        ) {
                                                            ::core::cmp::Ordering::Equal => {
                                                                match ::core::cmp::Ord::cmp(
                                                                    &self.close_paren,
                                                                    &other.close_paren,
                                                                ) {
                                                                    ::core::cmp::Ordering::Equal => {
                                                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                                    }
                                                                    cmp => cmp,
                                                                }
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for CallbackDefinition<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CallbackDefinition<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.ext_attrs,
                    &other.ext_attrs,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.callback,
                            &other.callback,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.assign,
                                            &other.assign,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.r#type,
                                                    &other.r#type,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        match ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.open_paren,
                                                            &other.open_paren,
                                                        ) {
                                                            ::core::option::Option::Some(
                                                                ::core::cmp::Ordering::Equal,
                                                            ) => {
                                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                                    &self.close_paren,
                                                                    &other.close_paren,
                                                                ) {
                                                                    ::core::option::Option::Some(
                                                                        ::core::cmp::Ordering::Equal,
                                                                    ) => {
                                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                                            &self.semi_colon,
                                                                            &other.semi_colon,
                                                                        )
                                                                    }
                                                                    cmp => cmp,
                                                                }
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for CallbackDefinition<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.ext_attrs, state);
                ::core::hash::Hash::hash(&self.callback, state);
                ::core::hash::Hash::hash(&self.identifier, state);
                ::core::hash::Hash::hash(&self.assign, state);
                ::core::hash::Hash::hash(&self.r#type, state);
                ::core::hash::Hash::hash(&self.open_paren, state);
                ::core::hash::Hash::hash(&self.close_paren, state);
                ::core::hash::Hash::hash(&self.semi_colon, state)
            }
        }
        impl CallbackDefinition<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, CallbackDefinition<'token>> {
                let (
                    tokens,
                    (
                        callback,
                        identifier,
                        assign,
                        r#type,
                        open_paren,
                        close_paren,
                        semi_colon,
                    ),
                ) = nom::sequence::tuple((
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::Callback(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: crate::lexer::Tag::Id(variant),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Assign(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(DistinguishableType::parse),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::OpenParen(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::CloseParen(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::SemiColon(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                ))(tokens)?;
                Ok((
                    tokens,
                    CallbackDefinition {
                        ext_attrs: None,
                        callback,
                        identifier,
                        assign,
                        r#type,
                        open_paren,
                        close_paren,
                        semi_colon,
                    },
                ))
            }
        }
    }
    mod dictionary {
        mod member {
            use nom::IResult;
            use crate::parser::extended_attributes::ExtendedAttributeList;
            use crate::parser::r#type::TypeWithExtendedAttributes;
            use crate::{common::Identifier, lexer::keywords};
            use crate::parser::{eat::VariantToken, impl_nom_traits::Tokens};
            pub struct DictionaryMember<'a> {
                pub ext_attrs: Option<ExtendedAttributeList<'a>>,
                pub required: Option<VariantToken<'a, keywords::Required<'a>>>,
                pub r#type: TypeWithExtendedAttributes<'a>,
                pub identifier: VariantToken<'a, Identifier<'a>>,
                pub semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for DictionaryMember<'a> {
                #[inline]
                fn clone(&self) -> DictionaryMember<'a> {
                    DictionaryMember {
                        ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                        required: ::core::clone::Clone::clone(&self.required),
                        r#type: ::core::clone::Clone::clone(&self.r#type),
                        identifier: ::core::clone::Clone::clone(&self.identifier),
                        semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for DictionaryMember<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "DictionaryMember",
                        "ext_attrs",
                        &&self.ext_attrs,
                        "required",
                        &&self.required,
                        "type",
                        &&self.r#type,
                        "identifier",
                        &&self.identifier,
                        "semi_colon",
                        &&self.semi_colon,
                    )
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for DictionaryMember<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for DictionaryMember<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        Option<ExtendedAttributeList<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        Option<VariantToken<'a, keywords::Required<'a>>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<TypeWithExtendedAttributes<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, Identifier<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::SemiColon<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for DictionaryMember<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for DictionaryMember<'a> {
                #[inline]
                fn eq(&self, other: &DictionaryMember<'a>) -> bool {
                    self.ext_attrs == other.ext_attrs && self.required == other.required
                        && self.r#type == other.r#type
                        && self.identifier == other.identifier
                        && self.semi_colon == other.semi_colon
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for DictionaryMember<'a> {
                #[inline]
                fn cmp(&self, other: &DictionaryMember<'a>) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.required,
                                &other.required,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.r#type, &other.r#type) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.identifier,
                                                &other.identifier,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for DictionaryMember<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &DictionaryMember<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.ext_attrs,
                        &other.ext_attrs,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.required,
                                &other.required,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.r#type,
                                        &other.r#type,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.identifier,
                                                &other.identifier,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.semi_colon,
                                                        &other.semi_colon,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for DictionaryMember<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.ext_attrs, state);
                    ::core::hash::Hash::hash(&self.required, state);
                    ::core::hash::Hash::hash(&self.r#type, state);
                    ::core::hash::Hash::hash(&self.identifier, state);
                    ::core::hash::Hash::hash(&self.semi_colon, state)
                }
            }
            impl DictionaryMember<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, DictionaryMember<'token>> {
                    let (
                        tokens,
                        (ext_attrs, required, r#type, identifier, semi_colon),
                    ) = nom::sequence::tuple((
                        nom::combinator::opt(ExtendedAttributeList::parse),
                        nom::combinator::opt(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Required(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                        nom::combinator::cut(TypeWithExtendedAttributes::parse),
                        nom::combinator::cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: crate::lexer::Tag::Id(variant),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                        nom::combinator::cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::SemiColon(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                    ))(tokens)?;
                    Ok((
                        tokens,
                        DictionaryMember {
                            ext_attrs,
                            required,
                            r#type,
                            identifier,
                            semi_colon,
                        },
                    ))
                }
            }
        }
        use nom::IResult;
        use crate::{common::Identifier, lexer::keywords};
        use self::member::DictionaryMember;
        use super::{
            eat::VariantToken, extended_attributes::ExtendedAttributeList,
            impl_nom_traits::Tokens,
        };
        pub struct DictionaryDefinition<'a> {
            pub ext_attrs: Option<ExtendedAttributeList<'a>>,
            pub dictionary: VariantToken<'a, keywords::Dictionary<'a>>,
            pub identifier: VariantToken<'a, Identifier<'a>>,
            pub open_brace: VariantToken<'a, keywords::OpenBrace<'a>>,
            pub body: Vec<DictionaryMember<'a>>,
            pub close_brace: VariantToken<'a, keywords::CloseBrace<'a>>,
            pub semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for DictionaryDefinition<'a> {
            #[inline]
            fn clone(&self) -> DictionaryDefinition<'a> {
                DictionaryDefinition {
                    ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                    identifier: ::core::clone::Clone::clone(&self.identifier),
                    open_brace: ::core::clone::Clone::clone(&self.open_brace),
                    body: ::core::clone::Clone::clone(&self.body),
                    close_brace: ::core::clone::Clone::clone(&self.close_brace),
                    semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for DictionaryDefinition<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "ext_attrs",
                    "dictionary",
                    "identifier",
                    "open_brace",
                    "body",
                    "close_brace",
                    "semi_colon",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &&self.ext_attrs,
                    &&self.dictionary,
                    &&self.identifier,
                    &&self.open_brace,
                    &&self.body,
                    &&self.close_brace,
                    &&self.semi_colon,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "DictionaryDefinition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for DictionaryDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for DictionaryDefinition<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Dictionary<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::OpenBrace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<Vec<DictionaryMember<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::CloseBrace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::SemiColon<'a>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for DictionaryDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for DictionaryDefinition<'a> {
            #[inline]
            fn eq(&self, other: &DictionaryDefinition<'a>) -> bool {
                self.ext_attrs == other.ext_attrs && self.dictionary == other.dictionary
                    && self.identifier == other.identifier
                    && self.open_brace == other.open_brace && self.body == other.body
                    && self.close_brace == other.close_brace
                    && self.semi_colon == other.semi_colon
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for DictionaryDefinition<'a> {
            #[inline]
            fn cmp(&self, other: &DictionaryDefinition<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.dictionary,
                            &other.dictionary,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.open_brace,
                                            &other.open_brace,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        match ::core::cmp::Ord::cmp(
                                                            &self.close_brace,
                                                            &other.close_brace,
                                                        ) {
                                                            ::core::cmp::Ordering::Equal => {
                                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for DictionaryDefinition<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &DictionaryDefinition<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.ext_attrs,
                    &other.ext_attrs,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.dictionary,
                            &other.dictionary,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.open_brace,
                                            &other.open_brace,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.body,
                                                    &other.body,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        match ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.close_brace,
                                                            &other.close_brace,
                                                        ) {
                                                            ::core::option::Option::Some(
                                                                ::core::cmp::Ordering::Equal,
                                                            ) => {
                                                                ::core::cmp::PartialOrd::partial_cmp(
                                                                    &self.semi_colon,
                                                                    &other.semi_colon,
                                                                )
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for DictionaryDefinition<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.ext_attrs, state);
                ::core::hash::Hash::hash(&self.dictionary, state);
                ::core::hash::Hash::hash(&self.identifier, state);
                ::core::hash::Hash::hash(&self.open_brace, state);
                ::core::hash::Hash::hash(&self.body, state);
                ::core::hash::Hash::hash(&self.close_brace, state);
                ::core::hash::Hash::hash(&self.semi_colon, state)
            }
        }
        impl DictionaryDefinition<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, DictionaryDefinition<'token>> {
                let (
                    tokens,
                    (dictionary, identifier, open_brace, members, semi_colon),
                ) = nom::sequence::tuple((
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::Dictionary(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: crate::lexer::Tag::Id(variant),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::OpenBrace(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::multi::many_till(
                        DictionaryMember::parse,
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::CloseBrace(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::SemiColon(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                ))(tokens)?;
                Ok((
                    tokens,
                    DictionaryDefinition {
                        ext_attrs: None,
                        dictionary,
                        identifier,
                        open_brace,
                        body: members.0,
                        close_brace: members.1,
                        semi_colon,
                    },
                ))
            }
        }
    }
    mod enumeration {
        use nom::IResult;
        use crate::{common::Identifier, lexer::keywords, literal::StringLit};
        use super::{
            eat::VariantToken, extended_attributes::ExtendedAttributeList,
            impl_nom_traits::Tokens,
        };
        pub struct EnumDefinition<'a> {
            pub ext_attrs: Option<ExtendedAttributeList<'a>>,
            pub r#enum: VariantToken<'a, keywords::Enum<'a>>,
            pub identifier: VariantToken<'a, Identifier<'a>>,
            pub open_brace: VariantToken<'a, keywords::OpenBrace<'a>>,
            pub body: Vec<VariantToken<'a, StringLit<'a>>>,
            pub close_brace: VariantToken<'a, keywords::CloseBrace<'a>>,
            pub semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for EnumDefinition<'a> {
            #[inline]
            fn clone(&self) -> EnumDefinition<'a> {
                EnumDefinition {
                    ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                    r#enum: ::core::clone::Clone::clone(&self.r#enum),
                    identifier: ::core::clone::Clone::clone(&self.identifier),
                    open_brace: ::core::clone::Clone::clone(&self.open_brace),
                    body: ::core::clone::Clone::clone(&self.body),
                    close_brace: ::core::clone::Clone::clone(&self.close_brace),
                    semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for EnumDefinition<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "ext_attrs",
                    "enum",
                    "identifier",
                    "open_brace",
                    "body",
                    "close_brace",
                    "semi_colon",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &&self.ext_attrs,
                    &&self.r#enum,
                    &&self.identifier,
                    &&self.open_brace,
                    &&self.body,
                    &&self.close_brace,
                    &&self.semi_colon,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "EnumDefinition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for EnumDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for EnumDefinition<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Enum<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::OpenBrace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    Vec<VariantToken<'a, StringLit<'a>>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::CloseBrace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::SemiColon<'a>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for EnumDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for EnumDefinition<'a> {
            #[inline]
            fn eq(&self, other: &EnumDefinition<'a>) -> bool {
                self.ext_attrs == other.ext_attrs && self.r#enum == other.r#enum
                    && self.identifier == other.identifier
                    && self.open_brace == other.open_brace && self.body == other.body
                    && self.close_brace == other.close_brace
                    && self.semi_colon == other.semi_colon
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for EnumDefinition<'a> {
            #[inline]
            fn cmp(&self, other: &EnumDefinition<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.r#enum, &other.r#enum) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.open_brace,
                                            &other.open_brace,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        match ::core::cmp::Ord::cmp(
                                                            &self.close_brace,
                                                            &other.close_brace,
                                                        ) {
                                                            ::core::cmp::Ordering::Equal => {
                                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for EnumDefinition<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &EnumDefinition<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.ext_attrs,
                    &other.ext_attrs,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.r#enum,
                            &other.r#enum,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.open_brace,
                                            &other.open_brace,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.body,
                                                    &other.body,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        match ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.close_brace,
                                                            &other.close_brace,
                                                        ) {
                                                            ::core::option::Option::Some(
                                                                ::core::cmp::Ordering::Equal,
                                                            ) => {
                                                                ::core::cmp::PartialOrd::partial_cmp(
                                                                    &self.semi_colon,
                                                                    &other.semi_colon,
                                                                )
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for EnumDefinition<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.ext_attrs, state);
                ::core::hash::Hash::hash(&self.r#enum, state);
                ::core::hash::Hash::hash(&self.identifier, state);
                ::core::hash::Hash::hash(&self.open_brace, state);
                ::core::hash::Hash::hash(&self.body, state);
                ::core::hash::Hash::hash(&self.close_brace, state);
                ::core::hash::Hash::hash(&self.semi_colon, state)
            }
        }
        impl EnumDefinition<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, EnumDefinition<'token>> {
                let (
                    tokens,
                    (r#enum, identifier, open_brace, body, _, close_brace, semi_colon),
                ) = nom::sequence::tuple((
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::Enum(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: crate::lexer::Tag::Id(variant),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::OpenBrace(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        nom::multi::separated_list1(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Comma(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: crate::lexer::Tag::Str(variant),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                    ),
                    nom::combinator::opt(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Comma(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::CloseBrace(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::SemiColon(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                ))(tokens)?;
                Ok((
                    tokens,
                    EnumDefinition {
                        ext_attrs: None,
                        r#enum,
                        identifier,
                        open_brace,
                        body,
                        close_brace,
                        semi_colon,
                    },
                ))
            }
        }
    }
    mod includes {
        use nom::IResult;
        use super::{
            eat::VariantToken, extended_attributes::ExtendedAttributeList,
            impl_nom_traits::Tokens,
        };
        use crate::{common::Identifier, lexer::keywords::{Includes, SemiColon}};
        pub struct IncludesStatementDefinition<'a> {
            pub ext_attrs: Option<ExtendedAttributeList<'a>>,
            pub lhs_identifier: VariantToken<'a, Identifier<'a>>,
            pub includes: VariantToken<'a, Includes<'a>>,
            pub rhs_identifier: VariantToken<'a, Identifier<'a>>,
            pub semi_colon: VariantToken<'a, SemiColon<'a>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for IncludesStatementDefinition<'a> {
            #[inline]
            fn clone(&self) -> IncludesStatementDefinition<'a> {
                IncludesStatementDefinition {
                    ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                    lhs_identifier: ::core::clone::Clone::clone(&self.lhs_identifier),
                    includes: ::core::clone::Clone::clone(&self.includes),
                    rhs_identifier: ::core::clone::Clone::clone(&self.rhs_identifier),
                    semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for IncludesStatementDefinition<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "IncludesStatementDefinition",
                    "ext_attrs",
                    &&self.ext_attrs,
                    "lhs_identifier",
                    &&self.lhs_identifier,
                    "includes",
                    &&self.includes,
                    "rhs_identifier",
                    &&self.rhs_identifier,
                    "semi_colon",
                    &&self.semi_colon,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for IncludesStatementDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for IncludesStatementDefinition<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Includes<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, SemiColon<'a>>>;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq
        for IncludesStatementDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for IncludesStatementDefinition<'a> {
            #[inline]
            fn eq(&self, other: &IncludesStatementDefinition<'a>) -> bool {
                self.ext_attrs == other.ext_attrs
                    && self.lhs_identifier == other.lhs_identifier
                    && self.includes == other.includes
                    && self.rhs_identifier == other.rhs_identifier
                    && self.semi_colon == other.semi_colon
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for IncludesStatementDefinition<'a> {
            #[inline]
            fn cmp(
                &self,
                other: &IncludesStatementDefinition<'a>,
            ) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.lhs_identifier,
                            &other.lhs_identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.includes,
                                    &other.includes,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.rhs_identifier,
                                            &other.rhs_identifier,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for IncludesStatementDefinition<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &IncludesStatementDefinition<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.ext_attrs,
                    &other.ext_attrs,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.lhs_identifier,
                            &other.lhs_identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.includes,
                                    &other.includes,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.rhs_identifier,
                                            &other.rhs_identifier,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for IncludesStatementDefinition<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.ext_attrs, state);
                ::core::hash::Hash::hash(&self.lhs_identifier, state);
                ::core::hash::Hash::hash(&self.includes, state);
                ::core::hash::Hash::hash(&self.rhs_identifier, state);
                ::core::hash::Hash::hash(&self.semi_colon, state)
            }
        }
        impl IncludesStatementDefinition<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, IncludesStatementDefinition<'token>> {
                let (
                    remaining,
                    (lhs_identifier, includes, rhs_identifier, termination),
                ) = nom::sequence::tuple((
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: crate::lexer::Tag::Id(variant),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::Includes(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: crate::lexer::Tag::Id(variant),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::SemiColon(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                ))(tokens)?;
                Ok((
                    remaining,
                    IncludesStatementDefinition {
                        ext_attrs: None,
                        lhs_identifier,
                        includes,
                        rhs_identifier,
                        semi_colon: termination,
                    },
                ))
            }
        }
    }
    mod interface {
        mod const_member {
            use nom::{IResult, Parser};
            use crate::{
                common::Identifier, lexer::keywords,
                literal::{FloatValueLit, IntegerLit},
                parser::{
                    eat::VariantToken, impl_nom_traits::Tokens,
                    r#type::primitive_type::PrimitiveType,
                },
            };
            pub enum ConstType<'a> {
                Primitive(PrimitiveType<'a>),
                Identifier(VariantToken<'a, Identifier<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for ConstType<'a> {
                #[inline]
                fn clone(&self) -> ConstType<'a> {
                    match self {
                        ConstType::Primitive(__self_0) => {
                            ConstType::Primitive(::core::clone::Clone::clone(__self_0))
                        }
                        ConstType::Identifier(__self_0) => {
                            ConstType::Identifier(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for ConstType<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ConstType::Primitive(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Primitive",
                                &__self_0,
                            )
                        }
                        ConstType::Identifier(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Identifier",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for ConstType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for ConstType<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<PrimitiveType<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, Identifier<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for ConstType<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for ConstType<'a> {
                #[inline]
                fn eq(&self, other: &ConstType<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                ConstType::Primitive(__self_0),
                                ConstType::Primitive(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                ConstType::Identifier(__self_0),
                                ConstType::Identifier(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for ConstType<'a> {
                #[inline]
                fn cmp(&self, other: &ConstType<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (
                                    ConstType::Primitive(__self_0),
                                    ConstType::Primitive(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    ConstType::Identifier(__self_0),
                                    ConstType::Identifier(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for ConstType<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &ConstType<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (
                                    ConstType::Primitive(__self_0),
                                    ConstType::Primitive(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    ConstType::Identifier(__self_0),
                                    ConstType::Identifier(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for ConstType<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        ConstType::Primitive(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        ConstType::Identifier(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl ConstType<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, ConstType<'token>> {
                    nom::branch::alt((
                        PrimitiveType::parse.map(ConstType::Primitive),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: crate::lexer::Tag::Id(variant),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(ConstType::Identifier),
                    ))(tokens)
                }
            }
            pub enum BooleanLit<'a> {
                True(VariantToken<'a, keywords::True<'a>>),
                False(VariantToken<'a, keywords::False<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for BooleanLit<'a> {
                #[inline]
                fn clone(&self) -> BooleanLit<'a> {
                    match self {
                        BooleanLit::True(__self_0) => {
                            BooleanLit::True(::core::clone::Clone::clone(__self_0))
                        }
                        BooleanLit::False(__self_0) => {
                            BooleanLit::False(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for BooleanLit<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        BooleanLit::True(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "True",
                                &__self_0,
                            )
                        }
                        BooleanLit::False(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "False",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for BooleanLit<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for BooleanLit<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::True<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::False<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for BooleanLit<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for BooleanLit<'a> {
                #[inline]
                fn eq(&self, other: &BooleanLit<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (BooleanLit::True(__self_0), BooleanLit::True(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            (
                                BooleanLit::False(__self_0),
                                BooleanLit::False(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for BooleanLit<'a> {
                #[inline]
                fn cmp(&self, other: &BooleanLit<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (BooleanLit::True(__self_0), BooleanLit::True(__arg1_0)) => {
                                    ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                                }
                                (
                                    BooleanLit::False(__self_0),
                                    BooleanLit::False(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for BooleanLit<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &BooleanLit<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (BooleanLit::True(__self_0), BooleanLit::True(__arg1_0)) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    BooleanLit::False(__self_0),
                                    BooleanLit::False(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for BooleanLit<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        BooleanLit::True(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        BooleanLit::False(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl BooleanLit<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, BooleanLit<'token>> {
                    nom::branch::alt((
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::True(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BooleanLit::True),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::False(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(BooleanLit::False),
                    ))(tokens)
                }
            }
            pub enum FloatLit<'a> {
                Value(VariantToken<'a, FloatValueLit<'a>>),
                NegInfinity(VariantToken<'a, keywords::NegInfinity<'a>>),
                Infinity(VariantToken<'a, keywords::Infinity<'a>>),
                NaN(VariantToken<'a, keywords::NaN<'a>>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for FloatLit<'a> {
                #[inline]
                fn clone(&self) -> FloatLit<'a> {
                    match self {
                        FloatLit::Value(__self_0) => {
                            FloatLit::Value(::core::clone::Clone::clone(__self_0))
                        }
                        FloatLit::NegInfinity(__self_0) => {
                            FloatLit::NegInfinity(::core::clone::Clone::clone(__self_0))
                        }
                        FloatLit::Infinity(__self_0) => {
                            FloatLit::Infinity(::core::clone::Clone::clone(__self_0))
                        }
                        FloatLit::NaN(__self_0) => {
                            FloatLit::NaN(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for FloatLit<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        FloatLit::Value(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Value",
                                &__self_0,
                            )
                        }
                        FloatLit::NegInfinity(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "NegInfinity",
                                &__self_0,
                            )
                        }
                        FloatLit::Infinity(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Infinity",
                                &__self_0,
                            )
                        }
                        FloatLit::NaN(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "NaN",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for FloatLit<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for FloatLit<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, FloatValueLit<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::NegInfinity<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Infinity<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::NaN<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for FloatLit<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for FloatLit<'a> {
                #[inline]
                fn eq(&self, other: &FloatLit<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            (
                                FloatLit::NegInfinity(__self_0),
                                FloatLit::NegInfinity(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FloatLit::Infinity(__self_0),
                                FloatLit::Infinity(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for FloatLit<'a> {
                #[inline]
                fn cmp(&self, other: &FloatLit<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                                    ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                                }
                                (
                                    FloatLit::NegInfinity(__self_0),
                                    FloatLit::NegInfinity(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    FloatLit::Infinity(__self_0),
                                    FloatLit::Infinity(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                                    ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for FloatLit<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &FloatLit<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (FloatLit::Value(__self_0), FloatLit::Value(__arg1_0)) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    FloatLit::NegInfinity(__self_0),
                                    FloatLit::NegInfinity(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    FloatLit::Infinity(__self_0),
                                    FloatLit::Infinity(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (FloatLit::NaN(__self_0), FloatLit::NaN(__arg1_0)) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for FloatLit<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        FloatLit::Value(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        FloatLit::NegInfinity(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        FloatLit::Infinity(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        FloatLit::NaN(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl FloatLit<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, FloatLit<'token>> {
                    nom::branch::alt((
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: crate::lexer::Tag::Dec(variant),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(FloatLit::Value),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::NegInfinity(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(FloatLit::NegInfinity),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Infinity(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(FloatLit::Infinity),
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::NaN(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(FloatLit::NaN),
                    ))(tokens)
                }
            }
            pub enum ConstValue<'a> {
                Integer(VariantToken<'a, IntegerLit<'a>>),
                Boolean(BooleanLit<'a>),
                Float(FloatLit<'a>),
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for ConstValue<'a> {
                #[inline]
                fn clone(&self) -> ConstValue<'a> {
                    match self {
                        ConstValue::Integer(__self_0) => {
                            ConstValue::Integer(::core::clone::Clone::clone(__self_0))
                        }
                        ConstValue::Boolean(__self_0) => {
                            ConstValue::Boolean(::core::clone::Clone::clone(__self_0))
                        }
                        ConstValue::Float(__self_0) => {
                            ConstValue::Float(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for ConstValue<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        ConstValue::Integer(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Integer",
                                &__self_0,
                            )
                        }
                        ConstValue::Boolean(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Boolean",
                                &__self_0,
                            )
                        }
                        ConstValue::Float(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Float",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for ConstValue<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for ConstValue<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, IntegerLit<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<BooleanLit<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<FloatLit<'a>>;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for ConstValue<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for ConstValue<'a> {
                #[inline]
                fn eq(&self, other: &ConstValue<'a>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                ConstValue::Integer(__self_0),
                                ConstValue::Integer(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                ConstValue::Boolean(__self_0),
                                ConstValue::Boolean(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                ConstValue::Float(__self_0),
                                ConstValue::Float(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for ConstValue<'a> {
                #[inline]
                fn cmp(&self, other: &ConstValue<'a>) -> ::core::cmp::Ordering {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                        ::core::cmp::Ordering::Equal => {
                            match (self, other) {
                                (
                                    ConstValue::Integer(__self_0),
                                    ConstValue::Integer(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    ConstValue::Boolean(__self_0),
                                    ConstValue::Boolean(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                (
                                    ConstValue::Float(__self_0),
                                    ConstValue::Float(__arg1_0),
                                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for ConstValue<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &ConstValue<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &__self_tag,
                        &__arg1_tag,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match (self, other) {
                                (
                                    ConstValue::Integer(__self_0),
                                    ConstValue::Integer(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    ConstValue::Boolean(__self_0),
                                    ConstValue::Boolean(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                (
                                    ConstValue::Float(__self_0),
                                    ConstValue::Float(__arg1_0),
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                                }
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for ConstValue<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    ::core::hash::Hash::hash(&__self_tag, state);
                    match self {
                        ConstValue::Integer(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        ConstValue::Boolean(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                        ConstValue::Float(__self_0) => {
                            ::core::hash::Hash::hash(__self_0, state)
                        }
                    }
                }
            }
            impl ConstValue<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, ConstValue<'token>> {
                    nom::branch::alt((
                        crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: crate::lexer::Tag::Int(variant),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            })
                            .map(ConstValue::Integer),
                        BooleanLit::parse.map(ConstValue::Boolean),
                        FloatLit::parse.map(ConstValue::Float),
                    ))(tokens)
                }
            }
            pub struct ConstMember<'a> {
                r#const: VariantToken<'a, keywords::Const<'a>>,
                const_type: ConstType<'a>,
                identifier: VariantToken<'a, Identifier<'a>>,
                assign: VariantToken<'a, keywords::Assign<'a>>,
                const_value: ConstValue<'a>,
                semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for ConstMember<'a> {
                #[inline]
                fn clone(&self) -> ConstMember<'a> {
                    ConstMember {
                        r#const: ::core::clone::Clone::clone(&self.r#const),
                        const_type: ::core::clone::Clone::clone(&self.const_type),
                        identifier: ::core::clone::Clone::clone(&self.identifier),
                        assign: ::core::clone::Clone::clone(&self.assign),
                        const_value: ::core::clone::Clone::clone(&self.const_value),
                        semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for ConstMember<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "const",
                        "const_type",
                        "identifier",
                        "assign",
                        "const_value",
                        "semi_colon",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &&self.r#const,
                        &&self.const_type,
                        &&self.identifier,
                        &&self.assign,
                        &&self.const_value,
                        &&self.semi_colon,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "ConstMember",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for ConstMember<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for ConstMember<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Const<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<ConstType<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, Identifier<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Assign<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<ConstValue<'a>>;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::SemiColon<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for ConstMember<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for ConstMember<'a> {
                #[inline]
                fn eq(&self, other: &ConstMember<'a>) -> bool {
                    self.r#const == other.r#const && self.const_type == other.const_type
                        && self.identifier == other.identifier
                        && self.assign == other.assign
                        && self.const_value == other.const_value
                        && self.semi_colon == other.semi_colon
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for ConstMember<'a> {
                #[inline]
                fn cmp(&self, other: &ConstMember<'a>) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(&self.r#const, &other.r#const) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.const_type,
                                &other.const_type,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.const_value,
                                                        &other.const_value,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for ConstMember<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &ConstMember<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.r#const,
                        &other.r#const,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.const_type,
                                &other.const_type,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.identifier,
                                        &other.identifier,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.assign,
                                                &other.assign,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.const_value,
                                                        &other.const_value,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.semi_colon,
                                                                &other.semi_colon,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for ConstMember<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.r#const, state);
                    ::core::hash::Hash::hash(&self.const_type, state);
                    ::core::hash::Hash::hash(&self.identifier, state);
                    ::core::hash::Hash::hash(&self.assign, state);
                    ::core::hash::Hash::hash(&self.const_value, state);
                    ::core::hash::Hash::hash(&self.semi_colon, state)
                }
            }
            impl ConstMember<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, ConstMember<'token>> {
                    let (
                        tokens,
                        (
                            r#const,
                            const_type,
                            identifier,
                            assign,
                            const_value,
                            semi_colon,
                        ),
                    ) = nom::sequence::tuple((
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Const(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                        nom::combinator::cut(ConstType::parse),
                        nom::combinator::cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: crate::lexer::Tag::Id(variant),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                        nom::combinator::cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::Assign(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                        nom::combinator::cut(ConstValue::parse),
                        nom::combinator::cut(
                            crate::parser::eat::annotate(|
                                input: Tokens,
                            | -> IResult<Tokens, _> {
                                use crate::lexer::{keywords::Keyword, Tag};
                                use nom::{InputIter, Slice};
                                match input.iter_elements().next() {
                                    Some(
                                        crate::lexer::Token {
                                            tag: Tag::Kw(Keyword::SemiColon(variant)),
                                            trivia,
                                        },
                                    ) => {
                                        Ok((
                                            input.slice(1..),
                                            crate::parser::eat::VariantToken {
                                                variant,
                                                trivia,
                                            },
                                        ))
                                    }
                                    _ => {
                                        Err(
                                            nom::Err::Error(nom::error::Error {
                                                input,
                                                code: nom::error::ErrorKind::Char,
                                            }),
                                        )
                                    }
                                }
                            }),
                        ),
                    ))(tokens)?;
                    Ok((
                        tokens,
                        ConstMember {
                            r#const,
                            const_type,
                            identifier,
                            assign,
                            const_value,
                            semi_colon,
                        },
                    ))
                }
            }
        }
        pub use const_member::ConstMember;
        mod stringifier {
            use nom::IResult;
            use crate::{
                lexer::keywords, parser::{eat::VariantToken, impl_nom_traits::Tokens},
            };
            pub struct StringifierOperation<'a> {
                stringifier: VariantToken<'a, keywords::Stringifier<'a>>,
                semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for StringifierOperation<'a> {
                #[inline]
                fn clone(&self) -> StringifierOperation<'a> {
                    StringifierOperation {
                        stringifier: ::core::clone::Clone::clone(&self.stringifier),
                        semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for StringifierOperation<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "StringifierOperation",
                        "stringifier",
                        &&self.stringifier,
                        "semi_colon",
                        &&self.semi_colon,
                    )
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralEq for StringifierOperation<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::Eq for StringifierOperation<'a> {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::Stringifier<'a>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<
                        VariantToken<'a, keywords::SemiColon<'a>>,
                    >;
                }
            }
            #[automatically_derived]
            impl<'a> ::core::marker::StructuralPartialEq for StringifierOperation<'a> {}
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialEq for StringifierOperation<'a> {
                #[inline]
                fn eq(&self, other: &StringifierOperation<'a>) -> bool {
                    self.stringifier == other.stringifier
                        && self.semi_colon == other.semi_colon
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::Ord for StringifierOperation<'a> {
                #[inline]
                fn cmp(
                    &self,
                    other: &StringifierOperation<'a>,
                ) -> ::core::cmp::Ordering {
                    match ::core::cmp::Ord::cmp(&self.stringifier, &other.stringifier) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::cmp::PartialOrd for StringifierOperation<'a> {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &StringifierOperation<'a>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.stringifier,
                        &other.stringifier,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.semi_colon,
                                &other.semi_colon,
                            )
                        }
                        cmp => cmp,
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::hash::Hash for StringifierOperation<'a> {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.stringifier, state);
                    ::core::hash::Hash::hash(&self.semi_colon, state)
                }
            }
            impl StringifierOperation<'_> {
                pub fn parse<'slice, 'token>(
                    tokens: Tokens<'slice, 'token>,
                ) -> IResult<Tokens<'slice, 'token>, StringifierOperation<'token>> {
                    let (tokens, (stringifier, semi_colon)) = nom::sequence::tuple((
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::Stringifier(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::SemiColon(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ))(tokens)?;
                    Ok((
                        tokens,
                        StringifierOperation {
                            stringifier,
                            semi_colon,
                        },
                    ))
                }
            }
        }
        pub use stringifier::StringifierOperation;
        use nom::{IResult, Parser};
        use crate::{common::Identifier, lexer::keywords};
        use super::{
            eat::VariantToken, extended_attributes::ExtendedAttributeList,
            impl_nom_traits::Tokens,
        };
        #[allow(clippy::large_enum_variant)]
        pub enum InterfaceMember<'a> {
            Const(ConstMember<'a>),
            Stringifier(StringifierOperation<'a>),
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::clone::Clone for InterfaceMember<'a> {
            #[inline]
            fn clone(&self) -> InterfaceMember<'a> {
                match self {
                    InterfaceMember::Const(__self_0) => {
                        InterfaceMember::Const(::core::clone::Clone::clone(__self_0))
                    }
                    InterfaceMember::Stringifier(__self_0) => {
                        InterfaceMember::Stringifier(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::fmt::Debug for InterfaceMember<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    InterfaceMember::Const(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Const",
                            &__self_0,
                        )
                    }
                    InterfaceMember::Stringifier(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Stringifier",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[allow(clippy::large_enum_variant)]
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for InterfaceMember<'a> {}
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::cmp::Eq for InterfaceMember<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
                let _: ::core::cmp::AssertParamIsEq<StringifierOperation<'a>>;
            }
        }
        #[allow(clippy::large_enum_variant)]
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for InterfaceMember<'a> {}
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::cmp::PartialEq for InterfaceMember<'a> {
            #[inline]
            fn eq(&self, other: &InterfaceMember<'a>) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            InterfaceMember::Const(__self_0),
                            InterfaceMember::Const(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            InterfaceMember::Stringifier(__self_0),
                            InterfaceMember::Stringifier(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::cmp::Ord for InterfaceMember<'a> {
            #[inline]
            fn cmp(&self, other: &InterfaceMember<'a>) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                InterfaceMember::Const(__self_0),
                                InterfaceMember::Const(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                InterfaceMember::Stringifier(__self_0),
                                InterfaceMember::Stringifier(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::cmp::PartialOrd for InterfaceMember<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &InterfaceMember<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match (self, other) {
                            (
                                InterfaceMember::Const(__self_0),
                                InterfaceMember::Const(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            (
                                InterfaceMember::Stringifier(__self_0),
                                InterfaceMember::Stringifier(__arg1_0),
                            ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::hash::Hash for InterfaceMember<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state);
                match self {
                    InterfaceMember::Const(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    InterfaceMember::Stringifier(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        impl InterfaceMember<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, InterfaceMember<'token>> {
                nom::branch::alt((
                    ConstMember::parse.map(InterfaceMember::Const),
                    StringifierOperation::parse.map(InterfaceMember::Stringifier),
                ))(tokens)
            }
        }
        pub struct InterfaceDefinition<'a> {
            pub ext_attrs: Option<ExtendedAttributeList<'a>>,
            pub interface: VariantToken<'a, keywords::Interface<'a>>,
            pub identifier: VariantToken<'a, Identifier<'a>>,
            pub open_brace: VariantToken<'a, keywords::OpenBrace<'a>>,
            pub body: Vec<InterfaceMember<'a>>,
            pub close_brace: VariantToken<'a, keywords::CloseBrace<'a>>,
            pub semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for InterfaceDefinition<'a> {
            #[inline]
            fn clone(&self) -> InterfaceDefinition<'a> {
                InterfaceDefinition {
                    ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                    interface: ::core::clone::Clone::clone(&self.interface),
                    identifier: ::core::clone::Clone::clone(&self.identifier),
                    open_brace: ::core::clone::Clone::clone(&self.open_brace),
                    body: ::core::clone::Clone::clone(&self.body),
                    close_brace: ::core::clone::Clone::clone(&self.close_brace),
                    semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for InterfaceDefinition<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "ext_attrs",
                    "interface",
                    "identifier",
                    "open_brace",
                    "body",
                    "close_brace",
                    "semi_colon",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &&self.ext_attrs,
                    &&self.interface,
                    &&self.identifier,
                    &&self.open_brace,
                    &&self.body,
                    &&self.close_brace,
                    &&self.semi_colon,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "InterfaceDefinition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for InterfaceDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for InterfaceDefinition<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Interface<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::OpenBrace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<Vec<InterfaceMember<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::CloseBrace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::SemiColon<'a>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for InterfaceDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for InterfaceDefinition<'a> {
            #[inline]
            fn eq(&self, other: &InterfaceDefinition<'a>) -> bool {
                self.ext_attrs == other.ext_attrs && self.interface == other.interface
                    && self.identifier == other.identifier
                    && self.open_brace == other.open_brace && self.body == other.body
                    && self.close_brace == other.close_brace
                    && self.semi_colon == other.semi_colon
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for InterfaceDefinition<'a> {
            #[inline]
            fn cmp(&self, other: &InterfaceDefinition<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.open_brace,
                                            &other.open_brace,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        match ::core::cmp::Ord::cmp(
                                                            &self.close_brace,
                                                            &other.close_brace,
                                                        ) {
                                                            ::core::cmp::Ordering::Equal => {
                                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for InterfaceDefinition<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &InterfaceDefinition<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.ext_attrs,
                    &other.ext_attrs,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.interface,
                            &other.interface,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.open_brace,
                                            &other.open_brace,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.body,
                                                    &other.body,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        match ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.close_brace,
                                                            &other.close_brace,
                                                        ) {
                                                            ::core::option::Option::Some(
                                                                ::core::cmp::Ordering::Equal,
                                                            ) => {
                                                                ::core::cmp::PartialOrd::partial_cmp(
                                                                    &self.semi_colon,
                                                                    &other.semi_colon,
                                                                )
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for InterfaceDefinition<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.ext_attrs, state);
                ::core::hash::Hash::hash(&self.interface, state);
                ::core::hash::Hash::hash(&self.identifier, state);
                ::core::hash::Hash::hash(&self.open_brace, state);
                ::core::hash::Hash::hash(&self.body, state);
                ::core::hash::Hash::hash(&self.close_brace, state);
                ::core::hash::Hash::hash(&self.semi_colon, state)
            }
        }
        impl InterfaceDefinition<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, InterfaceDefinition<'token>> {
                let (tokens, (interface, identifier, open_brace, members, semi_colon)) = nom::sequence::tuple((
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::Interface(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: crate::lexer::Tag::Id(variant),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::OpenBrace(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::multi::many_till(
                        InterfaceMember::parse,
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::CloseBrace(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::SemiColon(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                ))(tokens)?;
                Ok((
                    tokens,
                    InterfaceDefinition {
                        ext_attrs: None,
                        interface,
                        identifier,
                        open_brace,
                        body: members.0,
                        close_brace: members.1,
                        semi_colon,
                    },
                ))
            }
        }
    }
    mod namespace {
        use nom::{IResult, Parser};
        use crate::{common::Identifier, lexer::keywords};
        use super::{
            eat::VariantToken, extended_attributes::ExtendedAttributeList,
            impl_nom_traits::Tokens, interface::ConstMember,
        };
        #[allow(clippy::large_enum_variant)]
        pub enum NamespaceMember<'a> {
            Const(ConstMember<'a>),
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::clone::Clone for NamespaceMember<'a> {
            #[inline]
            fn clone(&self) -> NamespaceMember<'a> {
                match self {
                    NamespaceMember::Const(__self_0) => {
                        NamespaceMember::Const(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::fmt::Debug for NamespaceMember<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    NamespaceMember::Const(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Const",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[allow(clippy::large_enum_variant)]
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for NamespaceMember<'a> {}
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::cmp::Eq for NamespaceMember<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ConstMember<'a>>;
            }
        }
        #[allow(clippy::large_enum_variant)]
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for NamespaceMember<'a> {}
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::cmp::PartialEq for NamespaceMember<'a> {
            #[inline]
            fn eq(&self, other: &NamespaceMember<'a>) -> bool {
                match (self, other) {
                    (
                        NamespaceMember::Const(__self_0),
                        NamespaceMember::Const(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::cmp::Ord for NamespaceMember<'a> {
            #[inline]
            fn cmp(&self, other: &NamespaceMember<'a>) -> ::core::cmp::Ordering {
                match (self, other) {
                    (
                        NamespaceMember::Const(__self_0),
                        NamespaceMember::Const(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::cmp::PartialOrd for NamespaceMember<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &NamespaceMember<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match (self, other) {
                    (
                        NamespaceMember::Const(__self_0),
                        NamespaceMember::Const(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                }
            }
        }
        #[automatically_derived]
        #[allow(clippy::large_enum_variant)]
        impl<'a> ::core::hash::Hash for NamespaceMember<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match self {
                    NamespaceMember::Const(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        impl NamespaceMember<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, NamespaceMember<'token>> {
                nom::branch::alt((
                    ConstMember::parse.map(NamespaceMember::Const),
                ))(tokens)
            }
        }
        pub struct NamespaceDefinition<'a> {
            pub ext_attrs: Option<ExtendedAttributeList<'a>>,
            pub namespace: VariantToken<'a, keywords::Namespace<'a>>,
            pub identifier: VariantToken<'a, Identifier<'a>>,
            pub open_brace: VariantToken<'a, keywords::OpenBrace<'a>>,
            pub body: Vec<NamespaceMember<'a>>,
            pub close_brace: VariantToken<'a, keywords::CloseBrace<'a>>,
            pub semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for NamespaceDefinition<'a> {
            #[inline]
            fn clone(&self) -> NamespaceDefinition<'a> {
                NamespaceDefinition {
                    ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                    namespace: ::core::clone::Clone::clone(&self.namespace),
                    identifier: ::core::clone::Clone::clone(&self.identifier),
                    open_brace: ::core::clone::Clone::clone(&self.open_brace),
                    body: ::core::clone::Clone::clone(&self.body),
                    close_brace: ::core::clone::Clone::clone(&self.close_brace),
                    semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for NamespaceDefinition<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "ext_attrs",
                    "namespace",
                    "identifier",
                    "open_brace",
                    "body",
                    "close_brace",
                    "semi_colon",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &&self.ext_attrs,
                    &&self.namespace,
                    &&self.identifier,
                    &&self.open_brace,
                    &&self.body,
                    &&self.close_brace,
                    &&self.semi_colon,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "NamespaceDefinition",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for NamespaceDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for NamespaceDefinition<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Namespace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::OpenBrace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<Vec<NamespaceMember<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::CloseBrace<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::SemiColon<'a>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for NamespaceDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for NamespaceDefinition<'a> {
            #[inline]
            fn eq(&self, other: &NamespaceDefinition<'a>) -> bool {
                self.ext_attrs == other.ext_attrs && self.namespace == other.namespace
                    && self.identifier == other.identifier
                    && self.open_brace == other.open_brace && self.body == other.body
                    && self.close_brace == other.close_brace
                    && self.semi_colon == other.semi_colon
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for NamespaceDefinition<'a> {
            #[inline]
            fn cmp(&self, other: &NamespaceDefinition<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.namespace, &other.namespace) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.open_brace,
                                            &other.open_brace,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.body, &other.body) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        match ::core::cmp::Ord::cmp(
                                                            &self.close_brace,
                                                            &other.close_brace,
                                                        ) {
                                                            ::core::cmp::Ordering::Equal => {
                                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for NamespaceDefinition<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &NamespaceDefinition<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.ext_attrs,
                    &other.ext_attrs,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.namespace,
                            &other.namespace,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.open_brace,
                                            &other.open_brace,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.body,
                                                    &other.body,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        match ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.close_brace,
                                                            &other.close_brace,
                                                        ) {
                                                            ::core::option::Option::Some(
                                                                ::core::cmp::Ordering::Equal,
                                                            ) => {
                                                                ::core::cmp::PartialOrd::partial_cmp(
                                                                    &self.semi_colon,
                                                                    &other.semi_colon,
                                                                )
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for NamespaceDefinition<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.ext_attrs, state);
                ::core::hash::Hash::hash(&self.namespace, state);
                ::core::hash::Hash::hash(&self.identifier, state);
                ::core::hash::Hash::hash(&self.open_brace, state);
                ::core::hash::Hash::hash(&self.body, state);
                ::core::hash::Hash::hash(&self.close_brace, state);
                ::core::hash::Hash::hash(&self.semi_colon, state)
            }
        }
        impl NamespaceDefinition<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, NamespaceDefinition<'token>> {
                let (tokens, (namespace, identifier, open_brace, members, semi_colon)) = nom::sequence::tuple((
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::Namespace(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: crate::lexer::Tag::Id(variant),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::OpenBrace(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::multi::many_till(
                        NamespaceMember::parse,
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::CloseBrace(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::SemiColon(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                ))(tokens)?;
                Ok((
                    tokens,
                    NamespaceDefinition {
                        ext_attrs: None,
                        namespace,
                        identifier,
                        open_brace,
                        body: members.0,
                        close_brace: members.1,
                        semi_colon,
                    },
                ))
            }
        }
    }
    mod typedef {
        use nom::IResult;
        use crate::{common::Identifier, lexer::keywords};
        use super::{
            eat::VariantToken, extended_attributes::ExtendedAttributeList,
            impl_nom_traits::Tokens, r#type::TypeWithExtendedAttributes,
        };
        pub struct TypedefDefinition<'a> {
            pub ext_attrs: Option<ExtendedAttributeList<'a>>,
            pub typedef: VariantToken<'a, keywords::Typedef<'a>>,
            pub r#type: TypeWithExtendedAttributes<'a>,
            pub identifier: VariantToken<'a, Identifier<'a>>,
            pub semi_colon: VariantToken<'a, keywords::SemiColon<'a>>,
        }
        #[automatically_derived]
        impl<'a> ::core::clone::Clone for TypedefDefinition<'a> {
            #[inline]
            fn clone(&self) -> TypedefDefinition<'a> {
                TypedefDefinition {
                    ext_attrs: ::core::clone::Clone::clone(&self.ext_attrs),
                    typedef: ::core::clone::Clone::clone(&self.typedef),
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                    identifier: ::core::clone::Clone::clone(&self.identifier),
                    semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::fmt::Debug for TypedefDefinition<'a> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "TypedefDefinition",
                    "ext_attrs",
                    &&self.ext_attrs,
                    "typedef",
                    &&self.typedef,
                    "type",
                    &&self.r#type,
                    "identifier",
                    &&self.identifier,
                    "semi_colon",
                    &&self.semi_colon,
                )
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralEq for TypedefDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::Eq for TypedefDefinition<'a> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::Typedef<'a>>,
                >;
                let _: ::core::cmp::AssertParamIsEq<TypeWithExtendedAttributes<'a>>;
                let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, Identifier<'a>>>;
                let _: ::core::cmp::AssertParamIsEq<
                    VariantToken<'a, keywords::SemiColon<'a>>,
                >;
            }
        }
        #[automatically_derived]
        impl<'a> ::core::marker::StructuralPartialEq for TypedefDefinition<'a> {}
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialEq for TypedefDefinition<'a> {
            #[inline]
            fn eq(&self, other: &TypedefDefinition<'a>) -> bool {
                self.ext_attrs == other.ext_attrs && self.typedef == other.typedef
                    && self.r#type == other.r#type && self.identifier == other.identifier
                    && self.semi_colon == other.semi_colon
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::Ord for TypedefDefinition<'a> {
            #[inline]
            fn cmp(&self, other: &TypedefDefinition<'a>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.ext_attrs, &other.ext_attrs) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.typedef, &other.typedef) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.r#type, &other.r#type) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.identifier,
                                            &other.identifier,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::cmp::PartialOrd for TypedefDefinition<'a> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TypedefDefinition<'a>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.ext_attrs,
                    &other.ext_attrs,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.typedef,
                            &other.typedef,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.r#type,
                                    &other.r#type,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.identifier,
                                            &other.identifier,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<'a> ::core::hash::Hash for TypedefDefinition<'a> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.ext_attrs, state);
                ::core::hash::Hash::hash(&self.typedef, state);
                ::core::hash::Hash::hash(&self.r#type, state);
                ::core::hash::Hash::hash(&self.identifier, state);
                ::core::hash::Hash::hash(&self.semi_colon, state)
            }
        }
        impl TypedefDefinition<'_> {
            pub fn parse<'slice, 'token>(
                tokens: Tokens<'slice, 'token>,
            ) -> IResult<Tokens<'slice, 'token>, TypedefDefinition<'token>> {
                let (tokens, (typedef, r#type, identifier, semi_colon)) = nom::sequence::tuple((
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use crate::lexer::{keywords::Keyword, Tag};
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: Tag::Kw(Keyword::Typedef(variant)),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    nom::combinator::cut(TypeWithExtendedAttributes::parse),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: crate::lexer::Tag::Id(variant),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                    nom::combinator::cut(
                        crate::parser::eat::annotate(|
                            input: Tokens,
                        | -> IResult<Tokens, _> {
                            use crate::lexer::{keywords::Keyword, Tag};
                            use nom::{InputIter, Slice};
                            match input.iter_elements().next() {
                                Some(
                                    crate::lexer::Token {
                                        tag: Tag::Kw(Keyword::SemiColon(variant)),
                                        trivia,
                                    },
                                ) => {
                                    Ok((
                                        input.slice(1..),
                                        crate::parser::eat::VariantToken {
                                            variant,
                                            trivia,
                                        },
                                    ))
                                }
                                _ => {
                                    Err(
                                        nom::Err::Error(nom::error::Error {
                                            input,
                                            code: nom::error::ErrorKind::Char,
                                        }),
                                    )
                                }
                            }
                        }),
                    ),
                ))(tokens)?;
                Ok((
                    tokens,
                    TypedefDefinition {
                        ext_attrs: None,
                        typedef,
                        r#type,
                        identifier,
                        semi_colon,
                    },
                ))
            }
        }
    }
    use nom::{IResult, InputIter, Parser};
    use crate::lexer::{lex, Token};
    use self::{
        callback::CallbackDefinition, dictionary::DictionaryDefinition,
        eat::VariantToken, enumeration::EnumDefinition,
        extended_attributes::ExtendedAttributeList,
        includes::IncludesStatementDefinition, interface::InterfaceDefinition,
        namespace::NamespaceDefinition, typedef::TypedefDefinition,
    };
    pub enum ErrorKind<'a> {
        Lexer(nom::Err<nom::error::Error<&'a str>>),
        Parser(nom::Err<nom::error::Error<Vec<Token<'a>>>>),
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for ErrorKind<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ErrorKind::Lexer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Lexer",
                        &__self_0,
                    )
                }
                ErrorKind::Parser(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Parser",
                        &__self_0,
                    )
                }
            }
        }
    }
    pub enum Definition<'a> {
        Callback(CallbackDefinition<'a>),
        Interface(InterfaceDefinition<'a>),
        Namespace(NamespaceDefinition<'a>),
        Dictionary(DictionaryDefinition<'a>),
        Enum(EnumDefinition<'a>),
        Typedef(TypedefDefinition<'a>),
        IncludesStatement(IncludesStatementDefinition<'a>),
        Eof(VariantToken<'a, ()>),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Definition<'a> {
        #[inline]
        fn clone(&self) -> Definition<'a> {
            match self {
                Definition::Callback(__self_0) => {
                    Definition::Callback(::core::clone::Clone::clone(__self_0))
                }
                Definition::Interface(__self_0) => {
                    Definition::Interface(::core::clone::Clone::clone(__self_0))
                }
                Definition::Namespace(__self_0) => {
                    Definition::Namespace(::core::clone::Clone::clone(__self_0))
                }
                Definition::Dictionary(__self_0) => {
                    Definition::Dictionary(::core::clone::Clone::clone(__self_0))
                }
                Definition::Enum(__self_0) => {
                    Definition::Enum(::core::clone::Clone::clone(__self_0))
                }
                Definition::Typedef(__self_0) => {
                    Definition::Typedef(::core::clone::Clone::clone(__self_0))
                }
                Definition::IncludesStatement(__self_0) => {
                    Definition::IncludesStatement(::core::clone::Clone::clone(__self_0))
                }
                Definition::Eof(__self_0) => {
                    Definition::Eof(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Definition<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Definition::Callback(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Callback",
                        &__self_0,
                    )
                }
                Definition::Interface(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Interface",
                        &__self_0,
                    )
                }
                Definition::Namespace(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Namespace",
                        &__self_0,
                    )
                }
                Definition::Dictionary(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dictionary",
                        &__self_0,
                    )
                }
                Definition::Enum(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Enum",
                        &__self_0,
                    )
                }
                Definition::Typedef(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Typedef",
                        &__self_0,
                    )
                }
                Definition::IncludesStatement(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "IncludesStatement",
                        &__self_0,
                    )
                }
                Definition::Eof(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Eof",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Definition<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Definition<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<CallbackDefinition<'a>>;
            let _: ::core::cmp::AssertParamIsEq<InterfaceDefinition<'a>>;
            let _: ::core::cmp::AssertParamIsEq<NamespaceDefinition<'a>>;
            let _: ::core::cmp::AssertParamIsEq<DictionaryDefinition<'a>>;
            let _: ::core::cmp::AssertParamIsEq<EnumDefinition<'a>>;
            let _: ::core::cmp::AssertParamIsEq<TypedefDefinition<'a>>;
            let _: ::core::cmp::AssertParamIsEq<IncludesStatementDefinition<'a>>;
            let _: ::core::cmp::AssertParamIsEq<VariantToken<'a, ()>>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Definition<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Definition<'a> {
        #[inline]
        fn eq(&self, other: &Definition<'a>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Definition::Callback(__self_0), Definition::Callback(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        Definition::Interface(__self_0),
                        Definition::Interface(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        Definition::Namespace(__self_0),
                        Definition::Namespace(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        Definition::Dictionary(__self_0),
                        Definition::Dictionary(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (Definition::Typedef(__self_0), Definition::Typedef(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        Definition::IncludesStatement(__self_0),
                        Definition::IncludesStatement(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (Definition::Eof(__self_0), Definition::Eof(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::Ord for Definition<'a> {
        #[inline]
        fn cmp(&self, other: &Definition<'a>) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (
                            Definition::Callback(__self_0),
                            Definition::Callback(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Definition::Interface(__self_0),
                            Definition::Interface(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Definition::Namespace(__self_0),
                            Definition::Namespace(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Definition::Dictionary(__self_0),
                            Definition::Dictionary(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (
                            Definition::Typedef(__self_0),
                            Definition::Typedef(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (
                            Definition::IncludesStatement(__self_0),
                            Definition::IncludesStatement(__arg1_0),
                        ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                        (Definition::Eof(__self_0), Definition::Eof(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialOrd for Definition<'a> {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Definition<'a>,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match (self, other) {
                        (
                            Definition::Callback(__self_0),
                            Definition::Callback(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Definition::Interface(__self_0),
                            Definition::Interface(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Definition::Namespace(__self_0),
                            Definition::Namespace(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Definition::Dictionary(__self_0),
                            Definition::Dictionary(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        (
                            Definition::Typedef(__self_0),
                            Definition::Typedef(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (
                            Definition::IncludesStatement(__self_0),
                            Definition::IncludesStatement(__arg1_0),
                        ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                        (Definition::Eof(__self_0), Definition::Eof(__arg1_0)) => {
                            ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Definition<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Definition::Callback(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Definition::Interface(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Definition::Namespace(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Definition::Dictionary(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Definition::Enum(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Definition::Typedef(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Definition::IncludesStatement(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                Definition::Eof(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    fn set_ext_attr<'a>(
        (ext_attrs, mut def): (Option<ExtendedAttributeList<'a>>, Definition<'a>),
    ) -> Definition<'a> {
        match &mut def {
            Definition::Callback(d) => {
                d.ext_attrs = ext_attrs;
            }
            Definition::Interface(d) => {
                d.ext_attrs = ext_attrs;
            }
            Definition::Namespace(d) => {
                d.ext_attrs = ext_attrs;
            }
            Definition::Dictionary(d) => {
                d.ext_attrs = ext_attrs;
            }
            Definition::Enum(d) => {
                d.ext_attrs = ext_attrs;
            }
            Definition::Typedef(d) => {
                d.ext_attrs = ext_attrs;
            }
            Definition::IncludesStatement(d) => {
                d.ext_attrs = ext_attrs;
            }
            Definition::Eof(_) => {
                ::core::panicking::panic_fmt(
                    ::core::fmt::Arguments::new_v1(&["Unexpected EOF"], &[]),
                )
            }
        }
        def
    }
    pub fn parse(input: &str) -> Result<Vec<Definition>, ErrorKind> {
        let tokens = lex(input).map_err(ErrorKind::Lexer)?;
        let (unread, (mut defs, eof)) = nom::sequence::tuple((
                nom::multi::many0(
                    nom::sequence::tuple((
                            nom::combinator::opt(ExtendedAttributeList::parse),
                            nom::branch::alt((
                                CallbackDefinition::parse.map(Definition::Callback),
                                InterfaceDefinition::parse.map(Definition::Interface),
                                NamespaceDefinition::parse.map(Definition::Namespace),
                                DictionaryDefinition::parse.map(Definition::Dictionary),
                                EnumDefinition::parse.map(Definition::Enum),
                                TypedefDefinition::parse.map(Definition::Typedef),
                                IncludesStatementDefinition::parse
                                    .map(Definition::IncludesStatement),
                            )),
                        ))
                        .map(set_ext_attr),
                ),
                nom::combinator::map(
                    crate::parser::eat::annotate(|input: Tokens| -> IResult<Tokens, _> {
                        use nom::{InputIter, Slice};
                        match input.iter_elements().next() {
                            Some(
                                crate::lexer::Token {
                                    tag: crate::lexer::Tag::Eof(variant),
                                    trivia,
                                },
                            ) => {
                                Ok((
                                    input.slice(1..),
                                    crate::parser::eat::VariantToken {
                                        variant,
                                        trivia,
                                    },
                                ))
                            }
                            _ => {
                                Err(
                                    nom::Err::Error(nom::error::Error {
                                        input,
                                        code: nom::error::ErrorKind::Char,
                                    }),
                                )
                            }
                        }
                    }),
                    Definition::Eof,
                ),
            ))(Tokens(&tokens[..]))
            .map_err(|err| match err {
                nom::Err::Incomplete(need) => {
                    ErrorKind::Parser(nom::Err::Incomplete(need))
                }
                nom::Err::Error(err) => {
                    ErrorKind::Parser(
                        nom::Err::Error(nom::error::Error {
                            code: err.code,
                            input: err.input.iter_elements().collect(),
                        }),
                    )
                }
                nom::Err::Failure(err) => {
                    ErrorKind::Parser(
                        nom::Err::Failure(nom::error::Error {
                            code: err.code,
                            input: err.input.iter_elements().collect(),
                        }),
                    )
                }
            })?;
        if !unread.0.is_empty() {
            ::core::panicking::panic("assertion failed: unread.0.is_empty()")
        }
        defs.push(eof);
        Ok(defs)
    }
}
/// A convenient parse function
///
/// ### Example
///
/// ```
/// extern crate weedle;
///
/// let parsed = weedle::parse("
///     interface Window {
///         readonly attribute Storage sessionStorage;
///     };
/// ").unwrap();
///
/// println!("{:?}", parsed);
/// ```
pub fn parse(raw: &str) -> Result<Definitions<'_>, Err<Error<&str>>> {
    let (remaining, parsed) = Definitions::parse(raw)?;
    if remaining.is_empty() || crate::whitespace::sp(remaining).is_ok() {
        Ok(parsed)
    } else {
        Err(
            nom::Err::Failure(Error {
                input: remaining,
                code: nom::error::ErrorKind::Fail,
            }),
        )
    }
}
pub trait Parse<'a>: Sized {
    fn parse(input: &'a str) -> IResult<&'a str, Self>;
}
/// Parses WebIDL definitions. It is the root struct for a complete WebIDL definition.
///
/// ### Example
/// ```
/// use weedle::{Definitions, Parse};
///
/// let (_, parsed) = Definitions::parse("
///     interface Window {
///         readonly attribute Storage sessionStorage;
///     };
/// ").unwrap();
///
/// println!("{:?}", parsed);
/// ```
///
/// It is recommended to use [`parse`](fn.parse.html) instead.
pub type Definitions<'a> = Vec<Definition<'a>>;
/// Parses a definition
pub enum Definition<'a> {
    Callback(CallbackDefinition<'a>),
    CallbackInterface(CallbackInterfaceDefinition<'a>),
    Interface(InterfaceDefinition<'a>),
    InterfaceMixin(InterfaceMixinDefinition<'a>),
    Namespace(NamespaceDefinition<'a>),
    Dictionary(DictionaryDefinition<'a>),
    PartialInterface(PartialInterfaceDefinition<'a>),
    PartialInterfaceMixin(PartialInterfaceMixinDefinition<'a>),
    PartialDictionary(PartialDictionaryDefinition<'a>),
    PartialNamespace(PartialNamespaceDefinition<'a>),
    Enum(EnumDefinition<'a>),
    Typedef(TypedefDefinition<'a>),
    IncludesStatement(IncludesStatementDefinition<'a>),
    Implements(ImplementsDefinition<'a>),
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for Definition<'a> {
    #[inline]
    fn clone(&self) -> Definition<'a> {
        match self {
            Definition::Callback(__self_0) => {
                Definition::Callback(::core::clone::Clone::clone(__self_0))
            }
            Definition::CallbackInterface(__self_0) => {
                Definition::CallbackInterface(::core::clone::Clone::clone(__self_0))
            }
            Definition::Interface(__self_0) => {
                Definition::Interface(::core::clone::Clone::clone(__self_0))
            }
            Definition::InterfaceMixin(__self_0) => {
                Definition::InterfaceMixin(::core::clone::Clone::clone(__self_0))
            }
            Definition::Namespace(__self_0) => {
                Definition::Namespace(::core::clone::Clone::clone(__self_0))
            }
            Definition::Dictionary(__self_0) => {
                Definition::Dictionary(::core::clone::Clone::clone(__self_0))
            }
            Definition::PartialInterface(__self_0) => {
                Definition::PartialInterface(::core::clone::Clone::clone(__self_0))
            }
            Definition::PartialInterfaceMixin(__self_0) => {
                Definition::PartialInterfaceMixin(::core::clone::Clone::clone(__self_0))
            }
            Definition::PartialDictionary(__self_0) => {
                Definition::PartialDictionary(::core::clone::Clone::clone(__self_0))
            }
            Definition::PartialNamespace(__self_0) => {
                Definition::PartialNamespace(::core::clone::Clone::clone(__self_0))
            }
            Definition::Enum(__self_0) => {
                Definition::Enum(::core::clone::Clone::clone(__self_0))
            }
            Definition::Typedef(__self_0) => {
                Definition::Typedef(::core::clone::Clone::clone(__self_0))
            }
            Definition::IncludesStatement(__self_0) => {
                Definition::IncludesStatement(::core::clone::Clone::clone(__self_0))
            }
            Definition::Implements(__self_0) => {
                Definition::Implements(::core::clone::Clone::clone(__self_0))
            }
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for Definition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            Definition::Callback(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Callback",
                    &__self_0,
                )
            }
            Definition::CallbackInterface(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CallbackInterface",
                    &__self_0,
                )
            }
            Definition::Interface(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Interface",
                    &__self_0,
                )
            }
            Definition::InterfaceMixin(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InterfaceMixin",
                    &__self_0,
                )
            }
            Definition::Namespace(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Namespace",
                    &__self_0,
                )
            }
            Definition::Dictionary(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Dictionary",
                    &__self_0,
                )
            }
            Definition::PartialInterface(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PartialInterface",
                    &__self_0,
                )
            }
            Definition::PartialInterfaceMixin(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PartialInterfaceMixin",
                    &__self_0,
                )
            }
            Definition::PartialDictionary(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PartialDictionary",
                    &__self_0,
                )
            }
            Definition::PartialNamespace(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PartialNamespace",
                    &__self_0,
                )
            }
            Definition::Enum(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Enum", &__self_0)
            }
            Definition::Typedef(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Typedef",
                    &__self_0,
                )
            }
            Definition::IncludesStatement(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "IncludesStatement",
                    &__self_0,
                )
            }
            Definition::Implements(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "Implements",
                    &__self_0,
                )
            }
        }
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for Definition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for Definition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<CallbackDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<CallbackInterfaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<InterfaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<InterfaceMixinDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<NamespaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<DictionaryDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<PartialInterfaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<PartialInterfaceMixinDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<PartialDictionaryDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<PartialNamespaceDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<EnumDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<TypedefDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<IncludesStatementDefinition<'a>>;
        let _: ::core::cmp::AssertParamIsEq<ImplementsDefinition<'a>>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for Definition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for Definition<'a> {
    #[inline]
    fn eq(&self, other: &Definition<'a>) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
            && match (self, other) {
                (Definition::Callback(__self_0), Definition::Callback(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    Definition::CallbackInterface(__self_0),
                    Definition::CallbackInterface(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (Definition::Interface(__self_0), Definition::Interface(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    Definition::InterfaceMixin(__self_0),
                    Definition::InterfaceMixin(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (Definition::Namespace(__self_0), Definition::Namespace(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (Definition::Dictionary(__self_0), Definition::Dictionary(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    Definition::PartialInterface(__self_0),
                    Definition::PartialInterface(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    Definition::PartialInterfaceMixin(__self_0),
                    Definition::PartialInterfaceMixin(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    Definition::PartialDictionary(__self_0),
                    Definition::PartialDictionary(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (
                    Definition::PartialNamespace(__self_0),
                    Definition::PartialNamespace(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (Definition::Typedef(__self_0), Definition::Typedef(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (
                    Definition::IncludesStatement(__self_0),
                    Definition::IncludesStatement(__arg1_0),
                ) => *__self_0 == *__arg1_0,
                (Definition::Implements(__self_0), Definition::Implements(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                _ => unsafe { ::core::intrinsics::unreachable() }
            }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for Definition<'a> {
    #[inline]
    fn cmp(&self, other: &Definition<'a>) -> ::core::cmp::Ordering {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
            ::core::cmp::Ordering::Equal => {
                match (self, other) {
                    (Definition::Callback(__self_0), Definition::Callback(__arg1_0)) => {
                        ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                    }
                    (
                        Definition::CallbackInterface(__self_0),
                        Definition::CallbackInterface(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::Interface(__self_0),
                        Definition::Interface(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::InterfaceMixin(__self_0),
                        Definition::InterfaceMixin(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::Namespace(__self_0),
                        Definition::Namespace(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::Dictionary(__self_0),
                        Definition::Dictionary(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialInterface(__self_0),
                        Definition::PartialInterface(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialInterfaceMixin(__self_0),
                        Definition::PartialInterfaceMixin(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialDictionary(__self_0),
                        Definition::PartialDictionary(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialNamespace(__self_0),
                        Definition::PartialNamespace(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                        ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                    }
                    (Definition::Typedef(__self_0), Definition::Typedef(__arg1_0)) => {
                        ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                    }
                    (
                        Definition::IncludesStatement(__self_0),
                        Definition::IncludesStatement(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    (
                        Definition::Implements(__self_0),
                        Definition::Implements(__arg1_0),
                    ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for Definition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &Definition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match (self, other) {
                    (Definition::Callback(__self_0), Definition::Callback(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (
                        Definition::CallbackInterface(__self_0),
                        Definition::CallbackInterface(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::Interface(__self_0),
                        Definition::Interface(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::InterfaceMixin(__self_0),
                        Definition::InterfaceMixin(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::Namespace(__self_0),
                        Definition::Namespace(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::Dictionary(__self_0),
                        Definition::Dictionary(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialInterface(__self_0),
                        Definition::PartialInterface(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialInterfaceMixin(__self_0),
                        Definition::PartialInterfaceMixin(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialDictionary(__self_0),
                        Definition::PartialDictionary(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::PartialNamespace(__self_0),
                        Definition::PartialNamespace(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (Definition::Enum(__self_0), Definition::Enum(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (Definition::Typedef(__self_0), Definition::Typedef(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (
                        Definition::IncludesStatement(__self_0),
                        Definition::IncludesStatement(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Definition::Implements(__self_0),
                        Definition::Implements(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for Definition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        ::core::hash::Hash::hash(&__self_tag, state);
        match self {
            Definition::Callback(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::CallbackInterface(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::Interface(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::InterfaceMixin(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::Namespace(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::Dictionary(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::PartialInterface(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::PartialInterfaceMixin(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::PartialDictionary(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::PartialNamespace(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::Enum(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::Typedef(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            Definition::IncludesStatement(__self_0) => {
                ::core::hash::Hash::hash(__self_0, state)
            }
            Definition::Implements(__self_0) => ::core::hash::Hash::hash(__self_0, state),
        }
    }
}
/// Parses `[attributes]? callback identifier = type ( (arg1, arg2, ..., argN)? );`
pub struct CallbackDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub callback: crate::term::Callback,
    pub identifier: Identifier<'a>,
    pub assign: crate::term::Assign,
    pub return_type: ReturnType<'a>,
    pub arguments: Parenthesized<ArgumentList<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for CallbackDefinition<'a> {
    #[inline]
    fn clone(&self) -> CallbackDefinition<'a> {
        CallbackDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            callback: ::core::clone::Clone::clone(&self.callback),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            assign: ::core::clone::Clone::clone(&self.assign),
            return_type: ::core::clone::Clone::clone(&self.return_type),
            arguments: ::core::clone::Clone::clone(&self.arguments),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for CallbackDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "callback",
            "identifier",
            "assign",
            "return_type",
            "arguments",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.callback,
            &&self.identifier,
            &&self.assign,
            &&self.return_type,
            &&self.arguments,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "CallbackDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for CallbackDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for CallbackDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Callback>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Assign>;
        let _: ::core::cmp::AssertParamIsEq<ReturnType<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Parenthesized<ArgumentList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for CallbackDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for CallbackDefinition<'a> {
    #[inline]
    fn eq(&self, other: &CallbackDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.callback == other.callback
            && self.identifier == other.identifier && self.assign == other.assign
            && self.return_type == other.return_type && self.arguments == other.arguments
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for CallbackDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &CallbackDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.callback, &other.callback) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.assign, &other.assign) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.return_type,
                                            &other.return_type,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(
                                                    &self.arguments,
                                                    &other.arguments,
                                                ) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for CallbackDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &CallbackDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.callback,
                    &other.callback,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.assign,
                                    &other.assign,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.return_type,
                                            &other.return_type,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.arguments,
                                                    &other.arguments,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.semi_colon,
                                                            &other.semi_colon,
                                                        )
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for CallbackDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.callback, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.assign, state);
        ::core::hash::Hash::hash(&self.return_type, state);
        ::core::hash::Hash::hash(&self.arguments, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for CallbackDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Callback as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, callback)) => {
                            use nom::lib::std::result::Result::*;
                            match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, identifier)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <crate::term::Assign as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, assign)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <ReturnType<'a> as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, return_type)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <Parenthesized<
                                                        ArgumentList<'a>,
                                                    > as crate::Parse<'a>>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, arguments)) => {
                                                            use nom::lib::std::result::Result::*;
                                                            match <crate::term::SemiColon as crate::Parse<
                                                                'a,
                                                            >>::parse(i) {
                                                                Err(e) => Err(e),
                                                                Ok((i, semi_colon)) => {
                                                                    use nom::lib::std::result::Result::Ok;
                                                                    Ok((
                                                                        i,
                                                                        Self {
                                                                            attributes,
                                                                            callback,
                                                                            identifier,
                                                                            assign,
                                                                            return_type,
                                                                            arguments,
                                                                            semi_colon,
                                                                        },
                                                                    ))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? callback interface identifier ( : inheritance )? { members };`
pub struct CallbackInterfaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub callback: crate::term::Callback,
    pub interface: crate::term::Interface,
    pub identifier: Identifier<'a>,
    pub inheritance: Option<Inheritance<'a>>,
    pub members: Braced<InterfaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for CallbackInterfaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> CallbackInterfaceDefinition<'a> {
        CallbackInterfaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            callback: ::core::clone::Clone::clone(&self.callback),
            interface: ::core::clone::Clone::clone(&self.interface),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            inheritance: ::core::clone::Clone::clone(&self.inheritance),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for CallbackInterfaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "callback",
            "interface",
            "identifier",
            "inheritance",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.callback,
            &&self.interface,
            &&self.identifier,
            &&self.inheritance,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "CallbackInterfaceDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for CallbackInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for CallbackInterfaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Callback>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Option<Inheritance<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<InterfaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for CallbackInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for CallbackInterfaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &CallbackInterfaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.callback == other.callback
            && self.interface == other.interface && self.identifier == other.identifier
            && self.inheritance == other.inheritance && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for CallbackInterfaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &CallbackInterfaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.callback, &other.callback) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.inheritance,
                                            &other.inheritance,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for CallbackInterfaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &CallbackInterfaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.callback,
                    &other.callback,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.interface,
                            &other.interface,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.inheritance,
                                            &other.inheritance,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.members,
                                                    &other.members,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.semi_colon,
                                                            &other.semi_colon,
                                                        )
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for CallbackInterfaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.callback, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.inheritance, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for CallbackInterfaceDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Callback as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, callback)) => {
                            use nom::lib::std::result::Result::*;
                            match <crate::term::Interface as crate::Parse<
                                'a,
                            >>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, interface)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, identifier)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <Option<
                                                Inheritance<'a>,
                                            > as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, inheritance)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <Braced<
                                                        InterfaceMembers<'a>,
                                                    > as crate::Parse<'a>>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, members)) => {
                                                            use nom::lib::std::result::Result::*;
                                                            match <crate::term::SemiColon as crate::Parse<
                                                                'a,
                                                            >>::parse(i) {
                                                                Err(e) => Err(e),
                                                                Ok((i, semi_colon)) => {
                                                                    use nom::lib::std::result::Result::Ok;
                                                                    Ok((
                                                                        i,
                                                                        Self {
                                                                            attributes,
                                                                            callback,
                                                                            interface,
                                                                            identifier,
                                                                            inheritance,
                                                                            members,
                                                                            semi_colon,
                                                                        },
                                                                    ))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? interface identifier ( : inheritance )? { members };`
pub struct InterfaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub interface: crate::term::Interface,
    pub identifier: Identifier<'a>,
    pub inheritance: Option<Inheritance<'a>>,
    pub members: Braced<InterfaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for InterfaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> InterfaceDefinition<'a> {
        InterfaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            interface: ::core::clone::Clone::clone(&self.interface),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            inheritance: ::core::clone::Clone::clone(&self.inheritance),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for InterfaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "interface",
            "identifier",
            "inheritance",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.interface,
            &&self.identifier,
            &&self.inheritance,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "InterfaceDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for InterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for InterfaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Option<Inheritance<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<InterfaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for InterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for InterfaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &InterfaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.interface == other.interface
            && self.identifier == other.identifier
            && self.inheritance == other.inheritance && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for InterfaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &InterfaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.inheritance,
                                    &other.inheritance,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for InterfaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &InterfaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.interface,
                    &other.interface,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.inheritance,
                                    &other.inheritance,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for InterfaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.inheritance, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for InterfaceDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Interface as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, interface)) => {
                            use nom::lib::std::result::Result::*;
                            match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, identifier)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Option<
                                        Inheritance<'a>,
                                    > as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, inheritance)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <Braced<
                                                InterfaceMembers<'a>,
                                            > as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, members)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <crate::term::SemiColon as crate::Parse<
                                                        'a,
                                                    >>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, semi_colon)) => {
                                                            use nom::lib::std::result::Result::Ok;
                                                            Ok((
                                                                i,
                                                                Self {
                                                                    attributes,
                                                                    interface,
                                                                    identifier,
                                                                    inheritance,
                                                                    members,
                                                                    semi_colon,
                                                                },
                                                            ))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? interface mixin identifier { members };`
pub struct InterfaceMixinDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub interface: crate::term::Interface,
    pub mixin: crate::term::Mixin,
    pub identifier: Identifier<'a>,
    pub members: Braced<MixinMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for InterfaceMixinDefinition<'a> {
    #[inline]
    fn clone(&self) -> InterfaceMixinDefinition<'a> {
        InterfaceMixinDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            interface: ::core::clone::Clone::clone(&self.interface),
            mixin: ::core::clone::Clone::clone(&self.mixin),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for InterfaceMixinDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "interface",
            "mixin",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.interface,
            &&self.mixin,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "InterfaceMixinDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for InterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for InterfaceMixinDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Mixin>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<MixinMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for InterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for InterfaceMixinDefinition<'a> {
    #[inline]
    fn eq(&self, other: &InterfaceMixinDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.interface == other.interface
            && self.mixin == other.mixin && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for InterfaceMixinDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &InterfaceMixinDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.mixin, &other.mixin) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for InterfaceMixinDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &InterfaceMixinDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.interface,
                    &other.interface,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.mixin,
                            &other.mixin,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for InterfaceMixinDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.mixin, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for InterfaceMixinDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Interface as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, interface)) => {
                            use nom::lib::std::result::Result::*;
                            match <crate::term::Mixin as crate::Parse<'a>>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, mixin)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, identifier)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <Braced<
                                                MixinMembers<'a>,
                                            > as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, members)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <crate::term::SemiColon as crate::Parse<
                                                        'a,
                                                    >>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, semi_colon)) => {
                                                            use nom::lib::std::result::Result::Ok;
                                                            Ok((
                                                                i,
                                                                Self {
                                                                    attributes,
                                                                    interface,
                                                                    mixin,
                                                                    identifier,
                                                                    members,
                                                                    semi_colon,
                                                                },
                                                            ))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? namespace identifier { members };`
pub struct NamespaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub namespace: crate::term::Namespace,
    pub identifier: Identifier<'a>,
    pub members: Braced<NamespaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for NamespaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> NamespaceDefinition<'a> {
        NamespaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            namespace: ::core::clone::Clone::clone(&self.namespace),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for NamespaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "NamespaceDefinition",
            "attributes",
            &&self.attributes,
            "namespace",
            &&self.namespace,
            "identifier",
            &&self.identifier,
            "members",
            &&self.members,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for NamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for NamespaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Namespace>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<NamespaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for NamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for NamespaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &NamespaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.namespace == other.namespace
            && self.identifier == other.identifier && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for NamespaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &NamespaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.namespace, &other.namespace) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for NamespaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &NamespaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.namespace,
                    &other.namespace,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.members,
                                    &other.members,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for NamespaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.namespace, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for NamespaceDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Namespace as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, namespace)) => {
                            use nom::lib::std::result::Result::*;
                            match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, identifier)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Braced<
                                        NamespaceMembers<'a>,
                                    > as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, members)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <crate::term::SemiColon as crate::Parse<
                                                'a,
                                            >>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, semi_colon)) => {
                                                    use nom::lib::std::result::Result::Ok;
                                                    Ok((
                                                        i,
                                                        Self {
                                                            attributes,
                                                            namespace,
                                                            identifier,
                                                            members,
                                                            semi_colon,
                                                        },
                                                    ))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? dictionary identifier ( : inheritance )? { members };`
pub struct DictionaryDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub dictionary: crate::term::Dictionary,
    pub identifier: Identifier<'a>,
    pub inheritance: Option<Inheritance<'a>>,
    pub members: Braced<DictionaryMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for DictionaryDefinition<'a> {
    #[inline]
    fn clone(&self) -> DictionaryDefinition<'a> {
        DictionaryDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            dictionary: ::core::clone::Clone::clone(&self.dictionary),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            inheritance: ::core::clone::Clone::clone(&self.inheritance),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for DictionaryDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "dictionary",
            "identifier",
            "inheritance",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.dictionary,
            &&self.identifier,
            &&self.inheritance,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "DictionaryDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for DictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for DictionaryDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Dictionary>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Option<Inheritance<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<DictionaryMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for DictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for DictionaryDefinition<'a> {
    #[inline]
    fn eq(&self, other: &DictionaryDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.dictionary == other.dictionary
            && self.identifier == other.identifier
            && self.inheritance == other.inheritance && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for DictionaryDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &DictionaryDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.dictionary, &other.dictionary) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.inheritance,
                                    &other.inheritance,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for DictionaryDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &DictionaryDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.dictionary,
                    &other.dictionary,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.inheritance,
                                    &other.inheritance,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for DictionaryDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.dictionary, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.inheritance, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for DictionaryDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Dictionary as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, dictionary)) => {
                            use nom::lib::std::result::Result::*;
                            match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, identifier)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Option<
                                        Inheritance<'a>,
                                    > as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, inheritance)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <Braced<
                                                DictionaryMembers<'a>,
                                            > as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, members)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <crate::term::SemiColon as crate::Parse<
                                                        'a,
                                                    >>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, semi_colon)) => {
                                                            use nom::lib::std::result::Result::Ok;
                                                            Ok((
                                                                i,
                                                                Self {
                                                                    attributes,
                                                                    dictionary,
                                                                    identifier,
                                                                    inheritance,
                                                                    members,
                                                                    semi_colon,
                                                                },
                                                            ))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? partial interface identifier { members };`
pub struct PartialInterfaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub partial: crate::term::Partial,
    pub interface: crate::term::Interface,
    pub identifier: Identifier<'a>,
    pub members: Braced<InterfaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for PartialInterfaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> PartialInterfaceDefinition<'a> {
        PartialInterfaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            partial: ::core::clone::Clone::clone(&self.partial),
            interface: ::core::clone::Clone::clone(&self.interface),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for PartialInterfaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "partial",
            "interface",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.partial,
            &&self.interface,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "PartialInterfaceDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for PartialInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for PartialInterfaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Partial>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<InterfaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for PartialInterfaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for PartialInterfaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &PartialInterfaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.partial == other.partial
            && self.interface == other.interface && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for PartialInterfaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &PartialInterfaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.partial, &other.partial) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for PartialInterfaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &PartialInterfaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.partial,
                    &other.partial,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.interface,
                            &other.interface,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for PartialInterfaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.partial, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for PartialInterfaceDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Partial as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, partial)) => {
                            use nom::lib::std::result::Result::*;
                            match <crate::term::Interface as crate::Parse<
                                'a,
                            >>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, interface)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, identifier)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <Braced<
                                                InterfaceMembers<'a>,
                                            > as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, members)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <crate::term::SemiColon as crate::Parse<
                                                        'a,
                                                    >>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, semi_colon)) => {
                                                            use nom::lib::std::result::Result::Ok;
                                                            Ok((
                                                                i,
                                                                Self {
                                                                    attributes,
                                                                    partial,
                                                                    interface,
                                                                    identifier,
                                                                    members,
                                                                    semi_colon,
                                                                },
                                                            ))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? partial interface mixin identifier { members };`
pub struct PartialInterfaceMixinDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub partial: crate::term::Partial,
    pub interface: crate::term::Interface,
    pub mixin: crate::term::Mixin,
    pub identifier: Identifier<'a>,
    pub members: Braced<MixinMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    fn clone(&self) -> PartialInterfaceMixinDefinition<'a> {
        PartialInterfaceMixinDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            partial: ::core::clone::Clone::clone(&self.partial),
            interface: ::core::clone::Clone::clone(&self.interface),
            mixin: ::core::clone::Clone::clone(&self.mixin),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for PartialInterfaceMixinDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "partial",
            "interface",
            "mixin",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.partial,
            &&self.interface,
            &&self.mixin,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "PartialInterfaceMixinDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for PartialInterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Partial>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Interface>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Mixin>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<MixinMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for PartialInterfaceMixinDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    fn eq(&self, other: &PartialInterfaceMixinDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.partial == other.partial
            && self.interface == other.interface && self.mixin == other.mixin
            && self.identifier == other.identifier && self.members == other.members
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &PartialInterfaceMixinDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.partial, &other.partial) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.interface, &other.interface) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.mixin, &other.mixin) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.identifier,
                                            &other.identifier,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for PartialInterfaceMixinDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &PartialInterfaceMixinDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.partial,
                    &other.partial,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.interface,
                            &other.interface,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.mixin,
                                    &other.mixin,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.identifier,
                                            &other.identifier,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.members,
                                                    &other.members,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.semi_colon,
                                                            &other.semi_colon,
                                                        )
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for PartialInterfaceMixinDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.partial, state);
        ::core::hash::Hash::hash(&self.interface, state);
        ::core::hash::Hash::hash(&self.mixin, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for PartialInterfaceMixinDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Partial as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, partial)) => {
                            use nom::lib::std::result::Result::*;
                            match <crate::term::Interface as crate::Parse<
                                'a,
                            >>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, interface)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <crate::term::Mixin as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, mixin)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, identifier)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <Braced<
                                                        MixinMembers<'a>,
                                                    > as crate::Parse<'a>>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, members)) => {
                                                            use nom::lib::std::result::Result::*;
                                                            match <crate::term::SemiColon as crate::Parse<
                                                                'a,
                                                            >>::parse(i) {
                                                                Err(e) => Err(e),
                                                                Ok((i, semi_colon)) => {
                                                                    use nom::lib::std::result::Result::Ok;
                                                                    Ok((
                                                                        i,
                                                                        Self {
                                                                            attributes,
                                                                            partial,
                                                                            interface,
                                                                            mixin,
                                                                            identifier,
                                                                            members,
                                                                            semi_colon,
                                                                        },
                                                                    ))
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? partial dictionary identifier { members };`
pub struct PartialDictionaryDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub partial: crate::term::Partial,
    pub dictionary: crate::term::Dictionary,
    pub identifier: Identifier<'a>,
    pub members: Braced<DictionaryMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for PartialDictionaryDefinition<'a> {
    #[inline]
    fn clone(&self) -> PartialDictionaryDefinition<'a> {
        PartialDictionaryDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            partial: ::core::clone::Clone::clone(&self.partial),
            dictionary: ::core::clone::Clone::clone(&self.dictionary),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for PartialDictionaryDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "partial",
            "dictionary",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.partial,
            &&self.dictionary,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "PartialDictionaryDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for PartialDictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for PartialDictionaryDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Partial>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Dictionary>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<DictionaryMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for PartialDictionaryDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for PartialDictionaryDefinition<'a> {
    #[inline]
    fn eq(&self, other: &PartialDictionaryDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.partial == other.partial
            && self.dictionary == other.dictionary && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for PartialDictionaryDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &PartialDictionaryDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.partial, &other.partial) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.dictionary,
                            &other.dictionary,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for PartialDictionaryDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &PartialDictionaryDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.partial,
                    &other.partial,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.dictionary,
                            &other.dictionary,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for PartialDictionaryDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.partial, state);
        ::core::hash::Hash::hash(&self.dictionary, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for PartialDictionaryDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Partial as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, partial)) => {
                            use nom::lib::std::result::Result::*;
                            match <crate::term::Dictionary as crate::Parse<
                                'a,
                            >>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, dictionary)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, identifier)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <Braced<
                                                DictionaryMembers<'a>,
                                            > as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, members)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <crate::term::SemiColon as crate::Parse<
                                                        'a,
                                                    >>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, semi_colon)) => {
                                                            use nom::lib::std::result::Result::Ok;
                                                            Ok((
                                                                i,
                                                                Self {
                                                                    attributes,
                                                                    partial,
                                                                    dictionary,
                                                                    identifier,
                                                                    members,
                                                                    semi_colon,
                                                                },
                                                            ))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? partial namespace identifier { members };`
pub struct PartialNamespaceDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub partial: crate::term::Partial,
    pub namespace: crate::term::Namespace,
    pub identifier: Identifier<'a>,
    pub members: Braced<NamespaceMembers<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for PartialNamespaceDefinition<'a> {
    #[inline]
    fn clone(&self) -> PartialNamespaceDefinition<'a> {
        PartialNamespaceDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            partial: ::core::clone::Clone::clone(&self.partial),
            namespace: ::core::clone::Clone::clone(&self.namespace),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            members: ::core::clone::Clone::clone(&self.members),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for PartialNamespaceDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "attributes",
            "partial",
            "namespace",
            "identifier",
            "members",
            "semi_colon",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &&self.attributes,
            &&self.partial,
            &&self.namespace,
            &&self.identifier,
            &&self.members,
            &&self.semi_colon,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "PartialNamespaceDefinition",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for PartialNamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for PartialNamespaceDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Partial>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Namespace>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<NamespaceMembers<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for PartialNamespaceDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for PartialNamespaceDefinition<'a> {
    #[inline]
    fn eq(&self, other: &PartialNamespaceDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.partial == other.partial
            && self.namespace == other.namespace && self.identifier == other.identifier
            && self.members == other.members && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for PartialNamespaceDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &PartialNamespaceDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.partial, &other.partial) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.namespace, &other.namespace) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.members, &other.members) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for PartialNamespaceDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &PartialNamespaceDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.partial,
                    &other.partial,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.namespace,
                            &other.namespace,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.members,
                                            &other.members,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.semi_colon,
                                                    &other.semi_colon,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for PartialNamespaceDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.partial, state);
        ::core::hash::Hash::hash(&self.namespace, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.members, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for PartialNamespaceDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Partial as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, partial)) => {
                            use nom::lib::std::result::Result::*;
                            match <crate::term::Namespace as crate::Parse<
                                'a,
                            >>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, namespace)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, identifier)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <Braced<
                                                NamespaceMembers<'a>,
                                            > as crate::Parse<'a>>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, members)) => {
                                                    use nom::lib::std::result::Result::*;
                                                    match <crate::term::SemiColon as crate::Parse<
                                                        'a,
                                                    >>::parse(i) {
                                                        Err(e) => Err(e),
                                                        Ok((i, semi_colon)) => {
                                                            use nom::lib::std::result::Result::Ok;
                                                            Ok((
                                                                i,
                                                                Self {
                                                                    attributes,
                                                                    partial,
                                                                    namespace,
                                                                    identifier,
                                                                    members,
                                                                    semi_colon,
                                                                },
                                                            ))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? enum identifier { values };`
pub struct EnumDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub enum_: crate::term::Enum,
    pub identifier: Identifier<'a>,
    pub values: Braced<EnumValueList<'a>>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for EnumDefinition<'a> {
    #[inline]
    fn clone(&self) -> EnumDefinition<'a> {
        EnumDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            enum_: ::core::clone::Clone::clone(&self.enum_),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            values: ::core::clone::Clone::clone(&self.values),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for EnumDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "EnumDefinition",
            "attributes",
            &&self.attributes,
            "enum_",
            &&self.enum_,
            "identifier",
            &&self.identifier,
            "values",
            &&self.values,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for EnumDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for EnumDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Enum>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Braced<EnumValueList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for EnumDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for EnumDefinition<'a> {
    #[inline]
    fn eq(&self, other: &EnumDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.enum_ == other.enum_
            && self.identifier == other.identifier && self.values == other.values
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for EnumDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &EnumDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.enum_, &other.enum_) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.values, &other.values) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for EnumDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &EnumDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(&self.enum_, &other.enum_) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.identifier,
                            &other.identifier,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.values,
                                    &other.values,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for EnumDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.enum_, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.values, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for EnumDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Enum as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, enum_)) => {
                            use nom::lib::std::result::Result::*;
                            match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, identifier)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Braced<
                                        EnumValueList<'a>,
                                    > as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, values)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <crate::term::SemiColon as crate::Parse<
                                                'a,
                                            >>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, semi_colon)) => {
                                                    use nom::lib::std::result::Result::Ok;
                                                    Ok((
                                                        i,
                                                        Self {
                                                            attributes,
                                                            enum_,
                                                            identifier,
                                                            values,
                                                            semi_colon,
                                                        },
                                                    ))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? typedef attributedtype identifier;`
pub struct TypedefDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub typedef: crate::term::Typedef,
    pub type_: AttributedType<'a>,
    pub identifier: Identifier<'a>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for TypedefDefinition<'a> {
    #[inline]
    fn clone(&self) -> TypedefDefinition<'a> {
        TypedefDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            typedef: ::core::clone::Clone::clone(&self.typedef),
            type_: ::core::clone::Clone::clone(&self.type_),
            identifier: ::core::clone::Clone::clone(&self.identifier),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for TypedefDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "TypedefDefinition",
            "attributes",
            &&self.attributes,
            "typedef",
            &&self.typedef,
            "type_",
            &&self.type_,
            "identifier",
            &&self.identifier,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for TypedefDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for TypedefDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Typedef>;
        let _: ::core::cmp::AssertParamIsEq<AttributedType<'a>>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for TypedefDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for TypedefDefinition<'a> {
    #[inline]
    fn eq(&self, other: &TypedefDefinition<'a>) -> bool {
        self.attributes == other.attributes && self.typedef == other.typedef
            && self.type_ == other.type_ && self.identifier == other.identifier
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for TypedefDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &TypedefDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(&self.typedef, &other.typedef) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.type_, &other.type_) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for TypedefDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &TypedefDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.typedef,
                    &other.typedef,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.type_,
                            &other.type_,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.identifier,
                                    &other.identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for TypedefDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.typedef, state);
        ::core::hash::Hash::hash(&self.type_, state);
        ::core::hash::Hash::hash(&self.identifier, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for TypedefDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <crate::term::Typedef as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, typedef)) => {
                            use nom::lib::std::result::Result::*;
                            match <AttributedType<'a> as crate::Parse<'a>>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, type_)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, identifier)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <crate::term::SemiColon as crate::Parse<
                                                'a,
                                            >>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, semi_colon)) => {
                                                    use nom::lib::std::result::Result::Ok;
                                                    Ok((
                                                        i,
                                                        Self {
                                                            attributes,
                                                            typedef,
                                                            type_,
                                                            identifier,
                                                            semi_colon,
                                                        },
                                                    ))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? identifier includes identifier;`
pub struct IncludesStatementDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub lhs_identifier: Identifier<'a>,
    pub includes: crate::term::Includes,
    pub rhs_identifier: Identifier<'a>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for IncludesStatementDefinition<'a> {
    #[inline]
    fn clone(&self) -> IncludesStatementDefinition<'a> {
        IncludesStatementDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            lhs_identifier: ::core::clone::Clone::clone(&self.lhs_identifier),
            includes: ::core::clone::Clone::clone(&self.includes),
            rhs_identifier: ::core::clone::Clone::clone(&self.rhs_identifier),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for IncludesStatementDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "IncludesStatementDefinition",
            "attributes",
            &&self.attributes,
            "lhs_identifier",
            &&self.lhs_identifier,
            "includes",
            &&self.includes,
            "rhs_identifier",
            &&self.rhs_identifier,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for IncludesStatementDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for IncludesStatementDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Includes>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for IncludesStatementDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for IncludesStatementDefinition<'a> {
    #[inline]
    fn eq(&self, other: &IncludesStatementDefinition<'a>) -> bool {
        self.attributes == other.attributes
            && self.lhs_identifier == other.lhs_identifier
            && self.includes == other.includes
            && self.rhs_identifier == other.rhs_identifier
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for IncludesStatementDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &IncludesStatementDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(
                    &self.lhs_identifier,
                    &other.lhs_identifier,
                ) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.includes, &other.includes) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.rhs_identifier,
                                    &other.rhs_identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for IncludesStatementDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &IncludesStatementDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.lhs_identifier,
                    &other.lhs_identifier,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.includes,
                            &other.includes,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.rhs_identifier,
                                    &other.rhs_identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for IncludesStatementDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.lhs_identifier, state);
        ::core::hash::Hash::hash(&self.includes, state);
        ::core::hash::Hash::hash(&self.rhs_identifier, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for IncludesStatementDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, lhs_identifier)) => {
                            use nom::lib::std::result::Result::*;
                            match <crate::term::Includes as crate::Parse<'a>>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, includes)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, rhs_identifier)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <crate::term::SemiColon as crate::Parse<
                                                'a,
                                            >>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, semi_colon)) => {
                                                    use nom::lib::std::result::Result::Ok;
                                                    Ok((
                                                        i,
                                                        Self {
                                                            attributes,
                                                            lhs_identifier,
                                                            includes,
                                                            rhs_identifier,
                                                            semi_colon,
                                                        },
                                                    ))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
/// Parses `[attributes]? identifier implements identifier;`
pub struct ImplementsDefinition<'a> {
    pub attributes: Option<ExtendedAttributeList<'a>>,
    pub lhs_identifier: Identifier<'a>,
    pub includes: crate::term::Implements,
    pub rhs_identifier: Identifier<'a>,
    pub semi_colon: crate::term::SemiColon,
}
#[automatically_derived]
impl<'a> ::core::clone::Clone for ImplementsDefinition<'a> {
    #[inline]
    fn clone(&self) -> ImplementsDefinition<'a> {
        ImplementsDefinition {
            attributes: ::core::clone::Clone::clone(&self.attributes),
            lhs_identifier: ::core::clone::Clone::clone(&self.lhs_identifier),
            includes: ::core::clone::Clone::clone(&self.includes),
            rhs_identifier: ::core::clone::Clone::clone(&self.rhs_identifier),
            semi_colon: ::core::clone::Clone::clone(&self.semi_colon),
        }
    }
}
#[automatically_derived]
impl<'a> ::core::fmt::Debug for ImplementsDefinition<'a> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "ImplementsDefinition",
            "attributes",
            &&self.attributes,
            "lhs_identifier",
            &&self.lhs_identifier,
            "includes",
            &&self.includes,
            "rhs_identifier",
            &&self.rhs_identifier,
            "semi_colon",
            &&self.semi_colon,
        )
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralEq for ImplementsDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::Eq for ImplementsDefinition<'a> {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<Option<ExtendedAttributeList<'a>>>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::Implements>;
        let _: ::core::cmp::AssertParamIsEq<Identifier<'a>>;
        let _: ::core::cmp::AssertParamIsEq<crate::term::SemiColon>;
    }
}
#[automatically_derived]
impl<'a> ::core::marker::StructuralPartialEq for ImplementsDefinition<'a> {}
#[automatically_derived]
impl<'a> ::core::cmp::PartialEq for ImplementsDefinition<'a> {
    #[inline]
    fn eq(&self, other: &ImplementsDefinition<'a>) -> bool {
        self.attributes == other.attributes
            && self.lhs_identifier == other.lhs_identifier
            && self.includes == other.includes
            && self.rhs_identifier == other.rhs_identifier
            && self.semi_colon == other.semi_colon
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::Ord for ImplementsDefinition<'a> {
    #[inline]
    fn cmp(&self, other: &ImplementsDefinition<'a>) -> ::core::cmp::Ordering {
        match ::core::cmp::Ord::cmp(&self.attributes, &other.attributes) {
            ::core::cmp::Ordering::Equal => {
                match ::core::cmp::Ord::cmp(
                    &self.lhs_identifier,
                    &other.lhs_identifier,
                ) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.includes, &other.includes) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.rhs_identifier,
                                    &other.rhs_identifier,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(&self.semi_colon, &other.semi_colon)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::cmp::PartialOrd for ImplementsDefinition<'a> {
    #[inline]
    fn partial_cmp(
        &self,
        other: &ImplementsDefinition<'a>,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        match ::core::cmp::PartialOrd::partial_cmp(&self.attributes, &other.attributes) {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.lhs_identifier,
                    &other.lhs_identifier,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.includes,
                            &other.includes,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.rhs_identifier,
                                    &other.rhs_identifier,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.semi_colon,
                                            &other.semi_colon,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl<'a> ::core::hash::Hash for ImplementsDefinition<'a> {
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.attributes, state);
        ::core::hash::Hash::hash(&self.lhs_identifier, state);
        ::core::hash::Hash::hash(&self.includes, state);
        ::core::hash::Hash::hash(&self.rhs_identifier, state);
        ::core::hash::Hash::hash(&self.semi_colon, state)
    }
}
impl<'a> crate::Parse<'a> for ImplementsDefinition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        {
            use nom::lib::std::result::Result::*;
            match <Option<ExtendedAttributeList<'a>> as crate::Parse<'a>>::parse(input) {
                Err(e) => Err(e),
                Ok((i, attributes)) => {
                    use nom::lib::std::result::Result::*;
                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                        Err(e) => Err(e),
                        Ok((i, lhs_identifier)) => {
                            use nom::lib::std::result::Result::*;
                            match <crate::term::Implements as crate::Parse<
                                'a,
                            >>::parse(i) {
                                Err(e) => Err(e),
                                Ok((i, includes)) => {
                                    use nom::lib::std::result::Result::*;
                                    match <Identifier<'a> as crate::Parse<'a>>::parse(i) {
                                        Err(e) => Err(e),
                                        Ok((i, rhs_identifier)) => {
                                            use nom::lib::std::result::Result::*;
                                            match <crate::term::SemiColon as crate::Parse<
                                                'a,
                                            >>::parse(i) {
                                                Err(e) => Err(e),
                                                Ok((i, semi_colon)) => {
                                                    use nom::lib::std::result::Result::Ok;
                                                    Ok((
                                                        i,
                                                        Self {
                                                            attributes,
                                                            lhs_identifier,
                                                            includes,
                                                            rhs_identifier,
                                                            semi_colon,
                                                        },
                                                    ))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
impl<'a> From<CallbackDefinition<'a>> for Definition<'a> {
    fn from(x: CallbackDefinition<'a>) -> Self {
        Definition::Callback(x)
    }
}
impl<'a> From<CallbackInterfaceDefinition<'a>> for Definition<'a> {
    fn from(x: CallbackInterfaceDefinition<'a>) -> Self {
        Definition::CallbackInterface(x)
    }
}
impl<'a> From<InterfaceDefinition<'a>> for Definition<'a> {
    fn from(x: InterfaceDefinition<'a>) -> Self {
        Definition::Interface(x)
    }
}
impl<'a> From<InterfaceMixinDefinition<'a>> for Definition<'a> {
    fn from(x: InterfaceMixinDefinition<'a>) -> Self {
        Definition::InterfaceMixin(x)
    }
}
impl<'a> From<NamespaceDefinition<'a>> for Definition<'a> {
    fn from(x: NamespaceDefinition<'a>) -> Self {
        Definition::Namespace(x)
    }
}
impl<'a> From<DictionaryDefinition<'a>> for Definition<'a> {
    fn from(x: DictionaryDefinition<'a>) -> Self {
        Definition::Dictionary(x)
    }
}
impl<'a> From<PartialInterfaceDefinition<'a>> for Definition<'a> {
    fn from(x: PartialInterfaceDefinition<'a>) -> Self {
        Definition::PartialInterface(x)
    }
}
impl<'a> From<PartialInterfaceMixinDefinition<'a>> for Definition<'a> {
    fn from(x: PartialInterfaceMixinDefinition<'a>) -> Self {
        Definition::PartialInterfaceMixin(x)
    }
}
impl<'a> From<PartialDictionaryDefinition<'a>> for Definition<'a> {
    fn from(x: PartialDictionaryDefinition<'a>) -> Self {
        Definition::PartialDictionary(x)
    }
}
impl<'a> From<PartialNamespaceDefinition<'a>> for Definition<'a> {
    fn from(x: PartialNamespaceDefinition<'a>) -> Self {
        Definition::PartialNamespace(x)
    }
}
impl<'a> From<EnumDefinition<'a>> for Definition<'a> {
    fn from(x: EnumDefinition<'a>) -> Self {
        Definition::Enum(x)
    }
}
impl<'a> From<TypedefDefinition<'a>> for Definition<'a> {
    fn from(x: TypedefDefinition<'a>) -> Self {
        Definition::Typedef(x)
    }
}
impl<'a> From<IncludesStatementDefinition<'a>> for Definition<'a> {
    fn from(x: IncludesStatementDefinition<'a>) -> Self {
        Definition::IncludesStatement(x)
    }
}
impl<'a> From<ImplementsDefinition<'a>> for Definition<'a> {
    fn from(x: ImplementsDefinition<'a>) -> Self {
        Definition::Implements(x)
    }
}
impl<'a> crate::Parse<'a> for Definition<'a> {
    fn parse(input: &'a str) -> crate::IResult<&'a str, Self> {
        nom::branch::alt((
            nom::combinator::map(
                <CallbackDefinition<'a> as crate::Parse<'a>>::parse,
                From::from,
            ),
            nom::combinator::map(
                <CallbackInterfaceDefinition<'a> as crate::Parse<'a>>::parse,
                From::from,
            ),
            nom::branch::alt((
                nom::combinator::map(
                    <InterfaceDefinition<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::combinator::map(
                    <InterfaceMixinDefinition<'a> as crate::Parse<'a>>::parse,
                    From::from,
                ),
                nom::branch::alt((
                    nom::combinator::map(
                        <NamespaceDefinition<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::combinator::map(
                        <DictionaryDefinition<'a> as crate::Parse<'a>>::parse,
                        From::from,
                    ),
                    nom::branch::alt((
                        nom::combinator::map(
                            <PartialInterfaceDefinition<'a> as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::combinator::map(
                            <PartialInterfaceMixinDefinition<
                                'a,
                            > as crate::Parse<'a>>::parse,
                            From::from,
                        ),
                        nom::branch::alt((
                            nom::combinator::map(
                                <PartialDictionaryDefinition<
                                    'a,
                                > as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                            nom::combinator::map(
                                <PartialNamespaceDefinition<'a> as crate::Parse<'a>>::parse,
                                From::from,
                            ),
                            nom::branch::alt((
                                nom::combinator::map(
                                    <EnumDefinition<'a> as crate::Parse<'a>>::parse,
                                    From::from,
                                ),
                                nom::combinator::map(
                                    <TypedefDefinition<'a> as crate::Parse<'a>>::parse,
                                    From::from,
                                ),
                                nom::branch::alt((
                                    nom::combinator::map(
                                        <IncludesStatementDefinition<
                                            'a,
                                        > as crate::Parse<'a>>::parse,
                                        From::from,
                                    ),
                                    nom::combinator::map(
                                        <ImplementsDefinition<'a> as crate::Parse<'a>>::parse,
                                        From::from,
                                    ),
                                )),
                            )),
                        )),
                    )),
                )),
            )),
        ))(input)
    }
}
/// Parses a non-empty enum value list
pub type EnumValueList<'a> = PunctuatedNonEmpty<StringLit<'a>, crate::term::Comma>;
